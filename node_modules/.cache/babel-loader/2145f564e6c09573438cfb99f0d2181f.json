{"ast":null,"code":"import CACHE from \"./Cache.js\";\nimport Ed25519PrivateKey from \"./Ed25519PrivateKey.js\";\nimport BadMnemonicError from \"./BadMnemonicError.js\";\nimport BadMnemonicReason from \"./BadMnemonicReason.js\";\nimport legacyWords from \"./words/legacy.js\";\nimport bip39Words from \"./words/bip39.js\";\nimport nacl from \"tweetnacl\";\nimport * as sha256 from \"./primitive/sha256.js\";\nimport * as hmac from \"./primitive/hmac.js\";\nimport * as slip10 from \"./primitive/slip10.js\";\nimport * as bip32 from \"./primitive/bip32.js\";\nimport * as bip39 from \"./primitive/bip39.js\";\nimport * as entropy from \"./util/entropy.js\";\nimport * as random from \"./primitive/random.js\";\nimport EcdsaPrivateKey from \"./EcdsaPrivateKey.js\";\nimport * as ecdsa from \"./primitive/ecdsa.js\";\nconst ED25519_SEED_TEXT = \"ed25519 seed\";\nconst ECDSA_SEED_TEXT = \"Bitcoin seed\";\nexport const HARDEDED = 0x80000000; /// m/44'/3030'/0'/0' - All paths in EdDSA derivation are implicitly hardened.\n\nexport const HEDERA_PATH = [44, 3030, 0, 0]; /// m/44'/3030'/0'/0\n\nexport const SLIP44_ECDSA_HEDERA_PATH = [44 | HARDEDED, 3030 | HARDEDED, 0 | HARDEDED, 0]; /// m/44'/60'/0'/0\n\nexport const SLIP44_ECDSA_ETH_PATH = [44 | HARDEDED, 60 | HARDEDED, 0 | HARDEDED, 0, 0];\n/**\n * @typedef {import(\"./PrivateKey.js\").default} PrivateKey\n */\n\n/**\n * Multi-word mnemonic phrase (BIP-39).\n *\n * Compatible with the official Hedera mobile\n * wallets (24-words or 22-words) and BRD (12-words).\n */\n\nexport default class Mnemonic {\n  /**\n   * @param {Object} props\n   * @param {string[]} props.words\n   * @param {boolean} props.legacy\n   * @throws {BadMnemonicError}\n   * @hideconstructor\n   * @private\n   */\n  constructor(_ref) {\n    let {\n      words,\n      legacy\n    } = _ref;\n    this.words = words;\n    this._isLegacy = legacy;\n  }\n  /**\n   * Returns a new random 24-word mnemonic from the BIP-39\n   * standard English word list.\n   *\n   * @returns {Promise<Mnemonic>}\n   */\n\n\n  static generate() {\n    return Mnemonic._generate(24);\n  }\n  /**\n   * Returns a new random 12-word mnemonic from the BIP-39\n   * standard English word list.\n   *\n   * @returns {Promise<Mnemonic>}\n   */\n\n\n  static generate12() {\n    return Mnemonic._generate(12);\n  }\n  /**\n   * @param {number} length\n   * @returns {Promise<Mnemonic>}\n   */\n\n\n  static async _generate(length) {\n    // only 12-word or 24-word lengths are supported\n    let neededEntropy;\n    if (length === 12) neededEntropy = 16;else if (length === 24) neededEntropy = 32;else {\n      throw new Error(`unsupported phrase length ${length}, only 12 or 24 are supported`);\n    } // inlined from (ISC) with heavy alternations for modern crypto\n    // https://github.com/bitcoinjs/bip39/blob/8461e83677a1d2c685d0d5a9ba2a76bd228f74c6/ts_src/index.ts#L125\n\n    const seed = await random.bytesAsync(neededEntropy);\n    const entropyBits = bytesToBinary(Array.from(seed));\n    const checksumBits = await deriveChecksumBits(seed);\n    const bits = entropyBits + checksumBits;\n    const chunks = bits.match(/(.{1,11})/g);\n    const words = (chunks != null ? chunks : []).map(binary => bip39Words[binaryToByte(binary)]);\n    return new Mnemonic({\n      words,\n      legacy: false\n    });\n  }\n  /**\n   * Construct a mnemonic from a list of words. Handles 12, 22 (legacy), and 24 words.\n   *\n   * An exception of BadMnemonicError will be thrown if the mnemonic\n   * contains unknown words or fails the checksum. An invalid mnemonic\n   * can still be used to create private keys, the exception will\n   * contain the failing mnemonic in case you wish to ignore the\n   * validation error and continue.\n   *\n   * @param {string[]} words\n   * @throws {BadMnemonicError}\n   * @returns {Promise<Mnemonic>}\n   */\n\n\n  static fromWords(words) {\n    return new Mnemonic({\n      words,\n      legacy: words.length === 22\n    })._validate();\n  }\n  /**\n   * @deprecated - Use `toEd25519PrivateKey()` or `toEcdsaPrivateKey()` instead\n   * Recover a private key from this mnemonic phrase, with an\n   * optional passphrase.\n   * @param {string} [passphrase]\n   * @returns {Promise<PrivateKey>}\n   */\n\n\n  toPrivateKey() {\n    let passphrase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return this.toEd25519PrivateKey(passphrase);\n  }\n  /**\n   * Recover an Ed25519 private key from this mnemonic phrase, with an\n   * optional passphrase.\n   *\n   * @param {string} [passphrase]\n   * @param {number[]} [path]\n   * @returns {Promise<PrivateKey>}\n   */\n\n\n  async toEd25519PrivateKey() {\n    let passphrase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : HEDERA_PATH;\n\n    if (this._isLegacy) {\n      if (passphrase.length > 0) {\n        throw new Error(\"legacy 22-word mnemonics do not support passphrases\");\n      }\n\n      return this.toLegacyPrivateKey();\n    }\n\n    let {\n      keyData,\n      chainCode\n    } = await this._toKeyData(passphrase, ED25519_SEED_TEXT);\n\n    for (const index of path) {\n      ({\n        keyData,\n        chainCode\n      } = await slip10.derive(keyData, chainCode, index));\n    }\n\n    const keyPair = nacl.sign.keyPair.fromSeed(keyData);\n\n    if (CACHE.privateKeyConstructor == null) {\n      throw new Error(\"PrivateKey not found in cache\");\n    }\n\n    return CACHE.privateKeyConstructor(new Ed25519PrivateKey(keyPair, chainCode));\n  }\n  /**\n   * Recover an ECDSA private key from this mnemonic phrase, with an\n   * optional passphrase.\n   *\n   * @param {string} [passphrase]\n   * @param {number[]} [path]\n   * @returns {Promise<PrivateKey>}\n   */\n\n\n  async toEcdsaPrivateKey() {\n    let passphrase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : HEDERA_PATH;\n    let {\n      keyData,\n      chainCode\n    } = await this._toKeyData(passphrase, ECDSA_SEED_TEXT);\n\n    for (const index of path) {\n      ({\n        keyData,\n        chainCode\n      } = await bip32.derive(keyData, chainCode, index));\n    }\n\n    if (CACHE.privateKeyConstructor == null) {\n      throw new Error(\"PrivateKey not found in cache\");\n    }\n\n    return CACHE.privateKeyConstructor(new EcdsaPrivateKey(ecdsa.fromBytes(keyData), chainCode));\n  }\n  /**\n   * @param {string} passphrase\n   * @param {string} seedText\n   * @returns {Promise<{ keyData: Uint8Array; chainCode: Uint8Array }>} seedText\n   */\n\n\n  async _toKeyData(passphrase, seedText) {\n    const seed = await bip39.toSeed(this.words, passphrase);\n    const digest = await hmac.hash(hmac.HashAlgorithm.Sha512, seedText, seed);\n    return {\n      keyData: digest.subarray(0, 32),\n      chainCode: digest.subarray(32)\n    };\n  }\n  /**\n   * Recover a mnemonic phrase from a string, splitting on spaces. Handles 12, 22 (legacy), and 24 words.\n   *\n   * @param {string} mnemonic\n   * @returns {Promise<Mnemonic>}\n   */\n\n\n  static async fromString(mnemonic) {\n    return Mnemonic.fromWords(mnemonic.split(/\\s|,/));\n  }\n  /**\n   * @returns {Promise<Mnemonic>}\n   * @private\n   */\n\n\n  async _validate() {\n    //NOSONAR\n    // Validate that this is a valid BIP-39 mnemonic\n    // as generated by BIP-39's rules.\n    // Technically, invalid mnemonics can still be used to generate valid private keys,\n    // but if they became invalid due to user error then it will be difficult for the user\n    // to tell the difference unless they compare the generated keys.\n    // During validation, the following conditions are checked in order\n    //  1)) 24 or 12 words\n    //  2) All strings in {@link this.words} exist in the BIP-39\n    //     standard English word list (no normalization is done)\n    //  3) The calculated checksum for the mnemonic equals the\n    //     checksum encoded in the mnemonic\n    if (this._isLegacy) {\n      if (this.words.length !== 22) {\n        throw new BadMnemonicError(this, BadMnemonicReason.BadLength, []);\n      }\n\n      const unknownWordIndices = this.words.reduce((\n      /** @type {number[]} */\n      unknowns, word, index) => legacyWords.includes(word.toLowerCase()) ? unknowns : [...unknowns, index], []);\n\n      if (unknownWordIndices.length > 0) {\n        throw new BadMnemonicError(this, BadMnemonicReason.UnknownWords, unknownWordIndices);\n      }\n\n      const [seed, checksum] = entropy.legacy1(this.words, legacyWords);\n      const newChecksum = entropy.crc8(seed);\n\n      if (checksum !== newChecksum) {\n        throw new BadMnemonicError(this, BadMnemonicReason.ChecksumMismatch, []);\n      }\n    } else {\n      if (!(this.words.length === 12 || this.words.length === 24)) {\n        throw new BadMnemonicError(this, BadMnemonicReason.BadLength, []);\n      }\n\n      const unknownWordIndices = this.words.reduce((\n      /** @type {number[]} */\n      unknowns, word, index) => bip39Words.includes(word) ? unknowns : [...unknowns, index], []);\n\n      if (unknownWordIndices.length > 0) {\n        throw new BadMnemonicError(this, BadMnemonicReason.UnknownWords, unknownWordIndices);\n      } // FIXME: calculate checksum and compare\n      // https://github.com/bitcoinjs/bip39/blob/master/ts_src/index.ts#L112\n\n\n      const bits = this.words.map(word => {\n        return bip39Words.indexOf(word).toString(2).padStart(11, \"0\");\n      }).join(\"\");\n      const dividerIndex = Math.floor(bits.length / 33) * 32;\n      const entropyBits = bits.slice(0, dividerIndex);\n      const checksumBits = bits.slice(dividerIndex);\n      const entropyBitsRegex = entropyBits.match(/(.{1,8})/g);\n      const entropyBytes =\n      /** @type {RegExpMatchArray} */\n      entropyBitsRegex.map(binaryToByte);\n      const newChecksum = await deriveChecksumBits(Uint8Array.from(entropyBytes));\n\n      if (newChecksum !== checksumBits) {\n        throw new BadMnemonicError(this, BadMnemonicReason.ChecksumMismatch, []);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * @returns {Promise<PrivateKey>}\n   */\n\n\n  async toLegacyPrivateKey() {\n    let seed;\n\n    if (this._isLegacy) {\n      [seed] = entropy.legacy1(this.words, legacyWords);\n    } else {\n      seed = await entropy.legacy2(this.words, bip39Words);\n    }\n\n    if (CACHE.privateKeyFromBytes == null) {\n      throw new Error(\"PrivateKey not found in cache\");\n    }\n\n    return CACHE.privateKeyFromBytes(seed);\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  toString() {\n    return this.words.join(\" \");\n  }\n\n}\n/**\n * @param {string} bin\n * @returns {number}\n */\n\nfunction binaryToByte(bin) {\n  return parseInt(bin, 2);\n}\n/**\n * @param {number[]} bytes\n * @returns {string}\n */\n\n\nfunction bytesToBinary(bytes) {\n  return bytes.map(x => x.toString(2).padStart(8, \"0\")).join(\"\");\n}\n/**\n * @param {Uint8Array} entropyBuffer\n * @returns {Promise<string>}\n */\n\n\nasync function deriveChecksumBits(entropyBuffer) {\n  const ENT = entropyBuffer.length * 8;\n  const CS = ENT / 32;\n  const hash = await sha256.digest(entropyBuffer);\n  return bytesToBinary(Array.from(hash)).slice(0, CS);\n}","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/hbar-shop/hbar-shopify-coupon-client/node_modules/@hashgraph/cryptography/src/Mnemonic.js"],"names":["CACHE","Ed25519PrivateKey","BadMnemonicError","BadMnemonicReason","legacyWords","bip39Words","nacl","sha256","hmac","slip10","bip32","bip39","entropy","random","EcdsaPrivateKey","ecdsa","ED25519_SEED_TEXT","ECDSA_SEED_TEXT","HARDEDED","HEDERA_PATH","SLIP44_ECDSA_HEDERA_PATH","SLIP44_ECDSA_ETH_PATH","Mnemonic","constructor","words","legacy","_isLegacy","generate","_generate","generate12","length","neededEntropy","Error","seed","bytesAsync","entropyBits","bytesToBinary","Array","from","checksumBits","deriveChecksumBits","bits","chunks","match","map","binary","binaryToByte","fromWords","_validate","toPrivateKey","passphrase","toEd25519PrivateKey","path","toLegacyPrivateKey","keyData","chainCode","_toKeyData","index","derive","keyPair","sign","fromSeed","privateKeyConstructor","toEcdsaPrivateKey","fromBytes","seedText","toSeed","digest","hash","HashAlgorithm","Sha512","subarray","fromString","mnemonic","split","BadLength","unknownWordIndices","reduce","unknowns","word","includes","toLowerCase","UnknownWords","checksum","legacy1","newChecksum","crc8","ChecksumMismatch","indexOf","toString","padStart","join","dividerIndex","Math","floor","slice","entropyBitsRegex","entropyBytes","Uint8Array","legacy2","privateKeyFromBytes","bin","parseInt","bytes","x","entropyBuffer","ENT","CS"],"mappings":"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","sourcesContent":["import CACHE from \"./Cache.js\";\nimport Ed25519PrivateKey from \"./Ed25519PrivateKey.js\";\nimport BadMnemonicError from \"./BadMnemonicError.js\";\nimport BadMnemonicReason from \"./BadMnemonicReason.js\";\nimport legacyWords from \"./words/legacy.js\";\nimport bip39Words from \"./words/bip39.js\";\nimport nacl from \"tweetnacl\";\nimport * as sha256 from \"./primitive/sha256.js\";\nimport * as hmac from \"./primitive/hmac.js\";\nimport * as slip10 from \"./primitive/slip10.js\";\nimport * as bip32 from \"./primitive/bip32.js\";\nimport * as bip39 from \"./primitive/bip39.js\";\nimport * as entropy from \"./util/entropy.js\";\nimport * as random from \"./primitive/random.js\";\nimport EcdsaPrivateKey from \"./EcdsaPrivateKey.js\";\nimport * as ecdsa from \"./primitive/ecdsa.js\";\n\nconst ED25519_SEED_TEXT = \"ed25519 seed\";\nconst ECDSA_SEED_TEXT = \"Bitcoin seed\";\n\nexport const HARDEDED = 0x80000000;\n\n/// m/44'/3030'/0'/0' - All paths in EdDSA derivation are implicitly hardened.\nexport const HEDERA_PATH = [44, 3030, 0, 0];\n\n/// m/44'/3030'/0'/0\nexport const SLIP44_ECDSA_HEDERA_PATH = [\n    44 | HARDEDED,\n    3030 | HARDEDED,\n    0 | HARDEDED,\n    0,\n];\n\n/// m/44'/60'/0'/0\nexport const SLIP44_ECDSA_ETH_PATH = [\n    44 | HARDEDED,\n    60 | HARDEDED,\n    0 | HARDEDED,\n    0,\n    0,\n];\n\n/**\n * @typedef {import(\"./PrivateKey.js\").default} PrivateKey\n */\n\n/**\n * Multi-word mnemonic phrase (BIP-39).\n *\n * Compatible with the official Hedera mobile\n * wallets (24-words or 22-words) and BRD (12-words).\n */\nexport default class Mnemonic {\n    /**\n     * @param {Object} props\n     * @param {string[]} props.words\n     * @param {boolean} props.legacy\n     * @throws {BadMnemonicError}\n     * @hideconstructor\n     * @private\n     */\n    constructor({ words, legacy }) {\n        this.words = words;\n        this._isLegacy = legacy;\n    }\n\n    /**\n     * Returns a new random 24-word mnemonic from the BIP-39\n     * standard English word list.\n     *\n     * @returns {Promise<Mnemonic>}\n     */\n    static generate() {\n        return Mnemonic._generate(24);\n    }\n\n    /**\n     * Returns a new random 12-word mnemonic from the BIP-39\n     * standard English word list.\n     *\n     * @returns {Promise<Mnemonic>}\n     */\n    static generate12() {\n        return Mnemonic._generate(12);\n    }\n\n    /**\n     * @param {number} length\n     * @returns {Promise<Mnemonic>}\n     */\n    static async _generate(length) {\n        // only 12-word or 24-word lengths are supported\n        let neededEntropy;\n\n        if (length === 12) neededEntropy = 16;\n        else if (length === 24) neededEntropy = 32;\n        else {\n            throw new Error(\n                `unsupported phrase length ${length}, only 12 or 24 are supported`\n            );\n        }\n\n        // inlined from (ISC) with heavy alternations for modern crypto\n        // https://github.com/bitcoinjs/bip39/blob/8461e83677a1d2c685d0d5a9ba2a76bd228f74c6/ts_src/index.ts#L125\n        const seed = await random.bytesAsync(neededEntropy);\n        const entropyBits = bytesToBinary(Array.from(seed));\n        const checksumBits = await deriveChecksumBits(seed);\n        const bits = entropyBits + checksumBits;\n        const chunks = bits.match(/(.{1,11})/g);\n\n        const words = (chunks != null ? chunks : []).map(\n            (binary) => bip39Words[binaryToByte(binary)]\n        );\n\n        return new Mnemonic({ words, legacy: false });\n    }\n\n    /**\n     * Construct a mnemonic from a list of words. Handles 12, 22 (legacy), and 24 words.\n     *\n     * An exception of BadMnemonicError will be thrown if the mnemonic\n     * contains unknown words or fails the checksum. An invalid mnemonic\n     * can still be used to create private keys, the exception will\n     * contain the failing mnemonic in case you wish to ignore the\n     * validation error and continue.\n     *\n     * @param {string[]} words\n     * @throws {BadMnemonicError}\n     * @returns {Promise<Mnemonic>}\n     */\n    static fromWords(words) {\n        return new Mnemonic({\n            words,\n            legacy: words.length === 22,\n        })._validate();\n    }\n\n    /**\n     * @deprecated - Use `toEd25519PrivateKey()` or `toEcdsaPrivateKey()` instead\n     * Recover a private key from this mnemonic phrase, with an\n     * optional passphrase.\n     * @param {string} [passphrase]\n     * @returns {Promise<PrivateKey>}\n     */\n    toPrivateKey(passphrase = \"\") {\n        return this.toEd25519PrivateKey(passphrase);\n    }\n\n    /**\n     * Recover an Ed25519 private key from this mnemonic phrase, with an\n     * optional passphrase.\n     *\n     * @param {string} [passphrase]\n     * @param {number[]} [path]\n     * @returns {Promise<PrivateKey>}\n     */\n    async toEd25519PrivateKey(passphrase = \"\", path = HEDERA_PATH) {\n        if (this._isLegacy) {\n            if (passphrase.length > 0) {\n                throw new Error(\n                    \"legacy 22-word mnemonics do not support passphrases\"\n                );\n            }\n\n            return this.toLegacyPrivateKey();\n        }\n\n        let { keyData, chainCode } = await this._toKeyData(\n            passphrase,\n            ED25519_SEED_TEXT\n        );\n\n        for (const index of path) {\n            ({ keyData, chainCode } = await slip10.derive(\n                keyData,\n                chainCode,\n                index\n            ));\n        }\n\n        const keyPair = nacl.sign.keyPair.fromSeed(keyData);\n\n        if (CACHE.privateKeyConstructor == null) {\n            throw new Error(\"PrivateKey not found in cache\");\n        }\n\n        return CACHE.privateKeyConstructor(\n            new Ed25519PrivateKey(keyPair, chainCode)\n        );\n    }\n\n    /**\n     * Recover an ECDSA private key from this mnemonic phrase, with an\n     * optional passphrase.\n     *\n     * @param {string} [passphrase]\n     * @param {number[]} [path]\n     * @returns {Promise<PrivateKey>}\n     */\n    async toEcdsaPrivateKey(passphrase = \"\", path = HEDERA_PATH) {\n        let { keyData, chainCode } = await this._toKeyData(\n            passphrase,\n            ECDSA_SEED_TEXT\n        );\n\n        for (const index of path) {\n            ({ keyData, chainCode } = await bip32.derive(\n                keyData,\n                chainCode,\n                index\n            ));\n        }\n\n        if (CACHE.privateKeyConstructor == null) {\n            throw new Error(\"PrivateKey not found in cache\");\n        }\n\n        return CACHE.privateKeyConstructor(\n            new EcdsaPrivateKey(ecdsa.fromBytes(keyData), chainCode)\n        );\n    }\n\n    /**\n     * @param {string} passphrase\n     * @param {string} seedText\n     * @returns {Promise<{ keyData: Uint8Array; chainCode: Uint8Array }>} seedText\n     */\n    async _toKeyData(passphrase, seedText) {\n        const seed = await bip39.toSeed(this.words, passphrase);\n        const digest = await hmac.hash(\n            hmac.HashAlgorithm.Sha512,\n            seedText,\n            seed\n        );\n\n        return {\n            keyData: digest.subarray(0, 32),\n            chainCode: digest.subarray(32),\n        };\n    }\n\n    /**\n     * Recover a mnemonic phrase from a string, splitting on spaces. Handles 12, 22 (legacy), and 24 words.\n     *\n     * @param {string} mnemonic\n     * @returns {Promise<Mnemonic>}\n     */\n    static async fromString(mnemonic) {\n        return Mnemonic.fromWords(mnemonic.split(/\\s|,/));\n    }\n\n    /**\n     * @returns {Promise<Mnemonic>}\n     * @private\n     */\n    async _validate() {\n        //NOSONAR\n        // Validate that this is a valid BIP-39 mnemonic\n        // as generated by BIP-39's rules.\n\n        // Technically, invalid mnemonics can still be used to generate valid private keys,\n        // but if they became invalid due to user error then it will be difficult for the user\n        // to tell the difference unless they compare the generated keys.\n\n        // During validation, the following conditions are checked in order\n\n        //  1)) 24 or 12 words\n\n        //  2) All strings in {@link this.words} exist in the BIP-39\n        //     standard English word list (no normalization is done)\n\n        //  3) The calculated checksum for the mnemonic equals the\n        //     checksum encoded in the mnemonic\n\n        if (this._isLegacy) {\n            if (this.words.length !== 22) {\n                throw new BadMnemonicError(\n                    this,\n                    BadMnemonicReason.BadLength,\n                    []\n                );\n            }\n\n            const unknownWordIndices = this.words.reduce(\n                (/** @type {number[]} */ unknowns, word, index) =>\n                    legacyWords.includes(word.toLowerCase())\n                        ? unknowns\n                        : [...unknowns, index],\n                []\n            );\n\n            if (unknownWordIndices.length > 0) {\n                throw new BadMnemonicError(\n                    this,\n                    BadMnemonicReason.UnknownWords,\n                    unknownWordIndices\n                );\n            }\n\n            const [seed, checksum] = entropy.legacy1(this.words, legacyWords);\n            const newChecksum = entropy.crc8(seed);\n\n            if (checksum !== newChecksum) {\n                throw new BadMnemonicError(\n                    this,\n                    BadMnemonicReason.ChecksumMismatch,\n                    []\n                );\n            }\n        } else {\n            if (!(this.words.length === 12 || this.words.length === 24)) {\n                throw new BadMnemonicError(\n                    this,\n                    BadMnemonicReason.BadLength,\n                    []\n                );\n            }\n\n            const unknownWordIndices = this.words.reduce(\n                (/** @type {number[]} */ unknowns, word, index) =>\n                    bip39Words.includes(word) ? unknowns : [...unknowns, index],\n                []\n            );\n\n            if (unknownWordIndices.length > 0) {\n                throw new BadMnemonicError(\n                    this,\n                    BadMnemonicReason.UnknownWords,\n                    unknownWordIndices\n                );\n            }\n\n            // FIXME: calculate checksum and compare\n            // https://github.com/bitcoinjs/bip39/blob/master/ts_src/index.ts#L112\n\n            const bits = this.words\n                .map((word) => {\n                    return bip39Words\n                        .indexOf(word)\n                        .toString(2)\n                        .padStart(11, \"0\");\n                })\n                .join(\"\");\n\n            const dividerIndex = Math.floor(bits.length / 33) * 32;\n            const entropyBits = bits.slice(0, dividerIndex);\n            const checksumBits = bits.slice(dividerIndex);\n            const entropyBitsRegex = entropyBits.match(/(.{1,8})/g);\n            const entropyBytes = /** @type {RegExpMatchArray} */ (\n                entropyBitsRegex\n            ).map(binaryToByte);\n\n            const newChecksum = await deriveChecksumBits(\n                Uint8Array.from(entropyBytes)\n            );\n\n            if (newChecksum !== checksumBits) {\n                throw new BadMnemonicError(\n                    this,\n                    BadMnemonicReason.ChecksumMismatch,\n                    []\n                );\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * @returns {Promise<PrivateKey>}\n     */\n    async toLegacyPrivateKey() {\n        let seed;\n        if (this._isLegacy) {\n            [seed] = entropy.legacy1(this.words, legacyWords);\n        } else {\n            seed = await entropy.legacy2(this.words, bip39Words);\n        }\n\n        if (CACHE.privateKeyFromBytes == null) {\n            throw new Error(\"PrivateKey not found in cache\");\n        }\n\n        return CACHE.privateKeyFromBytes(seed);\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return this.words.join(\" \");\n    }\n}\n\n/**\n * @param {string} bin\n * @returns {number}\n */\nfunction binaryToByte(bin) {\n    return parseInt(bin, 2);\n}\n\n/**\n * @param {number[]} bytes\n * @returns {string}\n */\nfunction bytesToBinary(bytes) {\n    return bytes.map((x) => x.toString(2).padStart(8, \"0\")).join(\"\");\n}\n\n/**\n * @param {Uint8Array} entropyBuffer\n * @returns {Promise<string>}\n */\nasync function deriveChecksumBits(entropyBuffer) {\n    const ENT = entropyBuffer.length * 8;\n    const CS = ENT / 32;\n    const hash = await sha256.digest(entropyBuffer);\n\n    return bytesToBinary(Array.from(hash)).slice(0, CS);\n}\n"]},"metadata":{},"sourceType":"module"}