{"ast":null,"code":"import Key from \"./Key.js\";\nimport BadKeyError from \"./BadKeyError.js\";\nimport { arrayEqual, arrayStartsWith } from \"./util/array.js\";\nimport * as hex from \"./encoding/hex.js\";\nimport * as ecdsa from \"./primitive/ecdsa.js\";\nimport { keccak256 } from \"./primitive/keccak.js\";\nconst derPrefix = \"302d300706052b8104000a032200\";\nconst derPrefixBytes = hex.decode(derPrefix);\n/**\n * An public key on the Hedera™ network.\n */\n\nexport default class EcdsaPublicKey extends Key {\n  /**\n   * @internal\n   * @hideconstructor\n   * @param {Uint8Array} keyData\n   */\n  constructor(keyData) {\n    super();\n    /**\n     * @type {Uint8Array}\n     * @private\n     * @readonly\n     */\n\n    this._keyData = keyData;\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  get _type() {\n    return \"secp256k1\";\n  }\n  /**\n   * @param {Uint8Array} data\n   * @returns {EcdsaPublicKey}\n   */\n\n\n  static fromBytes(data) {\n    switch (data.length) {\n      case 33:\n        return EcdsaPublicKey.fromBytesRaw(data);\n\n      case 49:\n        return EcdsaPublicKey.fromBytesDer(data);\n\n      default:\n        throw new BadKeyError(`invalid public key length: ${data.length} bytes`);\n    }\n  }\n  /**\n   * @param {Uint8Array} data\n   * @returns {EcdsaPublicKey}\n   */\n\n\n  static fromBytesDer(data) {\n    if (data.length != 44 || !arrayStartsWith(data, derPrefixBytes)) {\n      throw new BadKeyError(`invalid public key length: ${data.length} bytes`);\n    }\n\n    return new EcdsaPublicKey(data.subarray(12));\n  }\n  /**\n   * @param {Uint8Array} data\n   * @returns {EcdsaPublicKey}\n   */\n\n\n  static fromBytesRaw(data) {\n    if (data.length != 33) {\n      throw new BadKeyError(`invalid public key length: ${data.length} bytes`);\n    }\n\n    return new EcdsaPublicKey(data);\n  }\n  /**\n   * Parse a public key from a string of hexadecimal digits.\n   *\n   * The public key may optionally be prefixed with\n   * the DER header.\n   *\n   * @param {string} text\n   * @returns {EcdsaPublicKey}\n   */\n\n\n  static fromString(text) {\n    return EcdsaPublicKey.fromBytes(hex.decode(text));\n  }\n  /**\n   * Verify a signature on a message with this public key.\n   *\n   * @param {Uint8Array} message\n   * @param {Uint8Array} signature\n   * @returns {boolean}\n   */\n\n\n  verify(message, signature) {\n    return ecdsa.verify(this._keyData, message, signature);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n\n\n  toBytesDer() {\n    const bytes = new Uint8Array(derPrefixBytes.length + this._keyData.length);\n    bytes.set(derPrefixBytes, 0);\n    bytes.set(this._keyData, derPrefixBytes.length);\n    return bytes;\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n\n\n  toBytesRaw() {\n    return new Uint8Array(this._keyData.subarray());\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  toEthereumAddress() {\n    const hash = hex.decode(keccak256(`0x${hex.encode(ecdsa.getFullPublicKey(this.toBytesRaw()).subarray(1))}`));\n    return hex.encode(hash.subarray(12));\n  }\n  /**\n   * @param {EcdsaPublicKey} other\n   * @returns {boolean}\n   */\n\n\n  equals(other) {\n    return arrayEqual(this._keyData, other._keyData);\n  }\n\n}","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/hbar-shop/hbar-shop-dashboard/node_modules/@hashgraph/cryptography/src/EcdsaPublicKey.js"],"names":["Key","BadKeyError","arrayEqual","arrayStartsWith","hex","ecdsa","keccak256","derPrefix","derPrefixBytes","decode","EcdsaPublicKey","constructor","keyData","_keyData","_type","fromBytes","data","length","fromBytesRaw","fromBytesDer","subarray","fromString","text","verify","message","signature","toBytesDer","bytes","Uint8Array","set","toBytesRaw","toEthereumAddress","hash","encode","getFullPublicKey","equals","other"],"mappings":"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","sourcesContent":["import Key from \"./Key.js\";\nimport BadKeyError from \"./BadKeyError.js\";\nimport { arrayEqual, arrayStartsWith } from \"./util/array.js\";\nimport * as hex from \"./encoding/hex.js\";\nimport * as ecdsa from \"./primitive/ecdsa.js\";\nimport { keccak256 } from \"./primitive/keccak.js\";\n\nconst derPrefix = \"302d300706052b8104000a032200\";\nconst derPrefixBytes = hex.decode(derPrefix);\n\n/**\n * An public key on the Hedera™ network.\n */\nexport default class EcdsaPublicKey extends Key {\n    /**\n     * @internal\n     * @hideconstructor\n     * @param {Uint8Array} keyData\n     */\n    constructor(keyData) {\n        super();\n\n        /**\n         * @type {Uint8Array}\n         * @private\n         * @readonly\n         */\n        this._keyData = keyData;\n    }\n\n    /**\n     * @returns {string}\n     */\n    get _type() {\n        return \"secp256k1\";\n    }\n\n    /**\n     * @param {Uint8Array} data\n     * @returns {EcdsaPublicKey}\n     */\n    static fromBytes(data) {\n        switch (data.length) {\n            case 33:\n                return EcdsaPublicKey.fromBytesRaw(data);\n            case 49:\n                return EcdsaPublicKey.fromBytesDer(data);\n            default:\n                throw new BadKeyError(\n                    `invalid public key length: ${data.length} bytes`\n                );\n        }\n    }\n\n    /**\n     * @param {Uint8Array} data\n     * @returns {EcdsaPublicKey}\n     */\n    static fromBytesDer(data) {\n        if (data.length != 44 || !arrayStartsWith(data, derPrefixBytes)) {\n            throw new BadKeyError(\n                `invalid public key length: ${data.length} bytes`\n            );\n        }\n\n        return new EcdsaPublicKey(data.subarray(12));\n    }\n\n    /**\n     * @param {Uint8Array} data\n     * @returns {EcdsaPublicKey}\n     */\n    static fromBytesRaw(data) {\n        if (data.length != 33) {\n            throw new BadKeyError(\n                `invalid public key length: ${data.length} bytes`\n            );\n        }\n\n        return new EcdsaPublicKey(data);\n    }\n\n    /**\n     * Parse a public key from a string of hexadecimal digits.\n     *\n     * The public key may optionally be prefixed with\n     * the DER header.\n     *\n     * @param {string} text\n     * @returns {EcdsaPublicKey}\n     */\n    static fromString(text) {\n        return EcdsaPublicKey.fromBytes(hex.decode(text));\n    }\n\n    /**\n     * Verify a signature on a message with this public key.\n     *\n     * @param {Uint8Array} message\n     * @param {Uint8Array} signature\n     * @returns {boolean}\n     */\n    verify(message, signature) {\n        return ecdsa.verify(this._keyData, message, signature);\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytesDer() {\n        const bytes = new Uint8Array(\n            derPrefixBytes.length + this._keyData.length\n        );\n\n        bytes.set(derPrefixBytes, 0);\n        bytes.set(this._keyData, derPrefixBytes.length);\n\n        return bytes;\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytesRaw() {\n        return new Uint8Array(this._keyData.subarray());\n    }\n\n    /**\n     * @returns {string}\n     */\n    toEthereumAddress() {\n        const hash = hex.decode(\n            keccak256(\n                `0x${hex.encode(\n                    ecdsa.getFullPublicKey(this.toBytesRaw()).subarray(1)\n                )}`\n            )\n        );\n        return hex.encode(hash.subarray(12));\n    }\n\n    /**\n     * @param {EcdsaPublicKey} other\n     * @returns {boolean}\n     */\n    equals(other) {\n        return arrayEqual(this._keyData, other._keyData);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}