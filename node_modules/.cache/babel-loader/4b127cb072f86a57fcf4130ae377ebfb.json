{"ast":null,"code":"/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\nimport LedgerId from \"../LedgerId.js\";\nimport * as util from \"../util.js\";\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../channel/MirrorChannel.js\").default} MirrorChannel\n * @typedef {import(\"../Node.js\").default} Node\n * @typedef {import(\"../MirrorNode.js\").default} MirrorNode\n * @typedef {import(\"../address_book/NodeAddressBook.js\").default} NodeAddressBook\n */\n\n/**\n * @template {Channel | MirrorChannel} ChannelT\n * @typedef {import(\"../ManagedNode.js\").default<ChannelT>} ManagedNode\n */\n\n/**\n * @template {Channel | MirrorChannel} ChannelT\n * @template {ManagedNode<ChannelT>} NetworkNodeT\n * @template {{ toString: () => string }} KeyT\n */\n\nexport default class ManagedNetwork {\n  /**\n   * @param {(address: string) => ChannelT} createNetworkChannel\n   */\n  constructor(createNetworkChannel) {\n    /**\n     * Map of node account ID (as a string)\n     * to the node URL.\n     *\n     * @internal\n     * @type {Map<string, NetworkNodeT[]>}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    this._network = new Map();\n    /**\n     * List of node account IDs.\n     *\n     * @protected\n     * @type {NetworkNodeT[]}\n     */\n\n    this._nodes = [];\n    /**\n     * List of node account IDs.\n     *\n     * @protected\n     * @type {NetworkNodeT[]}\n     */\n\n    this._healthyNodes = [];\n    /** @type {(address: string, cert?: string) => ChannelT} */\n\n    this._createNetworkChannel = createNetworkChannel;\n    /** @type {LedgerId | null} */\n\n    this._ledgerId = null;\n    this._minBackoff = 8000;\n    this._maxBackoff = 1000 * 60 * 60;\n    /** @type {number} */\n\n    this._maxNodeAttempts = -1;\n    this._transportSecurity = false;\n    this._nodeMinReadmitPeriod = this._minBackoff;\n    this._nodeMaxReadmitPeriod = this._maxBackoff;\n    this._earliestReadmitTime = Date.now() + this._nodeMinReadmitPeriod;\n  }\n  /**\n   * @returns {boolean}\n   */\n\n\n  isTransportSecurity() {\n    return this._transportSecurity;\n  }\n  /**\n   * @param {boolean} transportSecurity\n   * @returns {this}\n   */\n\n\n  setTransportSecurity(transportSecurity) {\n    if (this._transportSecurity == transportSecurity) {\n      return this;\n    }\n\n    this._network.clear();\n\n    for (let i = 0; i < this._nodes.length; i++) {\n      let node = this._nodes[i];\n      node.close();\n      node =\n      /** @type {NetworkNodeT} */\n      transportSecurity ? node.toSecure().setCert(this._ledgerId != null ? this._ledgerId.toString() : \"\") : node.toInsecure();\n      this._nodes[i] = node;\n      const nodes = this._network.get(node.getKey()) != null ?\n      /** @type {NetworkNodeT[]} */\n      this._network.get(node.getKey()) : [];\n      nodes.push(node);\n\n      this._network.set(node.getKey(), nodes);\n    } // Overwrite healthy node list since new ports might make the node work again\n\n\n    this._healthyNodes = [...this._nodes];\n    this._transportSecurity = transportSecurity;\n    return this;\n  }\n  /**\n   * @deprecated\n   * @param {string} networkName\n   * @returns {this}\n   */\n\n\n  setNetworkName(networkName) {\n    console.warn(\"Deprecated: Use `setLedgerId` instead\");\n    return this.setLedgerId(networkName);\n  }\n  /**\n   * @deprecated\n   * @returns {string | null}\n   */\n\n\n  get networkName() {\n    console.warn(\"Deprecated: Use `ledgerId` instead\");\n    return this.ledgerId != null ? this.ledgerId.toString() : null;\n  }\n  /**\n   * @param {string|LedgerId} ledgerId\n   * @returns {this}\n   */\n\n\n  setLedgerId(ledgerId) {\n    this._ledgerId = typeof ledgerId === \"string\" ? LedgerId.fromString(ledgerId) : ledgerId;\n    return this;\n  }\n  /**\n   * @returns {LedgerId | null}\n   */\n\n\n  get ledgerId() {\n    return this._ledgerId != null ? this._ledgerId : null;\n  }\n  /**\n   * @abstract\n   * @param {[string, KeyT]} entry\n   * @returns {NetworkNodeT}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _createNodeFromNetworkEntry(entry) {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * @abstract\n   * @param {Map<string, KeyT>} network\n   * @returns {number[]}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _getNodesToRemove(network) {\n    throw new Error(\"not implemented\");\n  }\n\n  _removeDeadNodes() {\n    if (this._maxNodeAttempts > 0) {\n      for (let i = this._nodes.length - 1; i >= 0; i--) {\n        const node = this._nodes[i];\n\n        if (node._badGrpcStatusCount < this._maxNodeAttempts) {\n          continue;\n        }\n\n        this._closeNode(i);\n      }\n    }\n  }\n\n  _readmitNodes() {\n    const now = Date.now();\n\n    if (this._earliestReadmitTime <= now) {\n      let nextEarliestReadmitTime = Number.MAX_SAFE_INTEGER;\n      let searchForNextEarliestReadmitTime = true;\n\n      outer: for (let i = 0; i < this._nodes.length; i++) {\n        for (let j = 0; j < this._healthyNodes.length; j++) {\n          if (searchForNextEarliestReadmitTime && this._nodes[i]._readmitTime > now) {\n            nextEarliestReadmitTime = Math.min(this._nodes[i]._readmitTime, nextEarliestReadmitTime);\n          }\n\n          if (this._nodes[i] == this._healthyNodes[j]) {\n            continue outer;\n          }\n        }\n\n        searchForNextEarliestReadmitTime = false;\n\n        if (this._nodes[i]._readmitTime <= now) {\n          this._healthyNodes.push(this._nodes[i]);\n        }\n      }\n\n      this._earliestReadmitTime = Math.min(Math.max(nextEarliestReadmitTime, this._nodeMinReadmitPeriod), this._nodeMaxReadmitPeriod);\n    }\n  }\n  /**\n   * @param {number} count\n   * @returns {NetworkNodeT[]}\n   */\n\n\n  _getNumberOfMostHealthyNodes(count) {\n    this._removeDeadNodes();\n    /** @type {NetworkNodeT[]} */\n\n\n    const nodes = [];\n    const keys = new Set(); // `this.getNode()` uses `Math.random()` internally to fetch\n    // nodes, this means _techically_ `this.getNode()` can return\n    // the same exact node several times in a row, but we do not\n    // want that. We want to get a random node that hasn't been\n    // chosen before. We could use a while loop and just keep calling\n    // `this.getNode()` until we get a list of `count` different nodes,\n    // but a potential issue is if somehow the healthy list gets\n    // corrupted or count is too large then the while loop would\n    // run forever. To resolve this, instead of using a while, we use\n    // a for loop where we call `this.getNode()` a max of\n    // `this._healthyNodes.length` times. This can result in a shorter\n    // list than `count`, but that is much better than running forever\n\n    for (let i = 0; i < this._healthyNodes.length; i++) {\n      if (nodes.length == count) {\n        break;\n      } // Get a random node\n\n\n      const node = this.getNode();\n\n      if (!keys.has(node.getKey())) {\n        keys.add(node.getKey());\n        nodes.push(node);\n      }\n    }\n\n    return nodes;\n  }\n  /**\n   * @param {number} i\n   */\n\n\n  _closeNode(i) {\n    const node = this._nodes[i];\n    node.close();\n\n    this._removeNodeFromNetwork(node);\n\n    this._nodes.splice(i, 1);\n  }\n  /**\n   * @param {NetworkNodeT} node\n   */\n\n\n  _removeNodeFromNetwork(node) {\n    const network =\n    /** @type {NetworkNodeT[]} */\n    this._network.get(node.getKey());\n\n    for (let j = 0; j < network.length; j++) {\n      if (network[j] === node) {\n        network.splice(j, 1);\n        break;\n      }\n    }\n\n    if (network.length === 0) {\n      this._network.delete(node.getKey());\n    }\n  }\n  /**\n   * @param {Map<string, KeyT>} network\n   * @returns {this}\n   */\n\n\n  _setNetwork(network) {\n    /** @type {NetworkNodeT[]} */\n    const newNodes = [];\n    const newNodeKeys = new Set();\n    const newNodeAddresses = new Set();\n    /** @type {NetworkNodeT[]} */\n\n    const newHealthyNodes = [];\n    /** @type {Map<string, NetworkNodeT[]>} */\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\n    const newNetwork = new Map(); // Remove nodes that are not in the new network\n\n    for (const i of this._getNodesToRemove(network)) {\n      this._closeNode(i);\n    } // Copy all the unclosed nodes\n\n\n    for (const node of this._nodes) {\n      newNodes.push(node);\n      newNodeKeys.add(node.getKey());\n      newNodeAddresses.add(node.address.toString());\n    } // Add new nodes\n\n\n    for (const [key, value] of network) {\n      if (newNodeKeys.has(value.toString()) && newNodeAddresses.has(key)) {\n        continue;\n      }\n\n      newNodes.push(this._createNodeFromNetworkEntry([key, value]));\n    } // Shuffle the nodes so we don't immediately pick the first nodes\n\n\n    util.shuffle(newNodes); // Copy all the nodes into the healhty nodes list initially\n    // and push the nodes into the network; this maintains the\n    // shuffled state from `newNodes`\n\n    for (const node of newNodes) {\n      if (!node.isHealthy()) {\n        continue;\n      }\n\n      newHealthyNodes.push(node);\n      const newNetworkNodes = newNetwork.has(node.getKey()) ?\n      /** @type {NetworkNodeT[]} */\n      newNetwork.get(node.getKey()) : [];\n      newNetworkNodes.push(node);\n      newNetwork.set(node.getKey(), newNetworkNodes);\n    } // console.log(JSON.stringify(newNodes, null, 2));\n\n\n    this._nodes = newNodes;\n    this._healthyNodes = newHealthyNodes;\n    this._network = newNetwork;\n    this._ledgerId = null;\n    return this;\n  }\n  /**\n   * @returns {number}\n   */\n\n\n  get maxNodeAttempts() {\n    return this._maxNodeAttempts;\n  }\n  /**\n   * @param {number} maxNodeAttempts\n   * @returns {this}\n   */\n\n\n  setMaxNodeAttempts(maxNodeAttempts) {\n    this._maxNodeAttempts = maxNodeAttempts;\n    return this;\n  }\n  /**\n   * @returns {number}\n   */\n\n\n  get minBackoff() {\n    return this._minBackoff;\n  }\n  /**\n   * @param {number} minBackoff\n   * @returns {this}\n   */\n\n\n  setMinBackoff(minBackoff) {\n    this._minBackoff = minBackoff;\n\n    for (const node of this._nodes) {\n      node.setMinBackoff(minBackoff);\n    }\n\n    return this;\n  }\n  /**\n   * @returns {number}\n   */\n\n\n  get maxBackoff() {\n    return this._maxBackoff;\n  }\n  /**\n   * @param {number} maxBackoff\n   * @returns {this}\n   */\n\n\n  setMaxBackoff(maxBackoff) {\n    this._maxBackoff = maxBackoff;\n\n    for (const node of this._nodes) {\n      node.setMaxBackoff(maxBackoff);\n    }\n\n    return this;\n  }\n  /**\n   * @returns {number}\n   */\n\n\n  get nodeMinReadmitPeriod() {\n    return this._nodeMinReadmitPeriod;\n  }\n  /**\n   * @param {number} nodeMinReadmitPeriod\n   * @returns {this}\n   */\n\n\n  setNodeMinReadmitPeriod(nodeMinReadmitPeriod) {\n    this._nodeMinReadmitPeriod = nodeMinReadmitPeriod;\n    this._earliestReadmitTime = Date.now() + this._nodeMinReadmitPeriod;\n    return this;\n  }\n  /**\n   * @returns {number}\n   */\n\n\n  get nodeMaxReadmitPeriod() {\n    return this._nodeMaxReadmitPeriod;\n  }\n  /**\n   * @param {number} nodeMaxReadmitPeriod\n   * @returns {this}\n   */\n\n\n  setNodeMaxReadmitPeriod(nodeMaxReadmitPeriod) {\n    this._nodeMaxReadmitPeriod = nodeMaxReadmitPeriod;\n    return this;\n  }\n  /**\n   * @param {KeyT=} key\n   * @returns {NetworkNodeT}\n   */\n\n\n  getNode(key) {\n    this._readmitNodes();\n\n    if (key != null) {\n      return (\n        /** @type {NetworkNodeT[]} */\n        this._network.get(key.toString())[0]\n      );\n    } else {\n      if (this._healthyNodes.length == 0) {\n        throw new Error(\"failed to find a healthy working node\");\n      }\n\n      return this._healthyNodes[Math.floor(Math.random() * this._healthyNodes.length)];\n    }\n  }\n  /**\n   * @param {NetworkNodeT} node\n   */\n\n\n  increaseBackoff(node) {\n    node.increaseBackoff();\n\n    for (let i = 0; i < this._healthyNodes.length; i++) {\n      if (this._healthyNodes[i] == node) {\n        this._healthyNodes.splice(i, 1);\n      }\n    }\n  }\n  /**\n   * @param {NetworkNodeT} node\n   */\n\n\n  decreaseBackoff(node) {\n    node.decreaseBackoff();\n  }\n\n  close() {\n    for (const node of this._nodes) {\n      node.close();\n    }\n\n    this._network.clear();\n\n    this._nodes = [];\n  }\n\n}","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/hbar-shop/hbar-shopify-coupon-client/node_modules/@hashgraph/sdk/src/client/ManagedNetwork.js"],"names":["LedgerId","util","ManagedNetwork","constructor","createNetworkChannel","_network","Map","_nodes","_healthyNodes","_createNetworkChannel","_ledgerId","_minBackoff","_maxBackoff","_maxNodeAttempts","_transportSecurity","_nodeMinReadmitPeriod","_nodeMaxReadmitPeriod","_earliestReadmitTime","Date","now","isTransportSecurity","setTransportSecurity","transportSecurity","clear","i","length","node","close","toSecure","setCert","toString","toInsecure","nodes","get","getKey","push","set","setNetworkName","networkName","console","warn","setLedgerId","ledgerId","fromString","_createNodeFromNetworkEntry","entry","Error","_getNodesToRemove","network","_removeDeadNodes","_badGrpcStatusCount","_closeNode","_readmitNodes","nextEarliestReadmitTime","Number","MAX_SAFE_INTEGER","searchForNextEarliestReadmitTime","outer","j","_readmitTime","Math","min","max","_getNumberOfMostHealthyNodes","count","keys","Set","getNode","has","add","_removeNodeFromNetwork","splice","delete","_setNetwork","newNodes","newNodeKeys","newNodeAddresses","newHealthyNodes","newNetwork","address","key","value","shuffle","isHealthy","newNetworkNodes","maxNodeAttempts","setMaxNodeAttempts","minBackoff","setMinBackoff","maxBackoff","setMaxBackoff","nodeMinReadmitPeriod","setNodeMinReadmitPeriod","nodeMaxReadmitPeriod","setNodeMaxReadmitPeriod","floor","random","increaseBackoff","decreaseBackoff"],"mappings":"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","sourcesContent":["/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\n\nimport LedgerId from \"../LedgerId.js\";\nimport * as util from \"../util.js\";\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../channel/MirrorChannel.js\").default} MirrorChannel\n * @typedef {import(\"../Node.js\").default} Node\n * @typedef {import(\"../MirrorNode.js\").default} MirrorNode\n * @typedef {import(\"../address_book/NodeAddressBook.js\").default} NodeAddressBook\n */\n\n/**\n * @template {Channel | MirrorChannel} ChannelT\n * @typedef {import(\"../ManagedNode.js\").default<ChannelT>} ManagedNode\n */\n\n/**\n * @template {Channel | MirrorChannel} ChannelT\n * @template {ManagedNode<ChannelT>} NetworkNodeT\n * @template {{ toString: () => string }} KeyT\n */\nexport default class ManagedNetwork {\n    /**\n     * @param {(address: string) => ChannelT} createNetworkChannel\n     */\n    constructor(createNetworkChannel) {\n        /**\n         * Map of node account ID (as a string)\n         * to the node URL.\n         *\n         * @internal\n         * @type {Map<string, NetworkNodeT[]>}\n         */\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this._network = new Map();\n\n        /**\n         * List of node account IDs.\n         *\n         * @protected\n         * @type {NetworkNodeT[]}\n         */\n        this._nodes = [];\n\n        /**\n         * List of node account IDs.\n         *\n         * @protected\n         * @type {NetworkNodeT[]}\n         */\n        this._healthyNodes = [];\n\n        /** @type {(address: string, cert?: string) => ChannelT} */\n        this._createNetworkChannel = createNetworkChannel;\n\n        /** @type {LedgerId | null} */\n        this._ledgerId = null;\n\n        this._minBackoff = 8000;\n        this._maxBackoff = 1000 * 60 * 60;\n\n        /** @type {number} */\n        this._maxNodeAttempts = -1;\n\n        this._transportSecurity = false;\n\n        this._nodeMinReadmitPeriod = this._minBackoff;\n        this._nodeMaxReadmitPeriod = this._maxBackoff;\n\n        this._earliestReadmitTime = Date.now() + this._nodeMinReadmitPeriod;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isTransportSecurity() {\n        return this._transportSecurity;\n    }\n\n    /**\n     * @param {boolean} transportSecurity\n     * @returns {this}\n     */\n    setTransportSecurity(transportSecurity) {\n        if (this._transportSecurity == transportSecurity) {\n            return this;\n        }\n\n        this._network.clear();\n\n        for (let i = 0; i < this._nodes.length; i++) {\n            let node = this._nodes[i];\n            node.close();\n\n            node = /** @type {NetworkNodeT} */ (\n                transportSecurity\n                    ? node\n                          .toSecure()\n                          .setCert(\n                              this._ledgerId != null\n                                  ? this._ledgerId.toString()\n                                  : \"\"\n                          )\n                    : node.toInsecure()\n            );\n            this._nodes[i] = node;\n\n            const nodes =\n                this._network.get(node.getKey()) != null\n                    ? /** @type {NetworkNodeT[]} */ (\n                          this._network.get(node.getKey())\n                      )\n                    : [];\n            nodes.push(node);\n            this._network.set(node.getKey(), nodes);\n        }\n\n        // Overwrite healthy node list since new ports might make the node work again\n        this._healthyNodes = [...this._nodes];\n\n        this._transportSecurity = transportSecurity;\n        return this;\n    }\n\n    /**\n     * @deprecated\n     * @param {string} networkName\n     * @returns {this}\n     */\n    setNetworkName(networkName) {\n        console.warn(\"Deprecated: Use `setLedgerId` instead\");\n        return this.setLedgerId(networkName);\n    }\n\n    /**\n     * @deprecated\n     * @returns {string | null}\n     */\n    get networkName() {\n        console.warn(\"Deprecated: Use `ledgerId` instead\");\n        return this.ledgerId != null ? this.ledgerId.toString() : null;\n    }\n\n    /**\n     * @param {string|LedgerId} ledgerId\n     * @returns {this}\n     */\n    setLedgerId(ledgerId) {\n        this._ledgerId =\n            typeof ledgerId === \"string\"\n                ? LedgerId.fromString(ledgerId)\n                : ledgerId;\n        return this;\n    }\n\n    /**\n     * @returns {LedgerId | null}\n     */\n    get ledgerId() {\n        return this._ledgerId != null ? this._ledgerId : null;\n    }\n\n    /**\n     * @abstract\n     * @param {[string, KeyT]} entry\n     * @returns {NetworkNodeT}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _createNodeFromNetworkEntry(entry) {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * @abstract\n     * @param {Map<string, KeyT>} network\n     * @returns {number[]}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _getNodesToRemove(network) {\n        throw new Error(\"not implemented\");\n    }\n\n    _removeDeadNodes() {\n        if (this._maxNodeAttempts > 0) {\n            for (let i = this._nodes.length - 1; i >= 0; i--) {\n                const node = this._nodes[i];\n\n                if (node._badGrpcStatusCount < this._maxNodeAttempts) {\n                    continue;\n                }\n\n                this._closeNode(i);\n            }\n        }\n    }\n\n    _readmitNodes() {\n        const now = Date.now();\n\n        if (this._earliestReadmitTime <= now) {\n            let nextEarliestReadmitTime = Number.MAX_SAFE_INTEGER;\n            let searchForNextEarliestReadmitTime = true;\n\n            outer: for (let i = 0; i < this._nodes.length; i++) {\n                for (let j = 0; j < this._healthyNodes.length; j++) {\n                    if (\n                        searchForNextEarliestReadmitTime &&\n                        this._nodes[i]._readmitTime > now\n                    ) {\n                        nextEarliestReadmitTime = Math.min(\n                            this._nodes[i]._readmitTime,\n                            nextEarliestReadmitTime\n                        );\n                    }\n\n                    if (this._nodes[i] == this._healthyNodes[j]) {\n                        continue outer;\n                    }\n                }\n\n                searchForNextEarliestReadmitTime = false;\n\n                if (this._nodes[i]._readmitTime <= now) {\n                    this._healthyNodes.push(this._nodes[i]);\n                }\n            }\n\n            this._earliestReadmitTime = Math.min(\n                Math.max(nextEarliestReadmitTime, this._nodeMinReadmitPeriod),\n                this._nodeMaxReadmitPeriod\n            );\n        }\n    }\n\n    /**\n     * @param {number} count\n     * @returns {NetworkNodeT[]}\n     */\n    _getNumberOfMostHealthyNodes(count) {\n        this._removeDeadNodes();\n\n        /** @type {NetworkNodeT[]} */\n        const nodes = [];\n        const keys = new Set();\n\n        // `this.getNode()` uses `Math.random()` internally to fetch\n        // nodes, this means _techically_ `this.getNode()` can return\n        // the same exact node several times in a row, but we do not\n        // want that. We want to get a random node that hasn't been\n        // chosen before. We could use a while loop and just keep calling\n        // `this.getNode()` until we get a list of `count` different nodes,\n        // but a potential issue is if somehow the healthy list gets\n        // corrupted or count is too large then the while loop would\n        // run forever. To resolve this, instead of using a while, we use\n        // a for loop where we call `this.getNode()` a max of\n        // `this._healthyNodes.length` times. This can result in a shorter\n        // list than `count`, but that is much better than running forever\n        for (let i = 0; i < this._healthyNodes.length; i++) {\n            if (nodes.length == count) {\n                break;\n            }\n\n            // Get a random node\n            const node = this.getNode();\n\n            if (!keys.has(node.getKey())) {\n                keys.add(node.getKey());\n                nodes.push(node);\n            }\n        }\n\n        return nodes;\n    }\n\n    /**\n     * @param {number} i\n     */\n    _closeNode(i) {\n        const node = this._nodes[i];\n\n        node.close();\n        this._removeNodeFromNetwork(node);\n        this._nodes.splice(i, 1);\n    }\n\n    /**\n     * @param {NetworkNodeT} node\n     */\n    _removeNodeFromNetwork(node) {\n        const network = /** @type {NetworkNodeT[]} */ (\n            this._network.get(node.getKey())\n        );\n\n        for (let j = 0; j < network.length; j++) {\n            if (network[j] === node) {\n                network.splice(j, 1);\n                break;\n            }\n        }\n\n        if (network.length === 0) {\n            this._network.delete(node.getKey());\n        }\n    }\n\n    /**\n     * @param {Map<string, KeyT>} network\n     * @returns {this}\n     */\n    _setNetwork(network) {\n        /** @type {NetworkNodeT[]} */\n        const newNodes = [];\n        const newNodeKeys = new Set();\n        const newNodeAddresses = new Set();\n\n        /** @type {NetworkNodeT[]} */\n        const newHealthyNodes = [];\n\n        /** @type {Map<string, NetworkNodeT[]>} */\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const newNetwork = new Map();\n\n        // Remove nodes that are not in the new network\n        for (const i of this._getNodesToRemove(network)) {\n            this._closeNode(i);\n        }\n\n        // Copy all the unclosed nodes\n        for (const node of this._nodes) {\n            newNodes.push(node);\n            newNodeKeys.add(node.getKey());\n            newNodeAddresses.add(node.address.toString());\n        }\n\n        // Add new nodes\n        for (const [key, value] of network) {\n            if (\n                newNodeKeys.has(value.toString()) &&\n                newNodeAddresses.has(key)\n            ) {\n                continue;\n            }\n            newNodes.push(this._createNodeFromNetworkEntry([key, value]));\n        }\n\n        // Shuffle the nodes so we don't immediately pick the first nodes\n        util.shuffle(newNodes);\n\n        // Copy all the nodes into the healhty nodes list initially\n        // and push the nodes into the network; this maintains the\n        // shuffled state from `newNodes`\n        for (const node of newNodes) {\n            if (!node.isHealthy()) {\n                continue;\n            }\n\n            newHealthyNodes.push(node);\n\n            const newNetworkNodes = newNetwork.has(node.getKey())\n                ? /** @type {NetworkNodeT[]} */ (newNetwork.get(node.getKey()))\n                : [];\n            newNetworkNodes.push(node);\n            newNetwork.set(node.getKey(), newNetworkNodes);\n        }\n\n        // console.log(JSON.stringify(newNodes, null, 2));\n        this._nodes = newNodes;\n        this._healthyNodes = newHealthyNodes;\n        this._network = newNetwork;\n        this._ledgerId = null;\n\n        return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get maxNodeAttempts() {\n        return this._maxNodeAttempts;\n    }\n\n    /**\n     * @param {number} maxNodeAttempts\n     * @returns {this}\n     */\n    setMaxNodeAttempts(maxNodeAttempts) {\n        this._maxNodeAttempts = maxNodeAttempts;\n        return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get minBackoff() {\n        return this._minBackoff;\n    }\n\n    /**\n     * @param {number} minBackoff\n     * @returns {this}\n     */\n    setMinBackoff(minBackoff) {\n        this._minBackoff = minBackoff;\n        for (const node of this._nodes) {\n            node.setMinBackoff(minBackoff);\n        }\n        return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get maxBackoff() {\n        return this._maxBackoff;\n    }\n\n    /**\n     * @param {number} maxBackoff\n     * @returns {this}\n     */\n    setMaxBackoff(maxBackoff) {\n        this._maxBackoff = maxBackoff;\n        for (const node of this._nodes) {\n            node.setMaxBackoff(maxBackoff);\n        }\n        return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get nodeMinReadmitPeriod() {\n        return this._nodeMinReadmitPeriod;\n    }\n\n    /**\n     * @param {number} nodeMinReadmitPeriod\n     * @returns {this}\n     */\n    setNodeMinReadmitPeriod(nodeMinReadmitPeriod) {\n        this._nodeMinReadmitPeriod = nodeMinReadmitPeriod;\n        this._earliestReadmitTime = Date.now() + this._nodeMinReadmitPeriod;\n        return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get nodeMaxReadmitPeriod() {\n        return this._nodeMaxReadmitPeriod;\n    }\n\n    /**\n     * @param {number} nodeMaxReadmitPeriod\n     * @returns {this}\n     */\n    setNodeMaxReadmitPeriod(nodeMaxReadmitPeriod) {\n        this._nodeMaxReadmitPeriod = nodeMaxReadmitPeriod;\n        return this;\n    }\n\n    /**\n     * @param {KeyT=} key\n     * @returns {NetworkNodeT}\n     */\n    getNode(key) {\n        this._readmitNodes();\n\n        if (key != null) {\n            return /** @type {NetworkNodeT[]} */ (\n                this._network.get(key.toString())\n            )[0];\n        } else {\n            if (this._healthyNodes.length == 0) {\n                throw new Error(\"failed to find a healthy working node\");\n            }\n\n            return this._healthyNodes[\n                Math.floor(Math.random() * this._healthyNodes.length)\n            ];\n        }\n    }\n\n    /**\n     * @param {NetworkNodeT} node\n     */\n    increaseBackoff(node) {\n        node.increaseBackoff();\n\n        for (let i = 0; i < this._healthyNodes.length; i++) {\n            if (this._healthyNodes[i] == node) {\n                this._healthyNodes.splice(i, 1);\n            }\n        }\n    }\n\n    /**\n     * @param {NetworkNodeT} node\n     */\n    decreaseBackoff(node) {\n        node.decreaseBackoff();\n    }\n\n    close() {\n        for (const node of this._nodes) {\n            node.close();\n        }\n\n        this._network.clear();\n        this._nodes = [];\n    }\n}\n"]},"metadata":{},"sourceType":"module"}