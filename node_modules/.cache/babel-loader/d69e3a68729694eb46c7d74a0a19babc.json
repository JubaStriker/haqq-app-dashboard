{"ast":null,"code":"/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\nimport GrpcServiceError from \"./grpc/GrpcServiceError.js\";\nimport GrpcStatus from \"./grpc/GrpcStatus.js\";\nimport List from \"./transaction/List.js\";\nimport Logger from \"js-logger\";\nimport * as hex from \"./encoding/hex.js\";\n/**\n * @typedef {import(\"./account/AccountId.js\").default} AccountId\n * @typedef {import(\"./Status.js\").default} Status\n * @typedef {import(\"./channel/Channel.js\").default} Channel\n * @typedef {import(\"./transaction/TransactionId.js\").default} TransactionId\n * @typedef {import(\"./client/Client.js\").ClientOperator} ClientOperator\n * @typedef {import(\"./Signer.js\").Signer} Signer\n * @typedef {import(\"./PublicKey.js\").default} PublicKey\n */\n\n/**\n * @enum {string}\n */\n\nexport const ExecutionState = {\n  Finished: \"Finished\",\n  Retry: \"Retry\",\n  Error: \"Error\"\n};\nexport const RST_STREAM = /\\brst[^0-9a-zA-Z]stream\\b/i;\n/**\n * @abstract\n * @internal\n * @template RequestT\n * @template ResponseT\n * @template OutputT\n */\n\nexport default class Executable {\n  constructor() {\n    /**\n     * The number of times we can retry the grpc call\n     *\n     * @private\n     * @type {number}\n     */\n    this._maxAttempts = 10;\n    /**\n     * List of node account IDs for each transaction that has been\n     * built.\n     *\n     * @internal\n     * @type {List<AccountId>}\n     */\n\n    this._nodeAccountIds = new List();\n    /**\n     * @internal\n     */\n\n    this._signOnDemand = false;\n    /**\n     * This is the request's min backoff\n     *\n     * @internal\n     * @type {number | null}\n     */\n\n    this._minBackoff = null;\n    /**\n     * This is the request's max backoff\n     *\n     * @internal\n     * @type {number | null}\n     */\n\n    this._maxBackoff = null;\n    /**\n     * The operator that was used to execute this request.\n     * The reason we save the operator in the request is because of the signing on\n     * demand feature. This feature requires us to sign new request on each attempt\n     * meaning if a client with an operator was used we'd need to sign with the operator\n     * on each attempt.\n     *\n     * @internal\n     * @type {ClientOperator | null}\n     */\n\n    this._operator = null;\n    /**\n     * The complete timeout for running the `execute()` method\n     *\n     * @internal\n     * @type {number | null}\n     */\n\n    this._requestTimeout = null;\n    /**\n     * The grpc request timeout aka deadline.\n     *\n     * The reason we have this is because there were times that consensus nodes held the grpc\n     * connection, but didn't return anything; not error nor regular response. This resulted\n     * in some weird behavior in the SDKs. To fix this we've added a grpc deadline to prevent\n     * nodes from stalling the executing of a request.\n     *\n     * @internal\n     * @type {number | null}\n     */\n\n    this._grpcDeadline = null;\n  }\n  /**\n   * Get the list of node account IDs on the request. If no nodes are set, then null is returned.\n   * The reasoning for this is simply \"legacy behavior\".\n   *\n   * @returns {?AccountId[]}\n   */\n\n\n  get nodeAccountIds() {\n    if (this._nodeAccountIds.isEmpty) {\n      return null;\n    } else {\n      this._nodeAccountIds.setLocked();\n\n      return this._nodeAccountIds.list;\n    }\n  }\n  /**\n   * Set the node account IDs on the request\n   *\n   * @param {AccountId[]} nodeIds\n   * @returns {this}\n   */\n\n\n  setNodeAccountIds(nodeIds) {\n    // Set the node account IDs, and lock the list. This will require `execute`\n    // to use these nodes instead of random nodes from the network.\n    this._nodeAccountIds.setList(nodeIds).setLocked();\n\n    return this;\n  }\n  /**\n   * @deprecated\n   * @returns {number}\n   */\n\n\n  get maxRetries() {\n    console.warn(\"Deprecated: use maxAttempts instead\");\n    return this.maxAttempts;\n  }\n  /**\n   * @param {number} maxRetries\n   * @returns {this}\n   */\n\n\n  setMaxRetries(maxRetries) {\n    console.warn(\"Deprecated: use setMaxAttempts() instead\");\n    return this.setMaxAttempts(maxRetries);\n  }\n  /**\n   * Get the max attempts on the request\n   *\n   * @returns {number}\n   */\n\n\n  get maxAttempts() {\n    return this._maxAttempts;\n  }\n  /**\n   * Set the max attempts on the request\n   *\n   * @param {number} maxAttempts\n   * @returns {this}\n   */\n\n\n  setMaxAttempts(maxAttempts) {\n    this._maxAttempts = maxAttempts;\n    return this;\n  }\n  /**\n   * Get the grpc deadline\n   *\n   * @returns {?number}\n   */\n\n\n  get grpcDeadline() {\n    return this._grpcDeadline;\n  }\n  /**\n   * Set the grpc deadline\n   *\n   * @param {number} grpcDeadline\n   * @returns {this}\n   */\n\n\n  setGrpcDeadline(grpcDeadline) {\n    this._grpcDeadline = grpcDeadline;\n    return this;\n  }\n  /**\n   * Set the min backoff for the request\n   *\n   * @param {number} minBackoff\n   * @returns {this}\n   */\n\n\n  setMinBackoff(minBackoff) {\n    // Honestly we shouldn't be checking for null since that should be TypeScript's job.\n    // Also verify that min backoff is not greater than max backoff.\n    if (minBackoff == null) {\n      throw new Error(\"minBackoff cannot be null.\");\n    } else if (this._maxBackoff != null && minBackoff > this._maxBackoff) {\n      throw new Error(\"minBackoff cannot be larger than maxBackoff.\");\n    }\n\n    this._minBackoff = minBackoff;\n    return this;\n  }\n  /**\n   * Get the min backoff\n   *\n   * @returns {number | null}\n   */\n\n\n  get minBackoff() {\n    return this._minBackoff;\n  }\n  /**\n   * Set the max backoff for the request\n   *\n   * @param {?number} maxBackoff\n   * @returns {this}\n   */\n\n\n  setMaxBackoff(maxBackoff) {\n    // Honestly we shouldn't be checking for null since that should be TypeScript's job.\n    // Also verify that max backoff is not less than min backoff.\n    if (maxBackoff == null) {\n      throw new Error(\"maxBackoff cannot be null.\");\n    } else if (this._minBackoff != null && maxBackoff < this._minBackoff) {\n      throw new Error(\"maxBackoff cannot be smaller than minBackoff.\");\n    }\n\n    this._maxBackoff = maxBackoff;\n    return this;\n  }\n  /**\n   * Get the max backoff\n   *\n   * @returns {number | null}\n   */\n\n\n  get maxBackoff() {\n    return this._maxBackoff;\n  }\n  /**\n   * This method is responsible for doing any work before the executing process begins.\n   * For paid queries this will result in executing a cost query, for transactions this\n   * will make sure we save the operator and sign any requests that need to be signed\n   * in case signing on demand is disabled.\n   *\n   * @abstract\n   * @protected\n   * @param {import(\"./client/Client.js\").default<Channel, *>} client\n   * @returns {Promise<void>}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _beforeExecute(client) {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * Create a protobuf request which will be passed into the `_execute()` method\n   *\n   * @abstract\n   * @protected\n   * @returns {Promise<RequestT>}\n   */\n\n\n  _makeRequestAsync() {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * This name is a bit wrong now, but the purpose of this method is to map the\n   * request and response into an error. This method will only be called when\n   * `_shouldRetry` returned `ExecutionState.Error`\n   *\n   * @abstract\n   * @internal\n   * @param {RequestT} request\n   * @param {ResponseT} response\n   * @returns {Error}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _mapStatusError(request, response) {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * Map the request, response, and the node account ID used for this attempt into a response.\n   * This method will only be called when `_shouldRetry` returned `ExecutionState.Finished`\n   *\n   * @abstract\n   * @protected\n   * @param {ResponseT} response\n   * @param {AccountId} nodeAccountId\n   * @param {RequestT} request\n   * @returns {Promise<OutputT>}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _mapResponse(response, nodeAccountId, request) {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * Perform a single grpc call with the given request. Each request has it's own\n   * required service so we just pass in channel, and it'$ the request's responsiblity\n   * to use the right service and call the right grpc method.\n   *\n   * @abstract\n   * @internal\n   * @param {Channel} channel\n   * @param {RequestT} request\n   * @returns {Promise<ResponseT>}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _execute(channel, request) {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * Return the current transaction ID for the request. All requests which are\n   * use the same transaction ID for each node, but the catch is that `Transaction`\n   * implicitly supports chunked transactions. Meaning there could be multiple\n   * transaction IDs stored in the request, and a different transaction ID will be used\n   * on subsequent calls to `execute()`\n   *\n   * FIXME: This method can most likely be removed, although some further inspection\n   * is required.\n   *\n   * @abstract\n   * @protected\n   * @returns {TransactionId}\n   */\n\n\n  _getTransactionId() {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * Return the log ID for this particular request\n   *\n   * Log IDs are simply a string constructed to make it easy to track each request's\n   * execution even when mulitple requests are executing in parallel. Typically, this\n   * method returns the format of `[<request type>.<timestamp of the transaction ID>]`\n   *\n   * Maybe we should deduplicate this using ${this.consturtor.name}\n   *\n   * @abstract\n   * @internal\n   * @returns {string}\n   */\n\n\n  _getLogId() {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * Serialize the request into bytes\n   *\n   * @abstract\n   * @param {RequestT} request\n   * @returns {Uint8Array}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _requestToBytes(request) {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * Serialize the response into bytes\n   *\n   * @abstract\n   * @param {ResponseT} response\n   * @returns {Uint8Array}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _responseToBytes(response) {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * Advance the request to the next node\n   *\n   * FIXME: This method used to perform different code depending on if we're\n   * executing a query or transaction, but that is no longer the case\n   * and hence could be removed.\n   *\n   * @protected\n   * @returns {void}\n   */\n\n\n  _advanceRequest() {\n    this._nodeAccountIds.advance();\n  }\n  /**\n   * Determine if we should continue the execution process, error, or finish.\n   *\n   * FIXME: This method should really be called something else. Initially it returned\n   * a boolean so `shouldRetry` made sense, but now it returns an enum, so the name\n   * no longer makes sense.\n   *\n   * @abstract\n   * @protected\n   * @param {RequestT} request\n   * @param {ResponseT} response\n   * @returns {[Status, ExecutionState]}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _shouldRetry(request, response) {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * Determine if we should error based on the gRPC status\n   *\n   * Unlike `shouldRetry` this method does in fact still return a boolean\n   *\n   * @protected\n   * @param {GrpcServiceError} error\n   * @returns {boolean}\n   */\n\n\n  _shouldRetryExceptionally(error) {\n    return error.status._code === GrpcStatus.Unavailable._code || error.status._code === GrpcStatus.ResourceExhausted._code || error.status._code === GrpcStatus.Internal._code && RST_STREAM.test(error.message);\n  }\n  /**\n   * A helper method for setting the operator on the request\n   *\n   * @internal\n   * @param {AccountId} accountId\n   * @param {PublicKey} publicKey\n   * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner\n   * @returns {this}\n   */\n\n\n  _setOperatorWith(accountId, publicKey, transactionSigner) {\n    this._operator = {\n      transactionSigner,\n      accountId,\n      publicKey\n    };\n    return this;\n  }\n  /**\n   * Execute this request using the signer\n   *\n   * This method is part of the signature providers feature\n   * https://hips.hedera.com/hip/hip-338\n   *\n   * @param {Signer} signer\n   * @returns {Promise<OutputT>}\n   */\n\n\n  async executeWithSigner(signer) {\n    return signer.call(this);\n  }\n  /**\n   * Execute the request using a client and an optional request timeout\n   *\n   * @template {Channel} ChannelT\n   * @template MirrorChannelT\n   * @param {import(\"./client/Client.js\").default<ChannelT, MirrorChannelT>} client\n   * @param {number=} requestTimeout\n   * @returns {Promise<OutputT>}\n   */\n\n\n  async execute(client, requestTimeout) {\n    // If the request timeout is set on the request we'll prioritize that instead\n    // of the parameter provided, and if the parameter isn't provided we'll\n    // use the default request timeout on client\n    if (this._requestTimeout == null) {\n      this._requestTimeout = requestTimeout != null ? requestTimeout : client.requestTimeout;\n    } // Some request need to perform additional requests before the executing\n    // such as paid queries need to fetch the cost of the query before\n    // finally executing the actual query.\n\n\n    await this._beforeExecute(client); // If the max backoff on the request is not set, use the default value in client\n\n    if (this._maxBackoff == null) {\n      this._maxBackoff = client.maxBackoff;\n    } // If the min backoff on the request is not set, use the default value in client\n\n\n    if (this._minBackoff == null) {\n      this._minBackoff = client.minBackoff;\n    } // If the max attempts on the request is not set, use the default value in client\n    // If the default value in client is not set, use a default of 10.\n    //\n    // FIXME: current implementation is wrong, update to follow comment above.\n\n\n    const maxAttempts = client._maxAttempts != null ? client._maxAttempts : this._maxAttempts; // Save the start time to be used later with request timeout\n\n    const startTime = Date.now(); // Saves each error we get so when we err due to max attempts exceeded we'll have\n    // the last error that was returned by the consensus node\n\n    let persistentError = null; // The retry loop\n\n    for (let attempt = 1; attempt <= maxAttempts; attempt += 1) {\n      // Determine if we've exceeded request timeout\n      if (this._requestTimeout != null && startTime + this._requestTimeout <= Date.now()) {\n        throw new Error(\"timeout exceeded\");\n      }\n\n      let nodeAccountId;\n      let node; // If node account IDs is locked then use the node account IDs\n      // from the list, otherwise build a new list of one node account ID\n      // using the entire network\n\n      if (this._nodeAccountIds.locked) {\n        nodeAccountId = this._nodeAccountIds.current;\n        node = client._network.getNode(nodeAccountId);\n      } else {\n        node = client._network.getNode();\n        nodeAccountId = node.accountId;\n\n        this._nodeAccountIds.setList([nodeAccountId]);\n      }\n\n      if (node == null) {\n        throw new Error(`NodeAccountId not recognized: ${nodeAccountId.toString()}`);\n      } // Get the log ID for the request.\n\n\n      const logId = this._getLogId();\n\n      Logger.debug(`[${logId}] Node AccountID: ${node.accountId.toString()}, IP: ${node.address.toString()}`);\n      const channel = node.getChannel();\n      const request = await this._makeRequestAsync(); // advance the internal index\n      // non-free queries and transactions map to more than 1 actual transaction and this will cause\n      // the next invocation of makeRequest to return the _next_ transaction\n      // FIXME: This is likely no longer relavent after we've transitioned to using our `List` type\n      // can be replaced with `this._nodeAccountIds.advance();`\n\n      this._advanceRequest();\n\n      let response; // If the node is unhealthy, wait for it to be healthy\n      // FIXME: This is wrong, we should skip to the next node, and only perform\n      // a request backoff after we've tried all nodes in the current list.\n\n      if (!node.isHealthy()) {\n        Logger.debug(`[${logId}] node is not healthy, skipping waiting ${node.getRemainingTime()}`);\n        await node.backoff();\n      }\n\n      try {\n        // Race the execution promise against the grpc timeout to prevent grpc connections\n        // from blocking this request\n        const promises = []; // If a grpc deadline is est, we should race it, otherwise the only thing in the\n        // list of promises will be the execution promise.\n\n        if (this._grpcDeadline != null) {\n          promises.push( // eslint-disable-next-line ie11/no-loop-func\n          new Promise((_, reject) => setTimeout( // eslint-disable-next-line ie11/no-loop-func\n          () => reject(new Error(\"grpc deadline exceeded\")),\n          /** @type {number=} */\n          this._grpcDeadline)));\n        }\n\n        Logger.trace(`[${this._getLogId()}] sending protobuf ${hex.encode(this._requestToBytes(request))}`);\n        promises.push(this._execute(channel, request)); // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\n        response =\n        /** @type {ResponseT} */\n        await Promise.race(promises);\n      } catch (err) {\n        // If we received a grpc status error we need to determine if\n        // we should retry on this error, or err from the request entirely.\n        const error = GrpcServiceError._fromResponse(\n        /** @type {Error} */\n        err); // Save the error in case we retry\n\n\n        persistentError = error;\n        Logger.debug(`[${logId}] received gRPC error ${JSON.stringify(error)}`);\n\n        if (error instanceof GrpcServiceError && this._shouldRetryExceptionally(error) && attempt <= maxAttempts) {\n          // Increase the backoff for the particular node and remove it from\n          // the healthy node list\n          client._network.increaseBackoff(node);\n\n          continue;\n        }\n\n        throw err;\n      }\n\n      Logger.trace(`[${this._getLogId()}] sending protobuf ${hex.encode(this._responseToBytes(response))}`); // If we didn't receive an error we should decrease the current nodes backoff\n      // in case it is a recovering node\n\n      client._network.decreaseBackoff(node); // Determine what execution state we're in by the response\n      // For transactions this would be as simple as checking the response status is `OK`\n      // while for _most_ queries it would check if the response status is `SUCCESS`\n      // The only odd balls are `TransactionReceiptQuery` and `TransactionRecordQuery`\n\n\n      const [err, shouldRetry] = this._shouldRetry(request, response);\n\n      if (err != null) {\n        persistentError = err;\n      } // Determine by the executing state what we should do\n\n\n      switch (shouldRetry) {\n        case ExecutionState.Retry:\n          await delayForAttempt(attempt, this._minBackoff, this._maxBackoff);\n          continue;\n\n        case ExecutionState.Finished:\n          return this._mapResponse(response, nodeAccountId, request);\n\n        case ExecutionState.Error:\n          throw this._mapStatusError(request, response);\n\n        default:\n          throw new Error(\"(BUG) non-exhuastive switch statement for `ExecutionState`\");\n      }\n    } // We'll only get here if we've run out of attempts, so we return an error wrapping the\n    // persistent error we saved before.\n\n\n    throw new Error(`max attempts of ${maxAttempts.toString()} was reached for request with last error being: ${persistentError != null ? persistentError.toString() : \"\"}`);\n  }\n  /**\n   * The current purpose of this method is to easily support signature providers since\n   * signature providers need to serialize _any_ request into bytes. `Query` and `Transaction`\n   * already implement `toBytes()` so it only made sense to make it avaiable here too.\n   *\n   * @abstract\n   * @returns {Uint8Array}\n   */\n\n\n  toBytes() {\n    throw new Error(\"not implemented\");\n  }\n\n}\n/**\n * A simple function that returns a promise timeout for a specific period of time\n *\n * @param {number} attempt\n * @param {number} minBackoff\n * @param {number} maxBackoff\n * @returns {Promise<void>}\n */\n\nfunction delayForAttempt(attempt, minBackoff, maxBackoff) {\n  // 0.1s, 0.2s, 0.4s, 0.8s, ...\n  const ms = Math.min(Math.floor(minBackoff * Math.pow(2, attempt)), maxBackoff);\n  return new Promise(resolve => setTimeout(resolve, ms));\n}","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/hbar-shop/hbar-shopify-coupon-client/node_modules/@hashgraph/sdk/src/Executable.js"],"names":["GrpcServiceError","GrpcStatus","List","Logger","hex","ExecutionState","Finished","Retry","Error","RST_STREAM","Executable","constructor","_maxAttempts","_nodeAccountIds","_signOnDemand","_minBackoff","_maxBackoff","_operator","_requestTimeout","_grpcDeadline","nodeAccountIds","isEmpty","setLocked","list","setNodeAccountIds","nodeIds","setList","maxRetries","console","warn","maxAttempts","setMaxRetries","setMaxAttempts","grpcDeadline","setGrpcDeadline","setMinBackoff","minBackoff","setMaxBackoff","maxBackoff","_beforeExecute","client","_makeRequestAsync","_mapStatusError","request","response","_mapResponse","nodeAccountId","_execute","channel","_getTransactionId","_getLogId","_requestToBytes","_responseToBytes","_advanceRequest","advance","_shouldRetry","_shouldRetryExceptionally","error","status","_code","Unavailable","ResourceExhausted","Internal","test","message","_setOperatorWith","accountId","publicKey","transactionSigner","executeWithSigner","signer","call","execute","requestTimeout","startTime","Date","now","persistentError","attempt","node","locked","current","_network","getNode","toString","logId","debug","address","getChannel","isHealthy","getRemainingTime","backoff","promises","push","Promise","_","reject","setTimeout","trace","encode","race","err","_fromResponse","JSON","stringify","increaseBackoff","decreaseBackoff","shouldRetry","delayForAttempt","toBytes","ms","Math","min","floor","pow","resolve"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,OAAOA,gBAAP,MAA6B,4BAA7B;AACA,OAAOC,UAAP,MAAuB,sBAAvB;AACA,OAAOC,IAAP,MAAiB,uBAAjB;AACA,OAAOC,MAAP,MAAmB,WAAnB;AACA,OAAO,KAAKC,GAAZ,MAAqB,mBAArB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA,OAAO,MAAMC,cAAc,GAAG;AAC1BC,EAAAA,QAAQ,EAAE,UADgB;AAE1BC,EAAAA,KAAK,EAAE,OAFmB;AAG1BC,EAAAA,KAAK,EAAE;AAHmB,CAAvB;AAMP,OAAO,MAAMC,UAAU,GAAG,4BAAnB;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,UAAN,CAAiB;AAC5BC,EAAAA,WAAW,GAAG;AACV;AACR;AACA;AACA;AACA;AACA;AACQ,SAAKC,YAAL,GAAoB,EAApB;AAEA;AACR;AACA;AACA;AACA;AACA;AACA;;AACQ,SAAKC,eAAL,GAAuB,IAAIX,IAAJ,EAAvB;AAEA;AACR;AACA;;AACQ,SAAKY,aAAL,GAAqB,KAArB;AAEA;AACR;AACA;AACA;AACA;AACA;;AACQ,SAAKC,WAAL,GAAmB,IAAnB;AAEA;AACR;AACA;AACA;AACA;AACA;;AACQ,SAAKC,WAAL,GAAmB,IAAnB;AAEA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACQ,SAAKC,SAAL,GAAiB,IAAjB;AAEA;AACR;AACA;AACA;AACA;AACA;;AACQ,SAAKC,eAAL,GAAuB,IAAvB;AAEA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACQ,SAAKC,aAAL,GAAqB,IAArB;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACsB,MAAdC,cAAc,GAAG;AACjB,QAAI,KAAKP,eAAL,CAAqBQ,OAAzB,EAAkC;AAC9B,aAAO,IAAP;AACH,KAFD,MAEO;AACH,WAAKR,eAAL,CAAqBS,SAArB;;AACA,aAAO,KAAKT,eAAL,CAAqBU,IAA5B;AACH;AACJ;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,iBAAiB,CAACC,OAAD,EAAU;AACvB;AACA;AACA,SAAKZ,eAAL,CAAqBa,OAArB,CAA6BD,OAA7B,EAAsCH,SAAtC;;AACA,WAAO,IAAP;AACH;AAED;AACJ;AACA;AACA;;;AACkB,MAAVK,UAAU,GAAG;AACbC,IAAAA,OAAO,CAACC,IAAR,CAAa,qCAAb;AACA,WAAO,KAAKC,WAAZ;AACH;AAED;AACJ;AACA;AACA;;;AACIC,EAAAA,aAAa,CAACJ,UAAD,EAAa;AACtBC,IAAAA,OAAO,CAACC,IAAR,CAAa,0CAAb;AACA,WAAO,KAAKG,cAAL,CAAoBL,UAApB,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;;;AACmB,MAAXG,WAAW,GAAG;AACd,WAAO,KAAKlB,YAAZ;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACIoB,EAAAA,cAAc,CAACF,WAAD,EAAc;AACxB,SAAKlB,YAAL,GAAoBkB,WAApB;AAEA,WAAO,IAAP;AACH;AAED;AACJ;AACA;AACA;AACA;;;AACoB,MAAZG,YAAY,GAAG;AACf,WAAO,KAAKd,aAAZ;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACIe,EAAAA,eAAe,CAACD,YAAD,EAAe;AAC1B,SAAKd,aAAL,GAAqBc,YAArB;AAEA,WAAO,IAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACIE,EAAAA,aAAa,CAACC,UAAD,EAAa;AACtB;AACA;AACA,QAAIA,UAAU,IAAI,IAAlB,EAAwB;AACpB,YAAM,IAAI5B,KAAJ,CAAU,4BAAV,CAAN;AACH,KAFD,MAEO,IAAI,KAAKQ,WAAL,IAAoB,IAApB,IAA4BoB,UAAU,GAAG,KAAKpB,WAAlD,EAA+D;AAClE,YAAM,IAAIR,KAAJ,CAAU,8CAAV,CAAN;AACH;;AACD,SAAKO,WAAL,GAAmBqB,UAAnB;AACA,WAAO,IAAP;AACH;AAED;AACJ;AACA;AACA;AACA;;;AACkB,MAAVA,UAAU,GAAG;AACb,WAAO,KAAKrB,WAAZ;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACIsB,EAAAA,aAAa,CAACC,UAAD,EAAa;AACtB;AACA;AACA,QAAIA,UAAU,IAAI,IAAlB,EAAwB;AACpB,YAAM,IAAI9B,KAAJ,CAAU,4BAAV,CAAN;AACH,KAFD,MAEO,IAAI,KAAKO,WAAL,IAAoB,IAApB,IAA4BuB,UAAU,GAAG,KAAKvB,WAAlD,EAA+D;AAClE,YAAM,IAAIP,KAAJ,CAAU,+CAAV,CAAN;AACH;;AACD,SAAKQ,WAAL,GAAmBsB,UAAnB;AACA,WAAO,IAAP;AACH;AAED;AACJ;AACA;AACA;AACA;;;AACkB,MAAVA,UAAU,GAAG;AACb,WAAO,KAAKtB,WAAZ;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI;;;AACAuB,EAAAA,cAAc,CAACC,MAAD,EAAS;AACnB,UAAM,IAAIhC,KAAJ,CAAU,iBAAV,CAAN;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIiC,EAAAA,iBAAiB,GAAG;AAChB,UAAM,IAAIjC,KAAJ,CAAU,iBAAV,CAAN;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI;;;AACAkC,EAAAA,eAAe,CAACC,OAAD,EAAUC,QAAV,EAAoB;AAC/B,UAAM,IAAIpC,KAAJ,CAAU,iBAAV,CAAN;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI;;;AACAqC,EAAAA,YAAY,CAACD,QAAD,EAAWE,aAAX,EAA0BH,OAA1B,EAAmC;AAC3C,UAAM,IAAInC,KAAJ,CAAU,iBAAV,CAAN;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI;;;AACAuC,EAAAA,QAAQ,CAACC,OAAD,EAAUL,OAAV,EAAmB;AACvB,UAAM,IAAInC,KAAJ,CAAU,iBAAV,CAAN;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIyC,EAAAA,iBAAiB,GAAG;AAChB,UAAM,IAAIzC,KAAJ,CAAU,iBAAV,CAAN;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI0C,EAAAA,SAAS,GAAG;AACR,UAAM,IAAI1C,KAAJ,CAAU,iBAAV,CAAN;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACI;;;AACA2C,EAAAA,eAAe,CAACR,OAAD,EAAU;AACrB,UAAM,IAAInC,KAAJ,CAAU,iBAAV,CAAN;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACI;;;AACA4C,EAAAA,gBAAgB,CAACR,QAAD,EAAW;AACvB,UAAM,IAAIpC,KAAJ,CAAU,iBAAV,CAAN;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI6C,EAAAA,eAAe,GAAG;AACd,SAAKxC,eAAL,CAAqByC,OAArB;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI;;;AACAC,EAAAA,YAAY,CAACZ,OAAD,EAAUC,QAAV,EAAoB;AAC5B,UAAM,IAAIpC,KAAJ,CAAU,iBAAV,CAAN;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIgD,EAAAA,yBAAyB,CAACC,KAAD,EAAQ;AAC7B,WACIA,KAAK,CAACC,MAAN,CAAaC,KAAb,KAAuB1D,UAAU,CAAC2D,WAAX,CAAuBD,KAA9C,IACAF,KAAK,CAACC,MAAN,CAAaC,KAAb,KAAuB1D,UAAU,CAAC4D,iBAAX,CAA6BF,KADpD,IAECF,KAAK,CAACC,MAAN,CAAaC,KAAb,KAAuB1D,UAAU,CAAC6D,QAAX,CAAoBH,KAA3C,IACGlD,UAAU,CAACsD,IAAX,CAAgBN,KAAK,CAACO,OAAtB,CAJR;AAMH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,gBAAgB,CAACC,SAAD,EAAYC,SAAZ,EAAuBC,iBAAvB,EAA0C;AACtD,SAAKnD,SAAL,GAAiB;AACbmD,MAAAA,iBADa;AAEbF,MAAAA,SAFa;AAGbC,MAAAA;AAHa,KAAjB;AAKA,WAAO,IAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAC2B,QAAjBE,iBAAiB,CAACC,MAAD,EAAS;AAC5B,WAAOA,MAAM,CAACC,IAAP,CAAY,IAAZ,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACiB,QAAPC,OAAO,CAAChC,MAAD,EAASiC,cAAT,EAAyB;AAClC;AACA;AACA;AACA,QAAI,KAAKvD,eAAL,IAAwB,IAA5B,EAAkC;AAC9B,WAAKA,eAAL,GACIuD,cAAc,IAAI,IAAlB,GAAyBA,cAAzB,GAA0CjC,MAAM,CAACiC,cADrD;AAEH,KAPiC,CASlC;AACA;AACA;;;AACA,UAAM,KAAKlC,cAAL,CAAoBC,MAApB,CAAN,CAZkC,CAclC;;AACA,QAAI,KAAKxB,WAAL,IAAoB,IAAxB,EAA8B;AAC1B,WAAKA,WAAL,GAAmBwB,MAAM,CAACF,UAA1B;AACH,KAjBiC,CAmBlC;;;AACA,QAAI,KAAKvB,WAAL,IAAoB,IAAxB,EAA8B;AAC1B,WAAKA,WAAL,GAAmByB,MAAM,CAACJ,UAA1B;AACH,KAtBiC,CAwBlC;AACA;AACA;AACA;;;AACA,UAAMN,WAAW,GACbU,MAAM,CAAC5B,YAAP,IAAuB,IAAvB,GACM4B,MAAM,CAAC5B,YADb,GAEM,KAAKA,YAHf,CA5BkC,CAiClC;;AACA,UAAM8D,SAAS,GAAGC,IAAI,CAACC,GAAL,EAAlB,CAlCkC,CAoClC;AACA;;AACA,QAAIC,eAAe,GAAG,IAAtB,CAtCkC,CAwClC;;AACA,SAAK,IAAIC,OAAO,GAAG,CAAnB,EAAsBA,OAAO,IAAIhD,WAAjC,EAA8CgD,OAAO,IAAI,CAAzD,EAA4D;AACxD;AACA,UACI,KAAK5D,eAAL,IAAwB,IAAxB,IACAwD,SAAS,GAAG,KAAKxD,eAAjB,IAAoCyD,IAAI,CAACC,GAAL,EAFxC,EAGE;AACE,cAAM,IAAIpE,KAAJ,CAAU,kBAAV,CAAN;AACH;;AAED,UAAIsC,aAAJ;AACA,UAAIiC,IAAJ,CAVwD,CAYxD;AACA;AACA;;AACA,UAAI,KAAKlE,eAAL,CAAqBmE,MAAzB,EAAiC;AAC7BlC,QAAAA,aAAa,GAAG,KAAKjC,eAAL,CAAqBoE,OAArC;AACAF,QAAAA,IAAI,GAAGvC,MAAM,CAAC0C,QAAP,CAAgBC,OAAhB,CAAwBrC,aAAxB,CAAP;AACH,OAHD,MAGO;AACHiC,QAAAA,IAAI,GAAGvC,MAAM,CAAC0C,QAAP,CAAgBC,OAAhB,EAAP;AACArC,QAAAA,aAAa,GAAGiC,IAAI,CAACb,SAArB;;AACA,aAAKrD,eAAL,CAAqBa,OAArB,CAA6B,CAACoB,aAAD,CAA7B;AACH;;AAED,UAAIiC,IAAI,IAAI,IAAZ,EAAkB;AACd,cAAM,IAAIvE,KAAJ,CACD,iCAAgCsC,aAAa,CAACsC,QAAd,EAAyB,EADxD,CAAN;AAGH,OA5BuD,CA8BxD;;;AACA,YAAMC,KAAK,GAAG,KAAKnC,SAAL,EAAd;;AACA/C,MAAAA,MAAM,CAACmF,KAAP,CACK,IAAGD,KAAM,qBAAoBN,IAAI,CAACb,SAAL,CAAekB,QAAf,EAA0B,SAAQL,IAAI,CAACQ,OAAL,CAAaH,QAAb,EAAwB,EAD5F;AAIA,YAAMpC,OAAO,GAAG+B,IAAI,CAACS,UAAL,EAAhB;AACA,YAAM7C,OAAO,GAAG,MAAM,KAAKF,iBAAL,EAAtB,CArCwD,CAuCxD;AACA;AACA;AACA;AACA;;AACA,WAAKY,eAAL;;AAEA,UAAIT,QAAJ,CA9CwD,CAgDxD;AACA;AACA;;AACA,UAAI,CAACmC,IAAI,CAACU,SAAL,EAAL,EAAuB;AACnBtF,QAAAA,MAAM,CAACmF,KAAP,CACK,IAAGD,KAAM,2CAA0CN,IAAI,CAACW,gBAAL,EAAwB,EADhF;AAGA,cAAMX,IAAI,CAACY,OAAL,EAAN;AACH;;AAED,UAAI;AACA;AACA;AACA,cAAMC,QAAQ,GAAG,EAAjB,CAHA,CAKA;AACA;;AACA,YAAI,KAAKzE,aAAL,IAAsB,IAA1B,EAAgC;AAC5ByE,UAAAA,QAAQ,CAACC,IAAT,EACI;AACA,cAAIC,OAAJ,CAAY,CAACC,CAAD,EAAIC,MAAJ,KACRC,UAAU,EACN;AACA,gBACID,MAAM,CAAC,IAAIxF,KAAJ,CAAU,wBAAV,CAAD,CAHJ;AAIN;AAAwB,eAAKW,aAJvB,CADd,CAFJ;AAWH;;AACDhB,QAAAA,MAAM,CAAC+F,KAAP,CACK,IAAG,KAAKhD,SAAL,EAAiB,sBAAqB9C,GAAG,CAAC+F,MAAJ,CACtC,KAAKhD,eAAL,CAAqBR,OAArB,CADsC,CAExC,EAHN;AAKAiD,QAAAA,QAAQ,CAACC,IAAT,CAAc,KAAK9C,QAAL,CAAcC,OAAd,EAAuBL,OAAvB,CAAd,EAzBA,CA0BA;;AACAC,QAAAA,QAAQ;AAAG;AACP,cAAMkD,OAAO,CAACM,IAAR,CAAaR,QAAb,CADV;AAGH,OA9BD,CA8BE,OAAOS,GAAP,EAAY;AACV;AACA;AACA,cAAM5C,KAAK,GAAGzD,gBAAgB,CAACsG,aAAjB;AACV;AAAsBD,QAAAA,GADZ,CAAd,CAHU,CAOV;;;AACAxB,QAAAA,eAAe,GAAGpB,KAAlB;AACAtD,QAAAA,MAAM,CAACmF,KAAP,CACK,IAAGD,KAAM,yBAAwBkB,IAAI,CAACC,SAAL,CAAe/C,KAAf,CAAsB,EAD5D;;AAIA,YACIA,KAAK,YAAYzD,gBAAjB,IACA,KAAKwD,yBAAL,CAA+BC,KAA/B,CADA,IAEAqB,OAAO,IAAIhD,WAHf,EAIE;AACE;AACA;AACAU,UAAAA,MAAM,CAAC0C,QAAP,CAAgBuB,eAAhB,CAAgC1B,IAAhC;;AACA;AACH;;AAED,cAAMsB,GAAN;AACH;;AAEDlG,MAAAA,MAAM,CAAC+F,KAAP,CACK,IAAG,KAAKhD,SAAL,EAAiB,sBAAqB9C,GAAG,CAAC+F,MAAJ,CACtC,KAAK/C,gBAAL,CAAsBR,QAAtB,CADsC,CAExC,EAHN,EAnHwD,CAyHxD;AACA;;AACAJ,MAAAA,MAAM,CAAC0C,QAAP,CAAgBwB,eAAhB,CAAgC3B,IAAhC,EA3HwD,CA6HxD;AACA;AACA;AACA;;;AACA,YAAM,CAACsB,GAAD,EAAMM,WAAN,IAAqB,KAAKpD,YAAL,CAAkBZ,OAAlB,EAA2BC,QAA3B,CAA3B;;AACA,UAAIyD,GAAG,IAAI,IAAX,EAAiB;AACbxB,QAAAA,eAAe,GAAGwB,GAAlB;AACH,OApIuD,CAsIxD;;;AACA,cAAQM,WAAR;AACI,aAAKtG,cAAc,CAACE,KAApB;AACI,gBAAMqG,eAAe,CACjB9B,OADiB,EAEjB,KAAK/D,WAFY,EAGjB,KAAKC,WAHY,CAArB;AAKA;;AACJ,aAAKX,cAAc,CAACC,QAApB;AACI,iBAAO,KAAKuC,YAAL,CAAkBD,QAAlB,EAA4BE,aAA5B,EAA2CH,OAA3C,CAAP;;AACJ,aAAKtC,cAAc,CAACG,KAApB;AACI,gBAAM,KAAKkC,eAAL,CAAqBC,OAArB,EAA8BC,QAA9B,CAAN;;AACJ;AACI,gBAAM,IAAIpC,KAAJ,CACF,4DADE,CAAN;AAbR;AAiBH,KAjMiC,CAmMlC;AACA;;;AACA,UAAM,IAAIA,KAAJ,CACD,mBAAkBsB,WAAW,CAACsD,QAAZ,EAAuB,mDACtCP,eAAe,IAAI,IAAnB,GAA0BA,eAAe,CAACO,QAAhB,EAA1B,GAAuD,EAC1D,EAHC,CAAN;AAKH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIyB,EAAAA,OAAO,GAAG;AACN,UAAM,IAAIrG,KAAJ,CAAU,iBAAV,CAAN;AACH;;AA9oB2B;AAipBhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASoG,eAAT,CAAyB9B,OAAzB,EAAkC1C,UAAlC,EAA8CE,UAA9C,EAA0D;AACtD;AACA,QAAMwE,EAAE,GAAGC,IAAI,CAACC,GAAL,CACPD,IAAI,CAACE,KAAL,CAAW7E,UAAU,GAAG2E,IAAI,CAACG,GAAL,CAAS,CAAT,EAAYpC,OAAZ,CAAxB,CADO,EAEPxC,UAFO,CAAX;AAIA,SAAO,IAAIwD,OAAJ,CAAaqB,OAAD,IAAalB,UAAU,CAACkB,OAAD,EAAUL,EAAV,CAAnC,CAAP;AACH","sourcesContent":["/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\n\nimport GrpcServiceError from \"./grpc/GrpcServiceError.js\";\nimport GrpcStatus from \"./grpc/GrpcStatus.js\";\nimport List from \"./transaction/List.js\";\nimport Logger from \"js-logger\";\nimport * as hex from \"./encoding/hex.js\";\n\n/**\n * @typedef {import(\"./account/AccountId.js\").default} AccountId\n * @typedef {import(\"./Status.js\").default} Status\n * @typedef {import(\"./channel/Channel.js\").default} Channel\n * @typedef {import(\"./transaction/TransactionId.js\").default} TransactionId\n * @typedef {import(\"./client/Client.js\").ClientOperator} ClientOperator\n * @typedef {import(\"./Signer.js\").Signer} Signer\n * @typedef {import(\"./PublicKey.js\").default} PublicKey\n */\n\n/**\n * @enum {string}\n */\nexport const ExecutionState = {\n    Finished: \"Finished\",\n    Retry: \"Retry\",\n    Error: \"Error\",\n};\n\nexport const RST_STREAM = /\\brst[^0-9a-zA-Z]stream\\b/i;\n\n/**\n * @abstract\n * @internal\n * @template RequestT\n * @template ResponseT\n * @template OutputT\n */\nexport default class Executable {\n    constructor() {\n        /**\n         * The number of times we can retry the grpc call\n         *\n         * @private\n         * @type {number}\n         */\n        this._maxAttempts = 10;\n\n        /**\n         * List of node account IDs for each transaction that has been\n         * built.\n         *\n         * @internal\n         * @type {List<AccountId>}\n         */\n        this._nodeAccountIds = new List();\n\n        /**\n         * @internal\n         */\n        this._signOnDemand = false;\n\n        /**\n         * This is the request's min backoff\n         *\n         * @internal\n         * @type {number | null}\n         */\n        this._minBackoff = null;\n\n        /**\n         * This is the request's max backoff\n         *\n         * @internal\n         * @type {number | null}\n         */\n        this._maxBackoff = null;\n\n        /**\n         * The operator that was used to execute this request.\n         * The reason we save the operator in the request is because of the signing on\n         * demand feature. This feature requires us to sign new request on each attempt\n         * meaning if a client with an operator was used we'd need to sign with the operator\n         * on each attempt.\n         *\n         * @internal\n         * @type {ClientOperator | null}\n         */\n        this._operator = null;\n\n        /**\n         * The complete timeout for running the `execute()` method\n         *\n         * @internal\n         * @type {number | null}\n         */\n        this._requestTimeout = null;\n\n        /**\n         * The grpc request timeout aka deadline.\n         *\n         * The reason we have this is because there were times that consensus nodes held the grpc\n         * connection, but didn't return anything; not error nor regular response. This resulted\n         * in some weird behavior in the SDKs. To fix this we've added a grpc deadline to prevent\n         * nodes from stalling the executing of a request.\n         *\n         * @internal\n         * @type {number | null}\n         */\n        this._grpcDeadline = null;\n    }\n\n    /**\n     * Get the list of node account IDs on the request. If no nodes are set, then null is returned.\n     * The reasoning for this is simply \"legacy behavior\".\n     *\n     * @returns {?AccountId[]}\n     */\n    get nodeAccountIds() {\n        if (this._nodeAccountIds.isEmpty) {\n            return null;\n        } else {\n            this._nodeAccountIds.setLocked();\n            return this._nodeAccountIds.list;\n        }\n    }\n\n    /**\n     * Set the node account IDs on the request\n     *\n     * @param {AccountId[]} nodeIds\n     * @returns {this}\n     */\n    setNodeAccountIds(nodeIds) {\n        // Set the node account IDs, and lock the list. This will require `execute`\n        // to use these nodes instead of random nodes from the network.\n        this._nodeAccountIds.setList(nodeIds).setLocked();\n        return this;\n    }\n\n    /**\n     * @deprecated\n     * @returns {number}\n     */\n    get maxRetries() {\n        console.warn(\"Deprecated: use maxAttempts instead\");\n        return this.maxAttempts;\n    }\n\n    /**\n     * @param {number} maxRetries\n     * @returns {this}\n     */\n    setMaxRetries(maxRetries) {\n        console.warn(\"Deprecated: use setMaxAttempts() instead\");\n        return this.setMaxAttempts(maxRetries);\n    }\n\n    /**\n     * Get the max attempts on the request\n     *\n     * @returns {number}\n     */\n    get maxAttempts() {\n        return this._maxAttempts;\n    }\n\n    /**\n     * Set the max attempts on the request\n     *\n     * @param {number} maxAttempts\n     * @returns {this}\n     */\n    setMaxAttempts(maxAttempts) {\n        this._maxAttempts = maxAttempts;\n\n        return this;\n    }\n\n    /**\n     * Get the grpc deadline\n     *\n     * @returns {?number}\n     */\n    get grpcDeadline() {\n        return this._grpcDeadline;\n    }\n\n    /**\n     * Set the grpc deadline\n     *\n     * @param {number} grpcDeadline\n     * @returns {this}\n     */\n    setGrpcDeadline(grpcDeadline) {\n        this._grpcDeadline = grpcDeadline;\n\n        return this;\n    }\n\n    /**\n     * Set the min backoff for the request\n     *\n     * @param {number} minBackoff\n     * @returns {this}\n     */\n    setMinBackoff(minBackoff) {\n        // Honestly we shouldn't be checking for null since that should be TypeScript's job.\n        // Also verify that min backoff is not greater than max backoff.\n        if (minBackoff == null) {\n            throw new Error(\"minBackoff cannot be null.\");\n        } else if (this._maxBackoff != null && minBackoff > this._maxBackoff) {\n            throw new Error(\"minBackoff cannot be larger than maxBackoff.\");\n        }\n        this._minBackoff = minBackoff;\n        return this;\n    }\n\n    /**\n     * Get the min backoff\n     *\n     * @returns {number | null}\n     */\n    get minBackoff() {\n        return this._minBackoff;\n    }\n\n    /**\n     * Set the max backoff for the request\n     *\n     * @param {?number} maxBackoff\n     * @returns {this}\n     */\n    setMaxBackoff(maxBackoff) {\n        // Honestly we shouldn't be checking for null since that should be TypeScript's job.\n        // Also verify that max backoff is not less than min backoff.\n        if (maxBackoff == null) {\n            throw new Error(\"maxBackoff cannot be null.\");\n        } else if (this._minBackoff != null && maxBackoff < this._minBackoff) {\n            throw new Error(\"maxBackoff cannot be smaller than minBackoff.\");\n        }\n        this._maxBackoff = maxBackoff;\n        return this;\n    }\n\n    /**\n     * Get the max backoff\n     *\n     * @returns {number | null}\n     */\n    get maxBackoff() {\n        return this._maxBackoff;\n    }\n\n    /**\n     * This method is responsible for doing any work before the executing process begins.\n     * For paid queries this will result in executing a cost query, for transactions this\n     * will make sure we save the operator and sign any requests that need to be signed\n     * in case signing on demand is disabled.\n     *\n     * @abstract\n     * @protected\n     * @param {import(\"./client/Client.js\").default<Channel, *>} client\n     * @returns {Promise<void>}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _beforeExecute(client) {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * Create a protobuf request which will be passed into the `_execute()` method\n     *\n     * @abstract\n     * @protected\n     * @returns {Promise<RequestT>}\n     */\n    _makeRequestAsync() {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * This name is a bit wrong now, but the purpose of this method is to map the\n     * request and response into an error. This method will only be called when\n     * `_shouldRetry` returned `ExecutionState.Error`\n     *\n     * @abstract\n     * @internal\n     * @param {RequestT} request\n     * @param {ResponseT} response\n     * @returns {Error}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _mapStatusError(request, response) {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * Map the request, response, and the node account ID used for this attempt into a response.\n     * This method will only be called when `_shouldRetry` returned `ExecutionState.Finished`\n     *\n     * @abstract\n     * @protected\n     * @param {ResponseT} response\n     * @param {AccountId} nodeAccountId\n     * @param {RequestT} request\n     * @returns {Promise<OutputT>}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _mapResponse(response, nodeAccountId, request) {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * Perform a single grpc call with the given request. Each request has it's own\n     * required service so we just pass in channel, and it'$ the request's responsiblity\n     * to use the right service and call the right grpc method.\n     *\n     * @abstract\n     * @internal\n     * @param {Channel} channel\n     * @param {RequestT} request\n     * @returns {Promise<ResponseT>}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _execute(channel, request) {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * Return the current transaction ID for the request. All requests which are\n     * use the same transaction ID for each node, but the catch is that `Transaction`\n     * implicitly supports chunked transactions. Meaning there could be multiple\n     * transaction IDs stored in the request, and a different transaction ID will be used\n     * on subsequent calls to `execute()`\n     *\n     * FIXME: This method can most likely be removed, although some further inspection\n     * is required.\n     *\n     * @abstract\n     * @protected\n     * @returns {TransactionId}\n     */\n    _getTransactionId() {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * Return the log ID for this particular request\n     *\n     * Log IDs are simply a string constructed to make it easy to track each request's\n     * execution even when mulitple requests are executing in parallel. Typically, this\n     * method returns the format of `[<request type>.<timestamp of the transaction ID>]`\n     *\n     * Maybe we should deduplicate this using ${this.consturtor.name}\n     *\n     * @abstract\n     * @internal\n     * @returns {string}\n     */\n    _getLogId() {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * Serialize the request into bytes\n     *\n     * @abstract\n     * @param {RequestT} request\n     * @returns {Uint8Array}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _requestToBytes(request) {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * Serialize the response into bytes\n     *\n     * @abstract\n     * @param {ResponseT} response\n     * @returns {Uint8Array}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _responseToBytes(response) {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * Advance the request to the next node\n     *\n     * FIXME: This method used to perform different code depending on if we're\n     * executing a query or transaction, but that is no longer the case\n     * and hence could be removed.\n     *\n     * @protected\n     * @returns {void}\n     */\n    _advanceRequest() {\n        this._nodeAccountIds.advance();\n    }\n\n    /**\n     * Determine if we should continue the execution process, error, or finish.\n     *\n     * FIXME: This method should really be called something else. Initially it returned\n     * a boolean so `shouldRetry` made sense, but now it returns an enum, so the name\n     * no longer makes sense.\n     *\n     * @abstract\n     * @protected\n     * @param {RequestT} request\n     * @param {ResponseT} response\n     * @returns {[Status, ExecutionState]}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _shouldRetry(request, response) {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * Determine if we should error based on the gRPC status\n     *\n     * Unlike `shouldRetry` this method does in fact still return a boolean\n     *\n     * @protected\n     * @param {GrpcServiceError} error\n     * @returns {boolean}\n     */\n    _shouldRetryExceptionally(error) {\n        return (\n            error.status._code === GrpcStatus.Unavailable._code ||\n            error.status._code === GrpcStatus.ResourceExhausted._code ||\n            (error.status._code === GrpcStatus.Internal._code &&\n                RST_STREAM.test(error.message))\n        );\n    }\n\n    /**\n     * A helper method for setting the operator on the request\n     *\n     * @internal\n     * @param {AccountId} accountId\n     * @param {PublicKey} publicKey\n     * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner\n     * @returns {this}\n     */\n    _setOperatorWith(accountId, publicKey, transactionSigner) {\n        this._operator = {\n            transactionSigner,\n            accountId,\n            publicKey,\n        };\n        return this;\n    }\n\n    /**\n     * Execute this request using the signer\n     *\n     * This method is part of the signature providers feature\n     * https://hips.hedera.com/hip/hip-338\n     *\n     * @param {Signer} signer\n     * @returns {Promise<OutputT>}\n     */\n    async executeWithSigner(signer) {\n        return signer.call(this);\n    }\n\n    /**\n     * Execute the request using a client and an optional request timeout\n     *\n     * @template {Channel} ChannelT\n     * @template MirrorChannelT\n     * @param {import(\"./client/Client.js\").default<ChannelT, MirrorChannelT>} client\n     * @param {number=} requestTimeout\n     * @returns {Promise<OutputT>}\n     */\n    async execute(client, requestTimeout) {\n        // If the request timeout is set on the request we'll prioritize that instead\n        // of the parameter provided, and if the parameter isn't provided we'll\n        // use the default request timeout on client\n        if (this._requestTimeout == null) {\n            this._requestTimeout =\n                requestTimeout != null ? requestTimeout : client.requestTimeout;\n        }\n\n        // Some request need to perform additional requests before the executing\n        // such as paid queries need to fetch the cost of the query before\n        // finally executing the actual query.\n        await this._beforeExecute(client);\n\n        // If the max backoff on the request is not set, use the default value in client\n        if (this._maxBackoff == null) {\n            this._maxBackoff = client.maxBackoff;\n        }\n\n        // If the min backoff on the request is not set, use the default value in client\n        if (this._minBackoff == null) {\n            this._minBackoff = client.minBackoff;\n        }\n\n        // If the max attempts on the request is not set, use the default value in client\n        // If the default value in client is not set, use a default of 10.\n        //\n        // FIXME: current implementation is wrong, update to follow comment above.\n        const maxAttempts =\n            client._maxAttempts != null\n                ? client._maxAttempts\n                : this._maxAttempts;\n\n        // Save the start time to be used later with request timeout\n        const startTime = Date.now();\n\n        // Saves each error we get so when we err due to max attempts exceeded we'll have\n        // the last error that was returned by the consensus node\n        let persistentError = null;\n\n        // The retry loop\n        for (let attempt = 1; attempt <= maxAttempts; attempt += 1) {\n            // Determine if we've exceeded request timeout\n            if (\n                this._requestTimeout != null &&\n                startTime + this._requestTimeout <= Date.now()\n            ) {\n                throw new Error(\"timeout exceeded\");\n            }\n\n            let nodeAccountId;\n            let node;\n\n            // If node account IDs is locked then use the node account IDs\n            // from the list, otherwise build a new list of one node account ID\n            // using the entire network\n            if (this._nodeAccountIds.locked) {\n                nodeAccountId = this._nodeAccountIds.current;\n                node = client._network.getNode(nodeAccountId);\n            } else {\n                node = client._network.getNode();\n                nodeAccountId = node.accountId;\n                this._nodeAccountIds.setList([nodeAccountId]);\n            }\n\n            if (node == null) {\n                throw new Error(\n                    `NodeAccountId not recognized: ${nodeAccountId.toString()}`\n                );\n            }\n\n            // Get the log ID for the request.\n            const logId = this._getLogId();\n            Logger.debug(\n                `[${logId}] Node AccountID: ${node.accountId.toString()}, IP: ${node.address.toString()}`\n            );\n\n            const channel = node.getChannel();\n            const request = await this._makeRequestAsync();\n\n            // advance the internal index\n            // non-free queries and transactions map to more than 1 actual transaction and this will cause\n            // the next invocation of makeRequest to return the _next_ transaction\n            // FIXME: This is likely no longer relavent after we've transitioned to using our `List` type\n            // can be replaced with `this._nodeAccountIds.advance();`\n            this._advanceRequest();\n\n            let response;\n\n            // If the node is unhealthy, wait for it to be healthy\n            // FIXME: This is wrong, we should skip to the next node, and only perform\n            // a request backoff after we've tried all nodes in the current list.\n            if (!node.isHealthy()) {\n                Logger.debug(\n                    `[${logId}] node is not healthy, skipping waiting ${node.getRemainingTime()}`\n                );\n                await node.backoff();\n            }\n\n            try {\n                // Race the execution promise against the grpc timeout to prevent grpc connections\n                // from blocking this request\n                const promises = [];\n\n                // If a grpc deadline is est, we should race it, otherwise the only thing in the\n                // list of promises will be the execution promise.\n                if (this._grpcDeadline != null) {\n                    promises.push(\n                        // eslint-disable-next-line ie11/no-loop-func\n                        new Promise((_, reject) =>\n                            setTimeout(\n                                // eslint-disable-next-line ie11/no-loop-func\n                                () =>\n                                    reject(new Error(\"grpc deadline exceeded\")),\n                                /** @type {number=} */ (this._grpcDeadline)\n                            )\n                        )\n                    );\n                }\n                Logger.trace(\n                    `[${this._getLogId()}] sending protobuf ${hex.encode(\n                        this._requestToBytes(request)\n                    )}`\n                );\n                promises.push(this._execute(channel, request));\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                response = /** @type {ResponseT} */ (\n                    await Promise.race(promises)\n                );\n            } catch (err) {\n                // If we received a grpc status error we need to determine if\n                // we should retry on this error, or err from the request entirely.\n                const error = GrpcServiceError._fromResponse(\n                    /** @type {Error} */ (err)\n                );\n\n                // Save the error in case we retry\n                persistentError = error;\n                Logger.debug(\n                    `[${logId}] received gRPC error ${JSON.stringify(error)}`\n                );\n\n                if (\n                    error instanceof GrpcServiceError &&\n                    this._shouldRetryExceptionally(error) &&\n                    attempt <= maxAttempts\n                ) {\n                    // Increase the backoff for the particular node and remove it from\n                    // the healthy node list\n                    client._network.increaseBackoff(node);\n                    continue;\n                }\n\n                throw err;\n            }\n\n            Logger.trace(\n                `[${this._getLogId()}] sending protobuf ${hex.encode(\n                    this._responseToBytes(response)\n                )}`\n            );\n\n            // If we didn't receive an error we should decrease the current nodes backoff\n            // in case it is a recovering node\n            client._network.decreaseBackoff(node);\n\n            // Determine what execution state we're in by the response\n            // For transactions this would be as simple as checking the response status is `OK`\n            // while for _most_ queries it would check if the response status is `SUCCESS`\n            // The only odd balls are `TransactionReceiptQuery` and `TransactionRecordQuery`\n            const [err, shouldRetry] = this._shouldRetry(request, response);\n            if (err != null) {\n                persistentError = err;\n            }\n\n            // Determine by the executing state what we should do\n            switch (shouldRetry) {\n                case ExecutionState.Retry:\n                    await delayForAttempt(\n                        attempt,\n                        this._minBackoff,\n                        this._maxBackoff\n                    );\n                    continue;\n                case ExecutionState.Finished:\n                    return this._mapResponse(response, nodeAccountId, request);\n                case ExecutionState.Error:\n                    throw this._mapStatusError(request, response);\n                default:\n                    throw new Error(\n                        \"(BUG) non-exhuastive switch statement for `ExecutionState`\"\n                    );\n            }\n        }\n\n        // We'll only get here if we've run out of attempts, so we return an error wrapping the\n        // persistent error we saved before.\n        throw new Error(\n            `max attempts of ${maxAttempts.toString()} was reached for request with last error being: ${\n                persistentError != null ? persistentError.toString() : \"\"\n            }`\n        );\n    }\n\n    /**\n     * The current purpose of this method is to easily support signature providers since\n     * signature providers need to serialize _any_ request into bytes. `Query` and `Transaction`\n     * already implement `toBytes()` so it only made sense to make it avaiable here too.\n     *\n     * @abstract\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        throw new Error(\"not implemented\");\n    }\n}\n\n/**\n * A simple function that returns a promise timeout for a specific period of time\n *\n * @param {number} attempt\n * @param {number} minBackoff\n * @param {number} maxBackoff\n * @returns {Promise<void>}\n */\nfunction delayForAttempt(attempt, minBackoff, maxBackoff) {\n    // 0.1s, 0.2s, 0.4s, 0.8s, ...\n    const ms = Math.min(\n        Math.floor(minBackoff * Math.pow(2, attempt)),\n        maxBackoff\n    );\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\n"]},"metadata":{},"sourceType":"module"}