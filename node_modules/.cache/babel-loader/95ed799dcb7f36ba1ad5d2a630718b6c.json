{"ast":null,"code":"/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\nimport TransactionId from \"../transaction/TransactionId.js\";\nimport SubscriptionHandle from \"./SubscriptionHandle.js\";\nimport TopicMessage from \"./TopicMessage.js\";\nimport * as HashgraphProto from \"@hashgraph/proto\";\nimport TopicId from \"./TopicId.js\";\nimport Long from \"long\";\nimport Timestamp from \"../Timestamp.js\";\nimport { RST_STREAM } from \"../Executable.js\";\nimport Logger from \"js-logger\";\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../channel/MirrorChannel.js\").default} MirrorChannel\n * @typedef {import(\"../channel/MirrorChannel.js\").MirrorError} MirrorError\n */\n\n/**\n * @template {Channel} ChannelT\n * @typedef {import(\"../client/Client.js\").default<ChannelT, MirrorChannel>} Client<ChannelT, MirrorChannel>\n */\n\nexport default class TopicMessageQuery {\n  /**\n   * @param {object} props\n   * @param {TopicId | string} [props.topicId]\n   * @param {Timestamp} [props.startTime]\n   * @param {Timestamp} [props.endTime]\n   * @param {(message: TopicMessage, error: Error)=> void} [props.errorHandler]\n   * @param {() => void} [props.completionHandler]\n   * @param {(error: MirrorError | Error | null) => boolean} [props.retryHandler]\n   * @param {Long | number} [props.limit]\n   */\n  constructor() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    /**\n     * @private\n     * @type {?TopicId}\n     */\n    this._topicId = null;\n\n    if (props.topicId != null) {\n      this.setTopicId(props.topicId);\n    }\n    /**\n     * @private\n     * @type {?Timestamp}\n     */\n\n\n    this._startTime = null;\n\n    if (props.startTime != null) {\n      this.setStartTime(props.startTime);\n    }\n    /**\n     * @private\n     * @type {?Timestamp}\n     */\n\n\n    this._endTime = null;\n\n    if (props.endTime != null) {\n      this.setEndTime(props.endTime);\n    }\n    /**\n     * @private\n     * @type {?Long}\n     */\n\n\n    this._limit = null;\n\n    if (props.limit != null) {\n      this.setLimit(props.limit);\n    }\n    /**\n     * @private\n     * @type {(message: TopicMessage, error: Error) => void}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n    this._errorHandler = (message, error) => {\n      console.error(`Error attempting to subscribe to topic: ${this._topicId != null ? this._topicId.toString() : \"\"}`);\n    };\n\n    if (props.errorHandler != null) {\n      this._errorHandler = props.errorHandler;\n    }\n    /*\n     * @private\n     * @type {((message: TopicMessage) => void) | null}\n     */\n\n\n    this._listener = null;\n    /**\n     * @private\n     * @type {() => void}\n     */\n\n    this._completionHandler = () => {\n      Logger.log(`Subscription to topic ${this._topicId != null ? this._topicId.toString() : \"\"} complete`);\n    };\n\n    if (props.completionHandler != null) {\n      this._completionHandler = props.completionHandler;\n    }\n    /**\n     * @private\n     * @type {(error: MirrorError | Error | null) => boolean}\n     */\n\n\n    this._retryHandler = error => {\n      if (error != null) {\n        if (error instanceof Error) {\n          // Retry on all errors which are not `MirrorError` because they're\n          // likely lower level HTTP/2 errors\n          return true;\n        } else {\n          // Retry on `NOT_FOUND`, `RESOURCE_EXHAUSTED`, `UNAVAILABLE`, and conditionally on `INTERNAL`\n          // if the message matches the right regex.\n          switch (error.code) {\n            // INTERNAL\n            // eslint-disable-next-line no-fallthrough\n            case 13:\n              return RST_STREAM.test(error.details.toString());\n            // NOT_FOUND\n            // eslint-disable-next-line no-fallthrough\n\n            case 5: // RESOURCE_EXHAUSTED\n            // eslint-disable-next-line no-fallthrough\n\n            case 8: // UNAVAILABLE\n            // eslint-disable-next-line no-fallthrough\n\n            case 14:\n              return true;\n\n            default:\n              return false;\n          }\n        }\n      }\n\n      return false;\n    };\n\n    if (props.retryHandler != null) {\n      this._retryHandler = props.retryHandler;\n    }\n    /**\n     * @private\n     * @type {number}\n     */\n\n\n    this._maxAttempts = 10;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this._maxBackoff = 8000;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this._attempt = 0;\n    /**\n     * @private\n     * @type {SubscriptionHandle | null}\n     */\n\n    this._handle = null;\n  }\n  /**\n   * @returns {?TopicId}\n   */\n\n\n  get topicId() {\n    return this._topicId;\n  }\n  /**\n   * @param {TopicId | string} topicId\n   * @returns {TopicMessageQuery}\n   */\n\n\n  setTopicId(topicId) {\n    this.requireNotSubscribed();\n    this._topicId = typeof topicId === \"string\" ? TopicId.fromString(topicId) : topicId.clone();\n    return this;\n  }\n  /**\n   * @returns {?Timestamp}\n   */\n\n\n  get startTime() {\n    return this._startTime;\n  }\n  /**\n   * @param {Timestamp | Date | number} startTime\n   * @returns {TopicMessageQuery}\n   */\n\n\n  setStartTime(startTime) {\n    this.requireNotSubscribed();\n    this._startTime = startTime instanceof Timestamp ? startTime : startTime instanceof Date ? Timestamp.fromDate(startTime) : new Timestamp(startTime, 0);\n    return this;\n  }\n  /**\n   * @returns {?Timestamp}\n   */\n\n\n  get endTime() {\n    return this._endTime;\n  }\n  /**\n   * @param {Timestamp | Date | number} endTime\n   * @returns {TopicMessageQuery}\n   */\n\n\n  setEndTime(endTime) {\n    this.requireNotSubscribed();\n    this._endTime = endTime instanceof Timestamp ? endTime : endTime instanceof Date ? Timestamp.fromDate(endTime) : new Timestamp(endTime, 0);\n    return this;\n  }\n  /**\n   * @returns {?Long}\n   */\n\n\n  get limit() {\n    return this._limit;\n  }\n  /**\n   * @param {Long | number} limit\n   * @returns {TopicMessageQuery}\n   */\n\n\n  setLimit(limit) {\n    this.requireNotSubscribed();\n    this._limit = limit instanceof Long ? limit : Long.fromValue(limit);\n    return this;\n  }\n  /**\n   * @param {(message: TopicMessage, error: Error)=> void} errorHandler\n   * @returns {TopicMessageQuery}\n   */\n\n\n  setErrorHandler(errorHandler) {\n    this._errorHandler = errorHandler;\n    return this;\n  }\n  /**\n   * @param {() => void} completionHandler\n   * @returns {TopicMessageQuery}\n   */\n\n\n  setCompletionHandler(completionHandler) {\n    this.requireNotSubscribed();\n    this._completionHandler = completionHandler;\n    return this;\n  }\n  /**\n   * @param {number} attempts\n   */\n\n\n  setMaxAttempts(attempts) {\n    this.requireNotSubscribed();\n    this._maxAttempts = attempts;\n  }\n  /**\n   * @param {number} backoff\n   */\n\n\n  setMaxBackoff(backoff) {\n    this.requireNotSubscribed();\n    this._maxBackoff = backoff;\n  }\n  /**\n   * @param {Client<Channel>} client\n   * @param {((message: TopicMessage, error: Error) => void) | null} errorHandler\n   * @param {(message: TopicMessage) => void} listener\n   * @returns {SubscriptionHandle}\n   */\n\n\n  subscribe(client, errorHandler, listener) {\n    this._handle = new SubscriptionHandle();\n    this._listener = listener;\n\n    if (errorHandler != null) {\n      this._errorHandler = errorHandler;\n    }\n\n    this._makeServerStreamRequest(client);\n\n    return this._handle;\n  }\n  /**\n   * @private\n   * @param {Client<Channel>} client\n   * @returns {void}\n   */\n\n\n  _makeServerStreamRequest(client) {\n    /** @type {Map<string, HashgraphProto.com.hedera.mirror.api.proto.ConsensusTopicResponse[]>} */\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const list = new Map();\n    const request = HashgraphProto.com.hedera.mirror.api.proto.ConsensusTopicQuery.encode({\n      topicID: this._topicId != null ? this._topicId._toProtobuf() : null,\n      consensusStartTime: this._startTime != null ? this._startTime._toProtobuf() : null,\n      consensusEndTime: this._endTime != null ? this._endTime._toProtobuf() : null,\n      limit: this._limit\n    }).finish();\n\n    const cancel = client._mirrorNetwork.getNextMirrorNode().getChannel().makeServerStreamRequest(\"ConsensusService\", \"subscribeTopic\", request, data => {\n      const message = HashgraphProto.com.hedera.mirror.api.proto.ConsensusTopicResponse.decode(data);\n\n      if (this._limit != null && this._limit.gt(0)) {\n        this._limit = this._limit.sub(1);\n      }\n\n      this._startTime = Timestamp._fromProtobuf(\n      /** @type {HashgraphProto.proto.ITimestamp} */\n      message.consensusTimestamp).plusNanos(1);\n\n      if (message.chunkInfo == null || message.chunkInfo != null && message.chunkInfo.total === 1) {\n        this._passTopicMessage(TopicMessage._ofSingle(message));\n      } else {\n        const chunkInfo =\n        /** @type {HashgraphProto.proto.IConsensusMessageChunkInfo} */\n        message.chunkInfo;\n        const initialTransactionID =\n        /** @type {HashgraphProto.proto.ITransactionID} */\n        chunkInfo.initialTransactionID;\n        const total =\n        /** @type {number} */\n        chunkInfo.total;\n\n        const transactionId = TransactionId._fromProtobuf(initialTransactionID).toString();\n        /** @type {HashgraphProto.com.hedera.mirror.api.proto.ConsensusTopicResponse[]} */\n\n\n        let responses = [];\n        const temp = list.get(transactionId);\n\n        if (temp == null) {\n          list.set(transactionId, responses);\n        } else {\n          responses = temp;\n        }\n\n        responses.push(message);\n\n        if (responses.length === total) {\n          const topicMessage = TopicMessage._ofMany(responses);\n\n          list.delete(transactionId);\n\n          this._passTopicMessage(topicMessage);\n        }\n      }\n    }, error => {\n      const message = error instanceof Error ? error.message : error.details;\n\n      if (this._attempt < this._maxAttempts && this._retryHandler(error)) {\n        const delay = Math.min(250 * 2 ** this._attempt, this._maxBackoff);\n        console.warn(`Error subscribing to topic ${this._topicId != null ? this._topicId.toString() : \"UNKNOWN\"} during attempt ${this._attempt}. Waiting ${delay} ms before next attempt: ${message}`);\n        this._attempt += 1;\n        setTimeout(() => {\n          this._makeServerStreamRequest(client);\n        }, delay);\n      }\n    }, this._completionHandler);\n\n    if (this._handle != null) {\n      this._handle._setCall(() => cancel());\n    }\n  }\n\n  requireNotSubscribed() {\n    if (this._handle != null) {\n      throw new Error(\"Cannot change fields on an already subscribed query\");\n    }\n  }\n  /**\n   * @private\n   * @param {TopicMessage} topicMessage\n   */\n\n\n  _passTopicMessage(topicMessage) {\n    try {\n      if (this._listener != null) {\n        this._listener(topicMessage);\n      } else {\n        throw new Error(\"(BUG) listener is unexpectedly not set\");\n      }\n    } catch (error) {\n      this._errorHandler(topicMessage,\n      /** @type {Error} */\n      error);\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/hbar-shop/hbar-shopify-coupon-client/node_modules/@hashgraph/sdk/src/topic/TopicMessageQuery.js"],"names":["TransactionId","SubscriptionHandle","TopicMessage","HashgraphProto","TopicId","Long","Timestamp","RST_STREAM","Logger","TopicMessageQuery","constructor","props","_topicId","topicId","setTopicId","_startTime","startTime","setStartTime","_endTime","endTime","setEndTime","_limit","limit","setLimit","_errorHandler","message","error","console","toString","errorHandler","_listener","_completionHandler","log","completionHandler","_retryHandler","Error","code","test","details","retryHandler","_maxAttempts","_maxBackoff","_attempt","_handle","requireNotSubscribed","fromString","clone","Date","fromDate","fromValue","setErrorHandler","setCompletionHandler","setMaxAttempts","attempts","setMaxBackoff","backoff","subscribe","client","listener","_makeServerStreamRequest","list","Map","request","com","hedera","mirror","api","proto","ConsensusTopicQuery","encode","topicID","_toProtobuf","consensusStartTime","consensusEndTime","finish","cancel","_mirrorNetwork","getNextMirrorNode","getChannel","makeServerStreamRequest","data","ConsensusTopicResponse","decode","gt","sub","_fromProtobuf","consensusTimestamp","plusNanos","chunkInfo","total","_passTopicMessage","_ofSingle","initialTransactionID","transactionId","responses","temp","get","set","push","length","topicMessage","_ofMany","delete","delay","Math","min","warn","setTimeout","_setCall"],"mappings":"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","sourcesContent":["/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\n\nimport TransactionId from \"../transaction/TransactionId.js\";\nimport SubscriptionHandle from \"./SubscriptionHandle.js\";\nimport TopicMessage from \"./TopicMessage.js\";\nimport * as HashgraphProto from \"@hashgraph/proto\";\nimport TopicId from \"./TopicId.js\";\nimport Long from \"long\";\nimport Timestamp from \"../Timestamp.js\";\nimport { RST_STREAM } from \"../Executable.js\";\nimport Logger from \"js-logger\";\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../channel/MirrorChannel.js\").default} MirrorChannel\n * @typedef {import(\"../channel/MirrorChannel.js\").MirrorError} MirrorError\n */\n\n/**\n * @template {Channel} ChannelT\n * @typedef {import(\"../client/Client.js\").default<ChannelT, MirrorChannel>} Client<ChannelT, MirrorChannel>\n */\n\nexport default class TopicMessageQuery {\n    /**\n     * @param {object} props\n     * @param {TopicId | string} [props.topicId]\n     * @param {Timestamp} [props.startTime]\n     * @param {Timestamp} [props.endTime]\n     * @param {(message: TopicMessage, error: Error)=> void} [props.errorHandler]\n     * @param {() => void} [props.completionHandler]\n     * @param {(error: MirrorError | Error | null) => boolean} [props.retryHandler]\n     * @param {Long | number} [props.limit]\n     */\n    constructor(props = {}) {\n        /**\n         * @private\n         * @type {?TopicId}\n         */\n        this._topicId = null;\n        if (props.topicId != null) {\n            this.setTopicId(props.topicId);\n        }\n\n        /**\n         * @private\n         * @type {?Timestamp}\n         */\n        this._startTime = null;\n        if (props.startTime != null) {\n            this.setStartTime(props.startTime);\n        }\n\n        /**\n         * @private\n         * @type {?Timestamp}\n         */\n        this._endTime = null;\n        if (props.endTime != null) {\n            this.setEndTime(props.endTime);\n        }\n\n        /**\n         * @private\n         * @type {?Long}\n         */\n        this._limit = null;\n        if (props.limit != null) {\n            this.setLimit(props.limit);\n        }\n\n        /**\n         * @private\n         * @type {(message: TopicMessage, error: Error) => void}\n         */\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        this._errorHandler = (message, error) => {\n            console.error(\n                `Error attempting to subscribe to topic: ${\n                    this._topicId != null ? this._topicId.toString() : \"\"\n                }`\n            );\n        };\n\n        if (props.errorHandler != null) {\n            this._errorHandler = props.errorHandler;\n        }\n\n        /*\n         * @private\n         * @type {((message: TopicMessage) => void) | null}\n         */\n        this._listener = null;\n\n        /**\n         * @private\n         * @type {() => void}\n         */\n        this._completionHandler = () => {\n            Logger.log(\n                `Subscription to topic ${\n                    this._topicId != null ? this._topicId.toString() : \"\"\n                } complete`\n            );\n        };\n\n        if (props.completionHandler != null) {\n            this._completionHandler = props.completionHandler;\n        }\n\n        /**\n         * @private\n         * @type {(error: MirrorError | Error | null) => boolean}\n         */\n        this._retryHandler = (error) => {\n            if (error != null) {\n                if (error instanceof Error) {\n                    // Retry on all errors which are not `MirrorError` because they're\n                    // likely lower level HTTP/2 errors\n                    return true;\n                } else {\n                    // Retry on `NOT_FOUND`, `RESOURCE_EXHAUSTED`, `UNAVAILABLE`, and conditionally on `INTERNAL`\n                    // if the message matches the right regex.\n                    switch (error.code) {\n                        // INTERNAL\n                        // eslint-disable-next-line no-fallthrough\n                        case 13:\n                            return RST_STREAM.test(error.details.toString());\n                        // NOT_FOUND\n                        // eslint-disable-next-line no-fallthrough\n                        case 5:\n                        // RESOURCE_EXHAUSTED\n                        // eslint-disable-next-line no-fallthrough\n                        case 8:\n                        // UNAVAILABLE\n                        // eslint-disable-next-line no-fallthrough\n                        case 14:\n                            return true;\n                        default:\n                            return false;\n                    }\n                }\n            }\n\n            return false;\n        };\n\n        if (props.retryHandler != null) {\n            this._retryHandler = props.retryHandler;\n        }\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._maxAttempts = 10;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._maxBackoff = 8000;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._attempt = 0;\n\n        /**\n         * @private\n         * @type {SubscriptionHandle | null}\n         */\n        this._handle = null;\n    }\n\n    /**\n     * @returns {?TopicId}\n     */\n    get topicId() {\n        return this._topicId;\n    }\n\n    /**\n     * @param {TopicId | string} topicId\n     * @returns {TopicMessageQuery}\n     */\n    setTopicId(topicId) {\n        this.requireNotSubscribed();\n\n        this._topicId =\n            typeof topicId === \"string\"\n                ? TopicId.fromString(topicId)\n                : topicId.clone();\n\n        return this;\n    }\n\n    /**\n     * @returns {?Timestamp}\n     */\n    get startTime() {\n        return this._startTime;\n    }\n\n    /**\n     * @param {Timestamp | Date | number} startTime\n     * @returns {TopicMessageQuery}\n     */\n    setStartTime(startTime) {\n        this.requireNotSubscribed();\n\n        this._startTime =\n            startTime instanceof Timestamp\n                ? startTime\n                : startTime instanceof Date\n                ? Timestamp.fromDate(startTime)\n                : new Timestamp(startTime, 0);\n        return this;\n    }\n\n    /**\n     * @returns {?Timestamp}\n     */\n    get endTime() {\n        return this._endTime;\n    }\n\n    /**\n     * @param {Timestamp | Date | number} endTime\n     * @returns {TopicMessageQuery}\n     */\n    setEndTime(endTime) {\n        this.requireNotSubscribed();\n\n        this._endTime =\n            endTime instanceof Timestamp\n                ? endTime\n                : endTime instanceof Date\n                ? Timestamp.fromDate(endTime)\n                : new Timestamp(endTime, 0);\n        return this;\n    }\n\n    /**\n     * @returns {?Long}\n     */\n    get limit() {\n        return this._limit;\n    }\n\n    /**\n     * @param {Long | number} limit\n     * @returns {TopicMessageQuery}\n     */\n    setLimit(limit) {\n        this.requireNotSubscribed();\n\n        this._limit = limit instanceof Long ? limit : Long.fromValue(limit);\n\n        return this;\n    }\n\n    /**\n     * @param {(message: TopicMessage, error: Error)=> void} errorHandler\n     * @returns {TopicMessageQuery}\n     */\n    setErrorHandler(errorHandler) {\n        this._errorHandler = errorHandler;\n\n        return this;\n    }\n\n    /**\n     * @param {() => void} completionHandler\n     * @returns {TopicMessageQuery}\n     */\n    setCompletionHandler(completionHandler) {\n        this.requireNotSubscribed();\n\n        this._completionHandler = completionHandler;\n\n        return this;\n    }\n\n    /**\n     * @param {number} attempts\n     */\n    setMaxAttempts(attempts) {\n        this.requireNotSubscribed();\n\n        this._maxAttempts = attempts;\n    }\n\n    /**\n     * @param {number} backoff\n     */\n    setMaxBackoff(backoff) {\n        this.requireNotSubscribed();\n\n        this._maxBackoff = backoff;\n    }\n\n    /**\n     * @param {Client<Channel>} client\n     * @param {((message: TopicMessage, error: Error) => void) | null} errorHandler\n     * @param {(message: TopicMessage) => void} listener\n     * @returns {SubscriptionHandle}\n     */\n    subscribe(client, errorHandler, listener) {\n        this._handle = new SubscriptionHandle();\n        this._listener = listener;\n\n        if (errorHandler != null) {\n            this._errorHandler = errorHandler;\n        }\n\n        this._makeServerStreamRequest(client);\n\n        return this._handle;\n    }\n\n    /**\n     * @private\n     * @param {Client<Channel>} client\n     * @returns {void}\n     */\n    _makeServerStreamRequest(client) {\n        /** @type {Map<string, HashgraphProto.com.hedera.mirror.api.proto.ConsensusTopicResponse[]>} */\n\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const list = new Map();\n\n        const request =\n            HashgraphProto.com.hedera.mirror.api.proto.ConsensusTopicQuery.encode(\n                {\n                    topicID:\n                        this._topicId != null\n                            ? this._topicId._toProtobuf()\n                            : null,\n                    consensusStartTime:\n                        this._startTime != null\n                            ? this._startTime._toProtobuf()\n                            : null,\n                    consensusEndTime:\n                        this._endTime != null\n                            ? this._endTime._toProtobuf()\n                            : null,\n                    limit: this._limit,\n                }\n            ).finish();\n\n        const cancel = client._mirrorNetwork\n            .getNextMirrorNode()\n            .getChannel()\n            .makeServerStreamRequest(\n                \"ConsensusService\",\n                \"subscribeTopic\",\n                request,\n                (data) => {\n                    const message =\n                        HashgraphProto.com.hedera.mirror.api.proto.ConsensusTopicResponse.decode(\n                            data\n                        );\n\n                    if (this._limit != null && this._limit.gt(0)) {\n                        this._limit = this._limit.sub(1);\n                    }\n\n                    this._startTime = Timestamp._fromProtobuf(\n                        /** @type {HashgraphProto.proto.ITimestamp} */ (\n                            message.consensusTimestamp\n                        )\n                    ).plusNanos(1);\n\n                    if (\n                        message.chunkInfo == null ||\n                        (message.chunkInfo != null &&\n                            message.chunkInfo.total === 1)\n                    ) {\n                        this._passTopicMessage(TopicMessage._ofSingle(message));\n                    } else {\n                        const chunkInfo =\n                            /** @type {HashgraphProto.proto.IConsensusMessageChunkInfo} */ (\n                                message.chunkInfo\n                            );\n                        const initialTransactionID =\n                            /** @type {HashgraphProto.proto.ITransactionID} */ (\n                                chunkInfo.initialTransactionID\n                            );\n                        const total = /** @type {number} */ (chunkInfo.total);\n                        const transactionId =\n                            TransactionId._fromProtobuf(\n                                initialTransactionID\n                            ).toString();\n\n                        /** @type {HashgraphProto.com.hedera.mirror.api.proto.ConsensusTopicResponse[]} */\n                        let responses = [];\n\n                        const temp = list.get(transactionId);\n                        if (temp == null) {\n                            list.set(transactionId, responses);\n                        } else {\n                            responses = temp;\n                        }\n\n                        responses.push(message);\n\n                        if (responses.length === total) {\n                            const topicMessage =\n                                TopicMessage._ofMany(responses);\n\n                            list.delete(transactionId);\n\n                            this._passTopicMessage(topicMessage);\n                        }\n                    }\n                },\n                (error) => {\n                    const message =\n                        error instanceof Error ? error.message : error.details;\n\n                    if (\n                        this._attempt < this._maxAttempts &&\n                        this._retryHandler(error)\n                    ) {\n                        const delay = Math.min(\n                            250 * 2 ** this._attempt,\n                            this._maxBackoff\n                        );\n                        console.warn(\n                            `Error subscribing to topic ${\n                                this._topicId != null\n                                    ? this._topicId.toString()\n                                    : \"UNKNOWN\"\n                            } during attempt ${\n                                this._attempt\n                            }. Waiting ${delay} ms before next attempt: ${message}`\n                        );\n\n                        this._attempt += 1;\n\n                        setTimeout(() => {\n                            this._makeServerStreamRequest(client);\n                        }, delay);\n                    }\n                },\n                this._completionHandler\n            );\n\n        if (this._handle != null) {\n            this._handle._setCall(() => cancel());\n        }\n    }\n\n    requireNotSubscribed() {\n        if (this._handle != null) {\n            throw new Error(\n                \"Cannot change fields on an already subscribed query\"\n            );\n        }\n    }\n\n    /**\n     * @private\n     * @param {TopicMessage} topicMessage\n     */\n    _passTopicMessage(topicMessage) {\n        try {\n            if (this._listener != null) {\n                this._listener(topicMessage);\n            } else {\n                throw new Error(\"(BUG) listener is unexpectedly not set\");\n            }\n        } catch (error) {\n            this._errorHandler(topicMessage, /** @type {Error} */ (error));\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}