{"ast":null,"code":"/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\nimport * as cryptography from \"@hashgraph/cryptography\";\nimport CACHE from \"./Cache.js\";\n/**\n * @typedef {import(\"./PrivateKey.js\").default} PrivateKey\n */\n\n/**\n * Multi-word mnemonic phrase (BIP-39).\n *\n * Compatible with the official Hedera mobile\n * wallets (24-words or 22-words) and BRD (12-words).\n */\n\nexport default class Mnemonic {\n  /**\n   * @param {cryptography.Mnemonic} mnemonic\n   * @hideconstructor\n   * @private\n   */\n  constructor(mnemonic) {\n    this._mnemonic = mnemonic;\n  }\n  /**\n   * Returns a new random 24-word mnemonic from the BIP-39\n   * standard English word list.\n   *\n   * @returns {Promise<Mnemonic>}\n   */\n\n\n  static async generate() {\n    return new Mnemonic(await cryptography.Mnemonic._generate(24));\n  }\n  /**\n   * Returns a new random 12-word mnemonic from the BIP-39\n   * standard English word list.\n   *\n   * @returns {Promise<Mnemonic>}\n   */\n\n\n  static async generate12() {\n    return new Mnemonic(await cryptography.Mnemonic._generate(12));\n  }\n  /**\n   * Construct a mnemonic from a list of words. Handles 12, 22 (legacy), and 24 words.\n   *\n   * An exception of BadMnemonicError will be thrown if the mnemonic\n   * contains unknown words or fails the checksum. An invalid mnemonic\n   * can still be used to create private keys, the exception will\n   * contain the failing mnemonic in case you wish to ignore the\n   * validation error and continue.\n   *\n   * @param {string[]} words\n   * @throws {BadMnemonicError}\n   * @returns {Promise<Mnemonic>}\n   */\n\n\n  static async fromWords(words) {\n    return new Mnemonic(await cryptography.Mnemonic.fromWords(words));\n  }\n  /**\n   * @deprecated - Use `toEd25519PrivateKey()` or `toEcdsaPrivateKey()` instead\n   * Recover a private key from this mnemonic phrase, with an\n   * optional passphrase.\n   * @param {string} [passphrase]\n   * @returns {Promise<PrivateKey>}\n   */\n\n\n  async toPrivateKey() {\n    let passphrase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return CACHE.privateKeyConstructor( // eslint-disable-next-line deprecation/deprecation\n    await this._mnemonic.toPrivateKey(passphrase));\n  }\n  /**\n   * Recover an Ed25519 private key from this mnemonic phrase, with an\n   * optional passphrase.\n   *\n   * @param {string} [passphrase]\n   * @param {number[]} [path]\n   * @returns {Promise<PrivateKey>}\n   */\n\n\n  async toEd25519PrivateKey() {\n    let passphrase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    let path = arguments.length > 1 ? arguments[1] : undefined;\n    return CACHE.privateKeyConstructor(await this._mnemonic.toEd25519PrivateKey(passphrase, path));\n  }\n  /**\n   * Recover an ECDSA private key from this mnemonic phrase, with an\n   * optional passphrase.\n   *\n   * @param {string} [passphrase]\n   * @param {number[]} [path]\n   * @returns {Promise<PrivateKey>}\n   */\n\n\n  async toEcdsaPrivateKey() {\n    let passphrase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    let path = arguments.length > 1 ? arguments[1] : undefined;\n    return CACHE.privateKeyConstructor(await this._mnemonic.toEcdsaPrivateKey(passphrase, path));\n  }\n  /**\n   * Recover a mnemonic phrase from a string, splitting on spaces. Handles 12, 22 (legacy), and 24 words.\n   *\n   * @param {string} mnemonic\n   * @returns {Promise<Mnemonic>}\n   */\n\n\n  static async fromString(mnemonic) {\n    return new Mnemonic(await cryptography.Mnemonic.fromString(mnemonic));\n  }\n  /**\n   * @returns {Promise<PrivateKey>}\n   */\n\n\n  async toLegacyPrivateKey() {\n    return CACHE.privateKeyConstructor(await this._mnemonic.toLegacyPrivateKey());\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  toString() {\n    return this._mnemonic.toString();\n  }\n\n}","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/hbar-shop/hbar-shopify-coupon-client/node_modules/@hashgraph/sdk/src/Mnemonic.js"],"names":["cryptography","CACHE","Mnemonic","constructor","mnemonic","_mnemonic","generate","_generate","generate12","fromWords","words","toPrivateKey","passphrase","privateKeyConstructor","toEd25519PrivateKey","path","toEcdsaPrivateKey","fromString","toLegacyPrivateKey","toString"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,OAAO,KAAKA,YAAZ,MAA8B,yBAA9B;AACA,OAAOC,KAAP,MAAkB,YAAlB;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,QAAN,CAAe;AAC1B;AACJ;AACA;AACA;AACA;AACIC,EAAAA,WAAW,CAACC,QAAD,EAAW;AAClB,SAAKC,SAAL,GAAiBD,QAAjB;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACyB,eAARE,QAAQ,GAAG;AACpB,WAAO,IAAIJ,QAAJ,CAAa,MAAMF,YAAY,CAACE,QAAb,CAAsBK,SAAtB,CAAgC,EAAhC,CAAnB,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AAC2B,eAAVC,UAAU,GAAG;AACtB,WAAO,IAAIN,QAAJ,CAAa,MAAMF,YAAY,CAACE,QAAb,CAAsBK,SAAtB,CAAgC,EAAhC,CAAnB,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAC0B,eAATE,SAAS,CAACC,KAAD,EAAQ;AAC1B,WAAO,IAAIR,QAAJ,CAAa,MAAMF,YAAY,CAACE,QAAb,CAAsBO,SAAtB,CAAgCC,KAAhC,CAAnB,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACsB,QAAZC,YAAY,GAAkB;AAAA,QAAjBC,UAAiB,uEAAJ,EAAI;AAChC,WAAOX,KAAK,CAACY,qBAAN,EACH;AACA,UAAM,KAAKR,SAAL,CAAeM,YAAf,CAA4BC,UAA5B,CAFH,CAAP;AAIH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AAC6B,QAAnBE,mBAAmB,GAAwB;AAAA,QAAvBF,UAAuB,uEAAV,EAAU;AAAA,QAANG,IAAM;AAC7C,WAAOd,KAAK,CAACY,qBAAN,CACH,MAAM,KAAKR,SAAL,CAAeS,mBAAf,CAAmCF,UAAnC,EAA+CG,IAA/C,CADH,CAAP;AAGH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AAC2B,QAAjBC,iBAAiB,GAAwB;AAAA,QAAvBJ,UAAuB,uEAAV,EAAU;AAAA,QAANG,IAAM;AAC3C,WAAOd,KAAK,CAACY,qBAAN,CACH,MAAM,KAAKR,SAAL,CAAeW,iBAAf,CAAiCJ,UAAjC,EAA6CG,IAA7C,CADH,CAAP;AAGH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AAC2B,eAAVE,UAAU,CAACb,QAAD,EAAW;AAC9B,WAAO,IAAIF,QAAJ,CAAa,MAAMF,YAAY,CAACE,QAAb,CAAsBe,UAAtB,CAAiCb,QAAjC,CAAnB,CAAP;AACH;AAED;AACJ;AACA;;;AAC4B,QAAlBc,kBAAkB,GAAG;AACvB,WAAOjB,KAAK,CAACY,qBAAN,CACH,MAAM,KAAKR,SAAL,CAAea,kBAAf,EADH,CAAP;AAGH;AAED;AACJ;AACA;;;AACIC,EAAAA,QAAQ,GAAG;AACP,WAAO,KAAKd,SAAL,CAAec,QAAf,EAAP;AACH;;AAjHyB","sourcesContent":["/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\n\nimport * as cryptography from \"@hashgraph/cryptography\";\nimport CACHE from \"./Cache.js\";\n\n/**\n * @typedef {import(\"./PrivateKey.js\").default} PrivateKey\n */\n\n/**\n * Multi-word mnemonic phrase (BIP-39).\n *\n * Compatible with the official Hedera mobile\n * wallets (24-words or 22-words) and BRD (12-words).\n */\nexport default class Mnemonic {\n    /**\n     * @param {cryptography.Mnemonic} mnemonic\n     * @hideconstructor\n     * @private\n     */\n    constructor(mnemonic) {\n        this._mnemonic = mnemonic;\n    }\n\n    /**\n     * Returns a new random 24-word mnemonic from the BIP-39\n     * standard English word list.\n     *\n     * @returns {Promise<Mnemonic>}\n     */\n    static async generate() {\n        return new Mnemonic(await cryptography.Mnemonic._generate(24));\n    }\n\n    /**\n     * Returns a new random 12-word mnemonic from the BIP-39\n     * standard English word list.\n     *\n     * @returns {Promise<Mnemonic>}\n     */\n    static async generate12() {\n        return new Mnemonic(await cryptography.Mnemonic._generate(12));\n    }\n\n    /**\n     * Construct a mnemonic from a list of words. Handles 12, 22 (legacy), and 24 words.\n     *\n     * An exception of BadMnemonicError will be thrown if the mnemonic\n     * contains unknown words or fails the checksum. An invalid mnemonic\n     * can still be used to create private keys, the exception will\n     * contain the failing mnemonic in case you wish to ignore the\n     * validation error and continue.\n     *\n     * @param {string[]} words\n     * @throws {BadMnemonicError}\n     * @returns {Promise<Mnemonic>}\n     */\n    static async fromWords(words) {\n        return new Mnemonic(await cryptography.Mnemonic.fromWords(words));\n    }\n\n    /**\n     * @deprecated - Use `toEd25519PrivateKey()` or `toEcdsaPrivateKey()` instead\n     * Recover a private key from this mnemonic phrase, with an\n     * optional passphrase.\n     * @param {string} [passphrase]\n     * @returns {Promise<PrivateKey>}\n     */\n    async toPrivateKey(passphrase = \"\") {\n        return CACHE.privateKeyConstructor(\n            // eslint-disable-next-line deprecation/deprecation\n            await this._mnemonic.toPrivateKey(passphrase)\n        );\n    }\n\n    /**\n     * Recover an Ed25519 private key from this mnemonic phrase, with an\n     * optional passphrase.\n     *\n     * @param {string} [passphrase]\n     * @param {number[]} [path]\n     * @returns {Promise<PrivateKey>}\n     */\n    async toEd25519PrivateKey(passphrase = \"\", path) {\n        return CACHE.privateKeyConstructor(\n            await this._mnemonic.toEd25519PrivateKey(passphrase, path)\n        );\n    }\n\n    /**\n     * Recover an ECDSA private key from this mnemonic phrase, with an\n     * optional passphrase.\n     *\n     * @param {string} [passphrase]\n     * @param {number[]} [path]\n     * @returns {Promise<PrivateKey>}\n     */\n    async toEcdsaPrivateKey(passphrase = \"\", path) {\n        return CACHE.privateKeyConstructor(\n            await this._mnemonic.toEcdsaPrivateKey(passphrase, path)\n        );\n    }\n\n    /**\n     * Recover a mnemonic phrase from a string, splitting on spaces. Handles 12, 22 (legacy), and 24 words.\n     *\n     * @param {string} mnemonic\n     * @returns {Promise<Mnemonic>}\n     */\n    static async fromString(mnemonic) {\n        return new Mnemonic(await cryptography.Mnemonic.fromString(mnemonic));\n    }\n\n    /**\n     * @returns {Promise<PrivateKey>}\n     */\n    async toLegacyPrivateKey() {\n        return CACHE.privateKeyConstructor(\n            await this._mnemonic.toLegacyPrivateKey()\n        );\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return this._mnemonic.toString();\n    }\n}\n"]},"metadata":{},"sourceType":"module"}