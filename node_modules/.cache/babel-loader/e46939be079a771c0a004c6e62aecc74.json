{"ast":null,"code":"/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\nimport AccountId from \"../account/AccountId.js\";\nimport Node from \"../Node.js\";\nimport { PREVIEWNET_ADDRESS_BOOK, TESTNET_ADDRESS_BOOK, MAINNET_ADDRESS_BOOK } from \"../address_book/AddressBooks.js\";\nimport ManagedNetwork from \"./ManagedNetwork.js\";\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../address_book/NodeAddressBook.js\").default} NodeAddressBook\n */\n\n/**\n * @augments {ManagedNetwork<Channel, Node, AccountId>}\n */\n\nexport default class Network extends ManagedNetwork {\n  /**\n   * @param {(address: string) => Channel} createNetworkChannel\n   */\n  constructor(createNetworkChannel) {\n    super(createNetworkChannel);\n    this._maxNodesPerTransaction = -1;\n    /** @type {NodeAddressBook | null} */\n\n    this._addressBook = null;\n  }\n  /**\n   * @param {{[key: string]: (string | AccountId)}} network\n   */\n\n\n  setNetwork(network) {\n    this._setNetwork( // eslint-disable-next-line ie11/no-collection-args\n    new Map( // eslint-disable-next-line ie11/no-collection-args\n    Object.entries(network).map(_ref => {\n      let [key, value] = _ref;\n      return [key, typeof value === \"string\" ? AccountId.fromString(value) : value];\n    })));\n  }\n  /**\n   * @param {NodeAddressBook} addressBook\n   * @returns {this}\n   */\n\n\n  setNetworkFromAddressBook(addressBook) {\n    /** @type {Record<string, AccountId>} */\n    const network = {};\n    const port = this.isTransportSecurity() ? 50212 : 50211;\n\n    for (const nodeAddress of addressBook.nodeAddresses) {\n      for (const endpoint of nodeAddress.addresses) {\n        // TODO: We hard code ports too much, should fix\n        if (endpoint.port === port && nodeAddress.accountId != null) {\n          network[endpoint.toString()] = nodeAddress.accountId;\n        }\n      }\n    }\n\n    this.setNetwork(network);\n    return this;\n  }\n  /**\n   * @returns {{[key: string]: (string | AccountId)}}\n   */\n\n\n  get network() {\n    /**\n     * @type {{[key: string]: (string | AccountId)}}\n     */\n    var n = {}; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n    for (const node of this._nodes) {\n      n[node.address.toString()] = node.accountId;\n    }\n\n    return n;\n  }\n  /**\n   * @param {string} networkName\n   * @returns {this}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  setNetworkName(networkName) {\n    super.setLedgerId(networkName);\n\n    switch (networkName) {\n      case \"mainnet\":\n        this._addressBook = MAINNET_ADDRESS_BOOK;\n        break;\n\n      case \"testnet\":\n        this._addressBook = TESTNET_ADDRESS_BOOK;\n        break;\n\n      case \"previewnet\":\n        this._addressBook = PREVIEWNET_ADDRESS_BOOK;\n        break;\n    }\n\n    if (this._addressBook != null) {\n      for (const node of this._nodes) {\n        for (const address of this._addressBook.nodeAddresses) {\n          if (address.accountId != null && address.accountId.toString() === node.accountId.toString()) {\n            node.setNodeAddress(address);\n          }\n        }\n      }\n    }\n\n    return this;\n  }\n  /**\n   * @returns {string | null}\n   */\n\n\n  get networkName() {\n    return this._ledgerId != null ? this._ledgerId.toString() : null;\n  }\n  /**\n   * @abstract\n   * @param {[string, (string | AccountId)]} entry\n   * @returns {Node}\n   */\n\n\n  _createNodeFromNetworkEntry(entry) {\n    const accountId = typeof entry[1] === \"string\" ? AccountId.fromString(entry[1]) : entry[1];\n    return new Node({\n      newNode: {\n        address: entry[0],\n        accountId,\n        channelInitFunction: this._createNetworkChannel\n      }\n    }).setMinBackoff(this._minBackoff);\n  }\n  /**\n   * @abstract\n   * @param {Map<string, AccountId>} network\n   * @returns {number[]}\n   */\n\n\n  _getNodesToRemove(network) {\n    const indexes = [];\n\n    for (let i = this._nodes.length - 1; i >= 0; i--) {\n      const node = this._nodes[i];\n      const accountId = network.get(node.address.toString());\n\n      if (accountId == null || accountId.toString() !== node.accountId.toString()) {\n        indexes.push(i);\n      }\n    }\n\n    return indexes;\n  }\n  /**\n   * @abstract\n   * @param {[string, (string | AccountId)]} entry\n   * @returns {boolean}\n   */\n\n\n  _checkNetworkContainsEntry(entry) {\n    for (const node of this._nodes) {\n      if (node.address.toString() === entry[0]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * @returns {number}\n   */\n\n\n  get maxNodesPerTransaction() {\n    return this._maxNodesPerTransaction;\n  }\n  /**\n   * @param {number} maxNodesPerTransaction\n   * @returns {this}\n   */\n\n\n  setMaxNodesPerTransaction(maxNodesPerTransaction) {\n    this._maxNodesPerTransaction = maxNodesPerTransaction;\n    return this;\n  }\n  /**\n   * @returns {number}\n   */\n\n\n  get maxNodeAttempts() {\n    return this._maxNodeAttempts;\n  }\n  /**\n   * @param {number} maxNodeAttempts\n   * @returns {this}\n   */\n\n\n  setMaxNodeAttempts(maxNodeAttempts) {\n    this._maxNodeAttempts = maxNodeAttempts;\n    return this;\n  }\n  /**\n   * @internal\n   * @returns {number}\n   */\n\n\n  getNumberOfNodesForTransaction() {\n    if (this._maxNodesPerTransaction > 0) {\n      return this._maxNodesPerTransaction;\n    }\n\n    return (this._nodes.length + 3 - 1) / 3;\n  }\n  /**\n   * @internal\n   * @returns {AccountId[]}\n   */\n\n\n  getNodeAccountIdsForExecute() {\n    return this._getNumberOfMostHealthyNodes(this.getNumberOfNodesForTransaction()).map(node => node.accountId);\n  }\n\n}","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/hbar-shop/hbar-shopify-coupon-client/node_modules/@hashgraph/sdk/src/client/Network.js"],"names":["AccountId","Node","PREVIEWNET_ADDRESS_BOOK","TESTNET_ADDRESS_BOOK","MAINNET_ADDRESS_BOOK","ManagedNetwork","Network","constructor","createNetworkChannel","_maxNodesPerTransaction","_addressBook","setNetwork","network","_setNetwork","Map","Object","entries","map","key","value","fromString","setNetworkFromAddressBook","addressBook","port","isTransportSecurity","nodeAddress","nodeAddresses","endpoint","addresses","accountId","toString","n","node","_nodes","address","setNetworkName","networkName","setLedgerId","setNodeAddress","_ledgerId","_createNodeFromNetworkEntry","entry","newNode","channelInitFunction","_createNetworkChannel","setMinBackoff","_minBackoff","_getNodesToRemove","indexes","i","length","get","push","_checkNetworkContainsEntry","maxNodesPerTransaction","setMaxNodesPerTransaction","maxNodeAttempts","_maxNodeAttempts","setMaxNodeAttempts","getNumberOfNodesForTransaction","getNodeAccountIdsForExecute","_getNumberOfMostHealthyNodes"],"mappings":"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","sourcesContent":["/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\n\nimport AccountId from \"../account/AccountId.js\";\nimport Node from \"../Node.js\";\nimport {\n    PREVIEWNET_ADDRESS_BOOK,\n    TESTNET_ADDRESS_BOOK,\n    MAINNET_ADDRESS_BOOK,\n} from \"../address_book/AddressBooks.js\";\nimport ManagedNetwork from \"./ManagedNetwork.js\";\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../address_book/NodeAddressBook.js\").default} NodeAddressBook\n */\n\n/**\n * @augments {ManagedNetwork<Channel, Node, AccountId>}\n */\nexport default class Network extends ManagedNetwork {\n    /**\n     * @param {(address: string) => Channel} createNetworkChannel\n     */\n    constructor(createNetworkChannel) {\n        super(createNetworkChannel);\n\n        this._maxNodesPerTransaction = -1;\n\n        /** @type {NodeAddressBook | null} */\n        this._addressBook = null;\n    }\n\n    /**\n     * @param {{[key: string]: (string | AccountId)}} network\n     */\n    setNetwork(network) {\n        this._setNetwork(\n            // eslint-disable-next-line ie11/no-collection-args\n            new Map(\n                // eslint-disable-next-line ie11/no-collection-args\n                Object.entries(network).map(([key, value]) => {\n                    return [\n                        key,\n                        typeof value === \"string\"\n                            ? AccountId.fromString(value)\n                            : value,\n                    ];\n                })\n            )\n        );\n    }\n\n    /**\n     * @param {NodeAddressBook} addressBook\n     * @returns {this}\n     */\n    setNetworkFromAddressBook(addressBook) {\n        /** @type {Record<string, AccountId>} */\n        const network = {};\n        const port = this.isTransportSecurity() ? 50212 : 50211;\n\n        for (const nodeAddress of addressBook.nodeAddresses) {\n            for (const endpoint of nodeAddress.addresses) {\n                // TODO: We hard code ports too much, should fix\n                if (endpoint.port === port && nodeAddress.accountId != null) {\n                    network[endpoint.toString()] = nodeAddress.accountId;\n                }\n            }\n        }\n\n        this.setNetwork(network);\n        return this;\n    }\n\n    /**\n     * @returns {{[key: string]: (string | AccountId)}}\n     */\n    get network() {\n        /**\n         * @type {{[key: string]: (string | AccountId)}}\n         */\n        var n = {};\n\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        for (const node of this._nodes) {\n            n[node.address.toString()] = node.accountId;\n        }\n\n        return n;\n    }\n\n    /**\n     * @param {string} networkName\n     * @returns {this}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    setNetworkName(networkName) {\n        super.setLedgerId(networkName);\n\n        switch (networkName) {\n            case \"mainnet\":\n                this._addressBook = MAINNET_ADDRESS_BOOK;\n                break;\n            case \"testnet\":\n                this._addressBook = TESTNET_ADDRESS_BOOK;\n                break;\n            case \"previewnet\":\n                this._addressBook = PREVIEWNET_ADDRESS_BOOK;\n                break;\n        }\n\n        if (this._addressBook != null) {\n            for (const node of this._nodes) {\n                for (const address of this._addressBook.nodeAddresses) {\n                    if (\n                        address.accountId != null &&\n                        address.accountId.toString() ===\n                            node.accountId.toString()\n                    ) {\n                        node.setNodeAddress(address);\n                    }\n                }\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * @returns {string | null}\n     */\n    get networkName() {\n        return this._ledgerId != null ? this._ledgerId.toString() : null;\n    }\n\n    /**\n     * @abstract\n     * @param {[string, (string | AccountId)]} entry\n     * @returns {Node}\n     */\n    _createNodeFromNetworkEntry(entry) {\n        const accountId =\n            typeof entry[1] === \"string\"\n                ? AccountId.fromString(entry[1])\n                : entry[1];\n\n        return new Node({\n            newNode: {\n                address: entry[0],\n                accountId,\n                channelInitFunction: this._createNetworkChannel,\n            },\n        }).setMinBackoff(this._minBackoff);\n    }\n\n    /**\n     * @abstract\n     * @param {Map<string, AccountId>} network\n     * @returns {number[]}\n     */\n    _getNodesToRemove(network) {\n        const indexes = [];\n\n        for (let i = this._nodes.length - 1; i >= 0; i--) {\n            const node = this._nodes[i];\n            const accountId = network.get(node.address.toString());\n\n            if (\n                accountId == null ||\n                accountId.toString() !== node.accountId.toString()\n            ) {\n                indexes.push(i);\n            }\n        }\n\n        return indexes;\n    }\n\n    /**\n     * @abstract\n     * @param {[string, (string | AccountId)]} entry\n     * @returns {boolean}\n     */\n    _checkNetworkContainsEntry(entry) {\n        for (const node of this._nodes) {\n            if (node.address.toString() === entry[0]) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get maxNodesPerTransaction() {\n        return this._maxNodesPerTransaction;\n    }\n\n    /**\n     * @param {number} maxNodesPerTransaction\n     * @returns {this}\n     */\n    setMaxNodesPerTransaction(maxNodesPerTransaction) {\n        this._maxNodesPerTransaction = maxNodesPerTransaction;\n        return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get maxNodeAttempts() {\n        return this._maxNodeAttempts;\n    }\n\n    /**\n     * @param {number} maxNodeAttempts\n     * @returns {this}\n     */\n    setMaxNodeAttempts(maxNodeAttempts) {\n        this._maxNodeAttempts = maxNodeAttempts;\n        return this;\n    }\n\n    /**\n     * @internal\n     * @returns {number}\n     */\n    getNumberOfNodesForTransaction() {\n        if (this._maxNodesPerTransaction > 0) {\n            return this._maxNodesPerTransaction;\n        }\n\n        return (this._nodes.length + 3 - 1) / 3;\n    }\n\n    /**\n     * @internal\n     * @returns {AccountId[]}\n     */\n    getNodeAccountIdsForExecute() {\n        return this._getNumberOfMostHealthyNodes(\n            this.getNumberOfNodesForTransaction()\n        ).map((node) => node.accountId);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}