{"ast":null,"code":"/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\nimport Hbar from \"../Hbar.js\";\nimport TokenId from \"../token/TokenId.js\";\nimport AccountId from \"./AccountId.js\";\nimport Transaction, { TRANSACTION_REGISTRY } from \"../transaction/Transaction.js\";\nimport Long from \"long\";\nimport NullableTokenDecimalMap from \"./NullableTokenDecimalMap.js\";\nimport Transfer from \"../Transfer.js\";\nimport TokenTransfer from \"../token/TokenTransfer.js\";\nimport TokenTransferMap from \"./TokenTransferMap.js\";\nimport HbarTransferMap from \"./HbarTransferMap.js\";\nimport TokenNftTransferMap from \"./TokenNftTransferMap.js\";\nimport TokenTransferAccountMap from \"./TokenTransferAccountMap.js\";\nimport TokenNftTransfer from \"../token/TokenNftTransfer.js\";\nimport NftId from \"../token/NftId.js\";\n/**\n * @typedef {import(\"../long.js\").LongObject} LongObject\n * @typedef {import(\"bignumber.js\").default} BigNumber\n */\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").proto.ITransaction} HashgraphProto.proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").proto.ISignedTransaction} HashgraphProto.proto.ISignedTransaction\n * @typedef {import(\"@hashgraph/proto\").proto.TransactionBody} HashgraphProto.proto.TransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionBody} HashgraphProto.proto.ITransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionResponse} HashgraphProto.proto.ITransactionResponse\n * @typedef {import(\"@hashgraph/proto\").proto.ICryptoTransferTransactionBody} HashgraphProto.proto.ICryptoTransferTransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITokenID} HashgraphProto.proto.ITokenID\n * @typedef {import(\"@hashgraph/proto\").proto.IAccountID} HashgraphProto.proto.IAccountID\n * @typedef {import(\"@hashgraph/proto\").proto.IAccountAmount} HashgraphProto.proto.IAccountAmount\n * @typedef {import(\"@hashgraph/proto\").proto.ITokenTransferList} HashgraphProto.proto.ITokenTransferList\n */\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../client/Client.js\").default<*, *>} Client\n * @typedef {import(\"../transaction/TransactionId.js\").default} TransactionId\n */\n\n/**\n * @typedef {object} TransferTokensInput\n * @property {TokenId | string} tokenId\n * @property {AccountId | string} accountId\n * @property {Long | number} amount\n */\n\n/**\n * @typedef {object} TransferTokenObject\n * @property {TokenId} tokenId\n * @property {AccountId} accountId\n * @property {Long} amount\n */\n\n/**\n * @typedef {object} TransferHbarInput\n * @property {AccountId | string} accountId\n * @property {number | string | Long | BigNumber | Hbar} amount\n */\n\n/**\n * @typedef {object} TransferNftInput\n * @property {TokenId | string} tokenId\n * @property {AccountId | string} sender\n * @property {AccountId | string} recipient\n * @property {Long | number} serial\n */\n\n/**\n * Transfers a new Hedera™ crypto-currency token.\n */\n\nexport default class TransferTransaction extends Transaction {\n  /**\n   * @param {object} [props]\n   * @param {(TransferTokensInput)[]} [props.tokenTransfers]\n   * @param {(TransferHbarInput)[]} [props.hbarTransfers]\n   * @param {(TransferNftInput)[]} [props.nftTransfers]\n   */\n  constructor() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    /**\n     * @private\n     * @type {TokenTransfer[]}\n     */\n\n    this._tokenTransfers = [];\n    /**\n     * @private\n     * @type {Transfer[]}\n     */\n\n    this._hbarTransfers = [];\n    /**\n     * @private\n     * @type {TokenNftTransfer[]}\n     */\n\n    this._nftTransfers = [];\n    this._defaultMaxTransactionFee = new Hbar(1);\n\n    for (const transfer of props.tokenTransfers != null ? props.tokenTransfers : []) {\n      this.addTokenTransfer(transfer.tokenId, transfer.accountId, transfer.amount);\n    }\n\n    for (const transfer of props.hbarTransfers != null ? props.hbarTransfers : []) {\n      this.addHbarTransfer(transfer.accountId, transfer.amount);\n    }\n\n    for (const transfer of props.nftTransfers != null ? props.nftTransfers : []) {\n      this.addNftTransfer(transfer.tokenId, transfer.serial, transfer.sender, transfer.recipient);\n    }\n  }\n  /**\n   * @internal\n   * @param {HashgraphProto.proto.ITransaction[]} transactions\n   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions\n   * @param {TransactionId[]} transactionIds\n   * @param {AccountId[]} nodeIds\n   * @param {HashgraphProto.proto.ITransactionBody[]} bodies\n   * @returns {TransferTransaction}\n   */\n\n\n  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {\n    const body = bodies[0];\n    const cryptoTransfer =\n    /** @type {HashgraphProto.proto.ICryptoTransferTransactionBody} */\n    body.cryptoTransfer;\n    const transfers = new TransferTransaction();\n    transfers._tokenTransfers = TokenTransfer._fromProtobuf(cryptoTransfer.tokenTransfers != null ? cryptoTransfer.tokenTransfers : []);\n    transfers._hbarTransfers = Transfer._fromProtobuf(cryptoTransfer.transfers != null ? cryptoTransfer.transfers.accountAmounts != null ? cryptoTransfer.transfers.accountAmounts : [] : []);\n    transfers._nftTransfers = TokenNftTransfer._fromProtobuf(cryptoTransfer.tokenTransfers != null ? cryptoTransfer.tokenTransfers : []);\n    return Transaction._fromProtobufTransactions(transfers, transactions, signedTransactions, transactionIds, nodeIds, bodies);\n  }\n  /**\n   * @returns {TokenTransferMap}\n   */\n\n\n  get tokenTransfers() {\n    const map = new TokenTransferMap();\n\n    for (const transfer of this._tokenTransfers) {\n      let transferMap = map.get(transfer.tokenId);\n\n      if (transferMap != null) {\n        transferMap._set(transfer.accountId, transfer.amount);\n      } else {\n        transferMap = new TokenTransferAccountMap();\n\n        transferMap._set(transfer.accountId, transfer.amount);\n\n        map._set(transfer.tokenId, transferMap);\n      }\n    }\n\n    return map;\n  }\n  /**\n   * @param {TokenId | string} tokenId\n   * @param {AccountId | string} accountId\n   * @param {number | Long} amount\n   * @param {boolean} isApproved\n   * @returns {this}\n   */\n\n\n  _addTokenTransfer(tokenId, accountId, amount, isApproved) {\n    this._requireNotFrozen();\n\n    const token = tokenId instanceof TokenId ? tokenId : TokenId.fromString(tokenId);\n    const account = accountId instanceof AccountId ? accountId : AccountId.fromString(accountId);\n    const value = amount instanceof Long ? amount : Long.fromNumber(amount);\n\n    for (const tokenTransfer of this._tokenTransfers) {\n      if (tokenTransfer.tokenId.compare(token) === 0 && tokenTransfer.accountId.compare(account) === 0) {\n        tokenTransfer.amount = tokenTransfer.amount.add(value);\n        tokenTransfer.expectedDecimals = null;\n        return this;\n      }\n    }\n\n    this._tokenTransfers.push(new TokenTransfer({\n      tokenId,\n      accountId,\n      expectedDecimals: null,\n      amount,\n      isApproved\n    }));\n\n    return this;\n  }\n  /**\n   * @param {TokenId | string} tokenId\n   * @param {AccountId | string} accountId\n   * @param {number | Long} amount\n   * @returns {this}\n   */\n\n\n  addTokenTransfer(tokenId, accountId, amount) {\n    return this._addTokenTransfer(tokenId, accountId, amount, false);\n  }\n  /**\n   * @param {TokenId | string} tokenId\n   * @param {AccountId | string} accountId\n   * @param {number | Long} amount\n   * @returns {this}\n   */\n\n\n  addApprovedTokenTransfer(tokenId, accountId, amount) {\n    return this._addTokenTransfer(tokenId, accountId, amount, true);\n  }\n  /**\n   * @param {TokenId | string} tokenId\n   * @param {AccountId | string} accountId\n   * @param {number | Long} amount\n   * @param {number} decimals\n   * @returns {this}\n   */\n\n\n  addTokenTransferWithDecimals(tokenId, accountId, amount, decimals) {\n    this._requireNotFrozen();\n\n    const token = tokenId instanceof TokenId ? tokenId : TokenId.fromString(tokenId);\n    const account = accountId instanceof AccountId ? accountId : AccountId.fromString(accountId);\n    const value = amount instanceof Long ? amount : Long.fromNumber(amount);\n    let found = false;\n\n    for (const tokenTransfer of this._tokenTransfers) {\n      if (tokenTransfer.tokenId.compare(token) === 0) {\n        if (tokenTransfer.expectedDecimals != null && tokenTransfer.expectedDecimals !== decimals) {\n          throw new Error(\"expected decimals mis-match\");\n        } else {\n          tokenTransfer.expectedDecimals = decimals;\n        }\n\n        if (tokenTransfer.accountId.compare(account) === 0) {\n          tokenTransfer.amount = tokenTransfer.amount.add(value);\n          tokenTransfer.expectedDecimals = decimals;\n          found = true;\n        }\n      }\n    }\n\n    if (found) {\n      return this;\n    }\n\n    this._tokenTransfers.push(new TokenTransfer({\n      tokenId,\n      accountId,\n      expectedDecimals: decimals,\n      amount,\n      isApproved: false\n    }));\n\n    return this;\n  }\n  /**\n   * @returns {NullableTokenDecimalMap}\n   */\n\n\n  get tokenIdDecimals() {\n    const map = new NullableTokenDecimalMap();\n\n    for (const transfer of this._tokenTransfers) {\n      map._set(transfer.tokenId, transfer.expectedDecimals);\n    }\n\n    return map;\n  }\n  /**\n   * @returns {HbarTransferMap}\n   */\n\n\n  get hbarTransfers() {\n    const map = new HbarTransferMap();\n\n    for (const transfer of this._hbarTransfers) {\n      map._set(transfer.accountId, transfer.amount);\n    }\n\n    return map;\n  }\n  /**\n   * @internal\n   * @param {AccountId | string} accountId\n   * @param {number | string | Long | LongObject | BigNumber | Hbar} amount\n   * @param {boolean} isApproved\n   * @returns {TransferTransaction}\n   */\n\n\n  _addHbarTransfer(accountId, amount, isApproved) {\n    this._requireNotFrozen();\n\n    const account = accountId instanceof AccountId ? accountId.clone() : AccountId.fromString(accountId);\n    const hbars = amount instanceof Hbar ? amount : new Hbar(amount);\n\n    for (const transfer of this._hbarTransfers) {\n      if (transfer.accountId.compare(account) === 0) {\n        transfer.amount = Hbar.fromTinybars(transfer.amount.toTinybars().add(hbars.toTinybars()));\n        return this;\n      }\n    }\n\n    this._hbarTransfers.push(new Transfer({\n      accountId: account,\n      amount: hbars,\n      isApproved\n    }));\n\n    return this;\n  }\n  /**\n   * @internal\n   * @param {AccountId | string} accountId\n   * @param {number | string | Long | LongObject | BigNumber | Hbar} amount\n   * @returns {TransferTransaction}\n   */\n\n\n  addHbarTransfer(accountId, amount) {\n    return this._addHbarTransfer(accountId, amount, false);\n  }\n  /**\n   * @internal\n   * @param {AccountId | string} accountId\n   * @param {number | string | Long | LongObject | BigNumber | Hbar} amount\n   * @returns {TransferTransaction}\n   */\n\n\n  addApprovedHbarTransfer(accountId, amount) {\n    return this._addHbarTransfer(accountId, amount, true);\n  }\n  /**\n   * @param {Client} client\n   */\n\n\n  _validateChecksums(client) {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    for (const transfer of this._hbarTransfers) {\n      transfer.accountId.validateChecksum(client);\n    }\n\n    for (const transfer of this._tokenTransfers) {\n      transfer.tokenId.validateChecksum(client);\n      transfer.accountId.validateChecksum(client);\n    }\n\n    for (const transfer of this._nftTransfers) {\n      transfer.tokenId.validateChecksum(client);\n      transfer.senderAccountId.validateChecksum(client);\n      transfer.receiverAccountId.validateChecksum(client);\n    }\n  }\n  /**\n   * @returns {TokenNftTransferMap}\n   */\n\n\n  get nftTransfers() {\n    const map = new TokenNftTransferMap();\n\n    for (const transfer of this._nftTransfers) {\n      const transferList = map.get(transfer.tokenId);\n      const nftTransfer = {\n        sender: transfer.senderAccountId,\n        recipient: transfer.receiverAccountId,\n        serial: transfer.serialNumber,\n        isApproved: transfer.isApproved\n      };\n\n      if (transferList != null) {\n        transferList.push(nftTransfer);\n      } else {\n        map._set(transfer.tokenId, [nftTransfer]);\n      }\n    }\n\n    return map;\n  }\n  /**\n   * @param {boolean} isApproved\n   * @param {NftId | TokenId | string} tokenIdOrNftId\n   * @param {AccountId | string | Long | number} senderAccountIdOrSerialNumber\n   * @param {AccountId | string} receiverAccountIdOrSenderAccountId\n   * @param {(AccountId | string)=} receiver\n   * @returns {TransferTransaction}\n   */\n\n\n  _addNftTransfer(isApproved, tokenIdOrNftId, senderAccountIdOrSerialNumber, receiverAccountIdOrSenderAccountId, receiver) {\n    this._requireNotFrozen();\n\n    let nftId;\n    let senderAccountId;\n    let receiverAccountId;\n\n    if (tokenIdOrNftId instanceof NftId) {\n      nftId = tokenIdOrNftId;\n      senderAccountId = typeof senderAccountIdOrSerialNumber === \"string\" ? AccountId.fromString(senderAccountIdOrSerialNumber) :\n      /** @type {AccountId} */\n      senderAccountIdOrSerialNumber;\n      receiverAccountId = typeof receiverAccountIdOrSenderAccountId === \"string\" ? AccountId.fromString(receiverAccountIdOrSenderAccountId) :\n      /** @type {AccountId} */\n      receiverAccountIdOrSenderAccountId;\n    } else if (tokenIdOrNftId instanceof TokenId) {\n      nftId = new NftId(tokenIdOrNftId,\n      /** @type {Long} */\n      senderAccountIdOrSerialNumber);\n      senderAccountId = typeof receiverAccountIdOrSenderAccountId === \"string\" ? AccountId.fromString(receiverAccountIdOrSenderAccountId) :\n      /** @type {AccountId} */\n      receiverAccountIdOrSenderAccountId;\n      receiverAccountId = typeof receiver === \"string\" ? AccountId.fromString(receiver) :\n      /** @type {AccountId} */\n      receiver;\n    } else {\n      try {\n        nftId = NftId.fromString(tokenIdOrNftId);\n        senderAccountId = typeof senderAccountIdOrSerialNumber === \"string\" ? AccountId.fromString(senderAccountIdOrSerialNumber) :\n        /** @type {AccountId} */\n        senderAccountIdOrSerialNumber;\n        receiverAccountId = typeof receiverAccountIdOrSenderAccountId === \"string\" ? AccountId.fromString(receiverAccountIdOrSenderAccountId) :\n        /** @type {AccountId} */\n        receiverAccountIdOrSenderAccountId;\n      } catch (_) {\n        const tokenId = TokenId.fromString(tokenIdOrNftId);\n        nftId = new NftId(tokenId,\n        /** @type {Long} */\n        senderAccountIdOrSerialNumber);\n        senderAccountId = typeof receiverAccountIdOrSenderAccountId === \"string\" ? AccountId.fromString(receiverAccountIdOrSenderAccountId) :\n        /** @type {AccountId} */\n        receiverAccountIdOrSenderAccountId;\n        receiverAccountId = typeof receiver === \"string\" ? AccountId.fromString(receiver) :\n        /** @type {AccountId} */\n        receiver;\n      }\n    }\n\n    for (const nftTransfer of this._nftTransfers) {\n      if (nftTransfer.tokenId.compare(nftId.tokenId) === 0 && nftTransfer.serialNumber.compare(nftId.serial) === 0) {\n        nftTransfer.senderAccountId = senderAccountId;\n        nftTransfer.receiverAccountId = receiverAccountId;\n        return this;\n      }\n    }\n\n    this._nftTransfers.push(new TokenNftTransfer({\n      tokenId: nftId.tokenId,\n      serialNumber: nftId.serial,\n      senderAccountId,\n      receiverAccountId,\n      isApproved\n    }));\n\n    return this;\n  }\n  /**\n   * @param {NftId | TokenId | string} tokenIdOrNftId\n   * @param {AccountId | string | Long | number} senderAccountIdOrSerialNumber\n   * @param {AccountId | string} receiverAccountIdOrSenderAccountId\n   * @param {(AccountId | string)=} receiver\n   * @returns {TransferTransaction}\n   */\n\n\n  addNftTransfer(tokenIdOrNftId, senderAccountIdOrSerialNumber, receiverAccountIdOrSenderAccountId, receiver) {\n    return this._addNftTransfer(false, tokenIdOrNftId, senderAccountIdOrSerialNumber, receiverAccountIdOrSenderAccountId, receiver);\n  }\n  /**\n   * @param {NftId | TokenId | string} tokenIdOrNftId\n   * @param {AccountId | string | Long | number} senderAccountIdOrSerialNumber\n   * @param {AccountId | string} receiverAccountIdOrSenderAccountId\n   * @param {(AccountId | string)=} receiver\n   * @returns {TransferTransaction}\n   */\n\n\n  addApprovedNftTransfer(tokenIdOrNftId, senderAccountIdOrSerialNumber, receiverAccountIdOrSenderAccountId, receiver) {\n    return this._addNftTransfer(true, tokenIdOrNftId, senderAccountIdOrSerialNumber, receiverAccountIdOrSenderAccountId, receiver);\n  }\n  /**\n   * @deprecated - Use `addApprovedHbarTransfer()` instead\n   * @param {AccountId | string} accountId\n   * @param {boolean} isApproved\n   * @returns {TransferTransaction}\n   */\n\n\n  setHbarTransferApproval(accountId, isApproved) {\n    const account = typeof accountId === \"string\" ? AccountId.fromString(accountId) : accountId;\n\n    for (const transfer of this._hbarTransfers) {\n      if (transfer.accountId.compare(account) === 0) {\n        transfer.isApproved = isApproved;\n      }\n    }\n\n    return this;\n  }\n  /**\n   * @deprecated - Use `addApprovedTokenTransfer()` instead\n   * @param {TokenId | string} tokenId\n   * @param {AccountId | string} accountId\n   * @param {boolean} isApproved\n   * @returns {TransferTransaction}\n   */\n\n\n  setTokenTransferApproval(tokenId, accountId, isApproved) {\n    const token = typeof tokenId === \"string\" ? TokenId.fromString(tokenId) : tokenId;\n    const account = typeof accountId === \"string\" ? AccountId.fromString(accountId) : accountId;\n\n    for (const tokenTransfer of this._tokenTransfers) {\n      if (tokenTransfer.tokenId.compare(token) === 0 && tokenTransfer.accountId.compare(account) === 0) {\n        tokenTransfer.isApproved = isApproved;\n      }\n    }\n\n    return this;\n  }\n  /**\n   * @deprecated - Use `addApprovedNftTransfer()` instead\n   * @param {NftId | string} nftId\n   * @param {boolean} isApproved\n   * @returns {TransferTransaction}\n   */\n\n\n  setNftTransferApproval(nftId, isApproved) {\n    const nft = typeof nftId === \"string\" ? NftId.fromString(nftId) : nftId;\n\n    for (const transfer of this._nftTransfers) {\n      if (transfer.tokenId.compare(nft.tokenId) === 0 && transfer.serialNumber.compare(nft.serial) === 0) {\n        transfer.isApproved = isApproved;\n      }\n    }\n\n    return this;\n  }\n  /**\n   * @override\n   * @internal\n   * @param {Channel} channel\n   * @param {HashgraphProto.proto.ITransaction} request\n   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}\n   */\n\n\n  _execute(channel, request) {\n    return channel.crypto.cryptoTransfer(request);\n  }\n  /**\n   * @override\n   * @protected\n   * @returns {NonNullable<HashgraphProto.proto.TransactionBody[\"data\"]>}\n   */\n\n\n  _getTransactionDataCase() {\n    return \"cryptoTransfer\";\n  }\n  /**\n   * @override\n   * @protected\n   * @returns {HashgraphProto.proto.ICryptoTransferTransactionBody}\n   */\n\n\n  _makeTransactionData() {\n    /** @type {{tokenId: TokenId; expectedDecimals: number | null; transfers: TokenTransfer[]; nftTransfers: TokenNftTransfer[];}[]} */\n    const tokenTransferList = [];\n\n    this._tokenTransfers.sort((a, b) => {\n      const compare = a.tokenId.compare(b.tokenId);\n\n      if (compare !== 0) {\n        return compare;\n      }\n\n      return a.accountId.compare(b.accountId);\n    });\n\n    this._nftTransfers.sort((a, b) => {\n      const senderComparision = a.senderAccountId.compare(b.senderAccountId);\n\n      if (senderComparision != 0) {\n        return senderComparision;\n      }\n\n      const recipientComparision = a.receiverAccountId.compare(b.receiverAccountId);\n\n      if (recipientComparision != 0) {\n        return recipientComparision;\n      }\n\n      return a.serialNumber.compare(b.serialNumber);\n    });\n\n    let i = 0;\n    let j = 0;\n\n    while (i < this._tokenTransfers.length || j < this._nftTransfers.length) {\n      if (i < this._tokenTransfers.length && j < this._nftTransfers.length) {\n        const iTokenId = this._tokenTransfers[i].tokenId;\n        const jTokenId = this._nftTransfers[j].tokenId;\n        const last = tokenTransferList.length > 0 ? tokenTransferList[tokenTransferList.length - 1] : null;\n        const lastTokenId = last != null ? last.tokenId : null;\n\n        if (last != null && lastTokenId != null && lastTokenId.compare(iTokenId) === 0) {\n          last.transfers.push(this._tokenTransfers[i++]);\n          continue;\n        }\n\n        if (last != null && lastTokenId != null && lastTokenId.compare(jTokenId) === 0) {\n          last.nftTransfers.push(this._nftTransfers[j++]);\n          continue;\n        }\n\n        const result = iTokenId.compare(jTokenId);\n\n        if (result === 0) {\n          tokenTransferList.push({\n            tokenId: iTokenId,\n            expectedDecimals: this._tokenTransfers[i].expectedDecimals,\n            transfers: [this._tokenTransfers[i++]],\n            nftTransfers: [this._nftTransfers[j++]]\n          });\n        } else if (result < 0) {\n          tokenTransferList.push({\n            tokenId: iTokenId,\n            expectedDecimals: this._tokenTransfers[i].expectedDecimals,\n            transfers: [this._tokenTransfers[i++]],\n            nftTransfers: []\n          });\n        } else {\n          tokenTransferList.push({\n            tokenId: jTokenId,\n            expectedDecimals: null,\n            transfers: [],\n            nftTransfers: [this._nftTransfers[j++]]\n          });\n        }\n      } else if (i < this._tokenTransfers.length) {\n        const iTokenId = this._tokenTransfers[i].tokenId;\n        let last;\n\n        for (const transfer of tokenTransferList) {\n          if (transfer.tokenId.compare(iTokenId) === 0) {\n            last = transfer;\n          }\n        }\n\n        const lastTokenId = last != null ? last.tokenId : null;\n\n        if (last != null && lastTokenId != null && lastTokenId.compare(iTokenId) === 0) {\n          last.transfers.push(this._tokenTransfers[i++]);\n          continue;\n        }\n\n        tokenTransferList.push({\n          tokenId: iTokenId,\n          expectedDecimals: this._tokenTransfers[i].expectedDecimals,\n          transfers: [this._tokenTransfers[i++]],\n          nftTransfers: []\n        });\n      } else if (j < this._nftTransfers.length) {\n        const jTokenId = this._nftTransfers[j].tokenId;\n        let last;\n\n        for (const transfer of tokenTransferList) {\n          if (transfer.tokenId.compare(jTokenId) === 0) {\n            last = transfer;\n          }\n        }\n\n        const lastTokenId = last != null ? last.tokenId : null;\n\n        if (last != null && lastTokenId != null && lastTokenId.compare(jTokenId) === 0) {\n          last.nftTransfers.push(this._nftTransfers[j++]);\n          continue;\n        }\n\n        tokenTransferList.push({\n          tokenId: jTokenId,\n          expectedDecimals: null,\n          transfers: [],\n          nftTransfers: [this._nftTransfers[j++]]\n        });\n      }\n    }\n\n    this._hbarTransfers.sort((a, b) => a.accountId.compare(b.accountId));\n\n    return {\n      transfers: {\n        accountAmounts: this._hbarTransfers.map(transfer => {\n          return {\n            accountID: transfer.accountId._toProtobuf(),\n            amount: transfer.amount.toTinybars(),\n            isApproval: transfer.isApproved\n          };\n        })\n      },\n      tokenTransfers: tokenTransferList.map(tokenTransfer => {\n        return {\n          token: tokenTransfer.tokenId._toProtobuf(),\n          expectedDecimals: tokenTransfer.expectedDecimals != null ? {\n            value: tokenTransfer.expectedDecimals\n          } : null,\n          transfers: tokenTransfer.transfers.map(transfer => transfer._toProtobuf()),\n          nftTransfers: tokenTransfer.nftTransfers.map(transfer => transfer._toProtobuf())\n        };\n      })\n    };\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  _getLogId() {\n    const timestamp =\n    /** @type {import(\"../Timestamp.js\").default} */\n    this._transactionIds.current.validStart;\n    return `TransferTransaction:${timestamp.toString()}`;\n  }\n\n}\nTRANSACTION_REGISTRY.set(\"cryptoTransfer\", // eslint-disable-next-line @typescript-eslint/unbound-method\nTransferTransaction._fromProtobuf);","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/hbar-shop/hbar-shop-dashboard/node_modules/@hashgraph/sdk/src/account/TransferTransaction.js"],"names":["Hbar","TokenId","AccountId","Transaction","TRANSACTION_REGISTRY","Long","NullableTokenDecimalMap","Transfer","TokenTransfer","TokenTransferMap","HbarTransferMap","TokenNftTransferMap","TokenTransferAccountMap","TokenNftTransfer","NftId","TransferTransaction","constructor","props","_tokenTransfers","_hbarTransfers","_nftTransfers","_defaultMaxTransactionFee","transfer","tokenTransfers","addTokenTransfer","tokenId","accountId","amount","hbarTransfers","addHbarTransfer","nftTransfers","addNftTransfer","serial","sender","recipient","_fromProtobuf","transactions","signedTransactions","transactionIds","nodeIds","bodies","body","cryptoTransfer","transfers","accountAmounts","_fromProtobufTransactions","map","transferMap","get","_set","_addTokenTransfer","isApproved","_requireNotFrozen","token","fromString","account","value","fromNumber","tokenTransfer","compare","add","expectedDecimals","push","addApprovedTokenTransfer","addTokenTransferWithDecimals","decimals","found","Error","tokenIdDecimals","_addHbarTransfer","clone","hbars","fromTinybars","toTinybars","addApprovedHbarTransfer","_validateChecksums","client","validateChecksum","senderAccountId","receiverAccountId","transferList","nftTransfer","serialNumber","_addNftTransfer","tokenIdOrNftId","senderAccountIdOrSerialNumber","receiverAccountIdOrSenderAccountId","receiver","nftId","_","addApprovedNftTransfer","setHbarTransferApproval","setTokenTransferApproval","setNftTransferApproval","nft","_execute","channel","request","crypto","_getTransactionDataCase","_makeTransactionData","tokenTransferList","sort","a","b","senderComparision","recipientComparision","i","j","length","iTokenId","jTokenId","last","lastTokenId","result","accountID","_toProtobuf","isApproval","_getLogId","timestamp","_transactionIds","current","validStart","toString","set"],"mappings":"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","sourcesContent":["/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\n\nimport Hbar from \"../Hbar.js\";\nimport TokenId from \"../token/TokenId.js\";\nimport AccountId from \"./AccountId.js\";\nimport Transaction, {\n    TRANSACTION_REGISTRY,\n} from \"../transaction/Transaction.js\";\nimport Long from \"long\";\nimport NullableTokenDecimalMap from \"./NullableTokenDecimalMap.js\";\nimport Transfer from \"../Transfer.js\";\nimport TokenTransfer from \"../token/TokenTransfer.js\";\nimport TokenTransferMap from \"./TokenTransferMap.js\";\nimport HbarTransferMap from \"./HbarTransferMap.js\";\nimport TokenNftTransferMap from \"./TokenNftTransferMap.js\";\nimport TokenTransferAccountMap from \"./TokenTransferAccountMap.js\";\nimport TokenNftTransfer from \"../token/TokenNftTransfer.js\";\nimport NftId from \"../token/NftId.js\";\n\n/**\n * @typedef {import(\"../long.js\").LongObject} LongObject\n * @typedef {import(\"bignumber.js\").default} BigNumber\n */\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").proto.ITransaction} HashgraphProto.proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").proto.ISignedTransaction} HashgraphProto.proto.ISignedTransaction\n * @typedef {import(\"@hashgraph/proto\").proto.TransactionBody} HashgraphProto.proto.TransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionBody} HashgraphProto.proto.ITransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionResponse} HashgraphProto.proto.ITransactionResponse\n * @typedef {import(\"@hashgraph/proto\").proto.ICryptoTransferTransactionBody} HashgraphProto.proto.ICryptoTransferTransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITokenID} HashgraphProto.proto.ITokenID\n * @typedef {import(\"@hashgraph/proto\").proto.IAccountID} HashgraphProto.proto.IAccountID\n * @typedef {import(\"@hashgraph/proto\").proto.IAccountAmount} HashgraphProto.proto.IAccountAmount\n * @typedef {import(\"@hashgraph/proto\").proto.ITokenTransferList} HashgraphProto.proto.ITokenTransferList\n */\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../client/Client.js\").default<*, *>} Client\n * @typedef {import(\"../transaction/TransactionId.js\").default} TransactionId\n */\n\n/**\n * @typedef {object} TransferTokensInput\n * @property {TokenId | string} tokenId\n * @property {AccountId | string} accountId\n * @property {Long | number} amount\n */\n\n/**\n * @typedef {object} TransferTokenObject\n * @property {TokenId} tokenId\n * @property {AccountId} accountId\n * @property {Long} amount\n */\n\n/**\n * @typedef {object} TransferHbarInput\n * @property {AccountId | string} accountId\n * @property {number | string | Long | BigNumber | Hbar} amount\n */\n\n/**\n * @typedef {object} TransferNftInput\n * @property {TokenId | string} tokenId\n * @property {AccountId | string} sender\n * @property {AccountId | string} recipient\n * @property {Long | number} serial\n */\n\n/**\n * Transfers a new Hedera™ crypto-currency token.\n */\nexport default class TransferTransaction extends Transaction {\n    /**\n     * @param {object} [props]\n     * @param {(TransferTokensInput)[]} [props.tokenTransfers]\n     * @param {(TransferHbarInput)[]} [props.hbarTransfers]\n     * @param {(TransferNftInput)[]} [props.nftTransfers]\n     */\n    constructor(props = {}) {\n        super();\n\n        /**\n         * @private\n         * @type {TokenTransfer[]}\n         */\n        this._tokenTransfers = [];\n\n        /**\n         * @private\n         * @type {Transfer[]}\n         */\n        this._hbarTransfers = [];\n\n        /**\n         * @private\n         * @type {TokenNftTransfer[]}\n         */\n        this._nftTransfers = [];\n\n        this._defaultMaxTransactionFee = new Hbar(1);\n\n        for (const transfer of props.tokenTransfers != null\n            ? props.tokenTransfers\n            : []) {\n            this.addTokenTransfer(\n                transfer.tokenId,\n                transfer.accountId,\n                transfer.amount\n            );\n        }\n\n        for (const transfer of props.hbarTransfers != null\n            ? props.hbarTransfers\n            : []) {\n            this.addHbarTransfer(transfer.accountId, transfer.amount);\n        }\n\n        for (const transfer of props.nftTransfers != null\n            ? props.nftTransfers\n            : []) {\n            this.addNftTransfer(\n                transfer.tokenId,\n                transfer.serial,\n                transfer.sender,\n                transfer.recipient\n            );\n        }\n    }\n\n    /**\n     * @internal\n     * @param {HashgraphProto.proto.ITransaction[]} transactions\n     * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions\n     * @param {TransactionId[]} transactionIds\n     * @param {AccountId[]} nodeIds\n     * @param {HashgraphProto.proto.ITransactionBody[]} bodies\n     * @returns {TransferTransaction}\n     */\n    static _fromProtobuf(\n        transactions,\n        signedTransactions,\n        transactionIds,\n        nodeIds,\n        bodies\n    ) {\n        const body = bodies[0];\n        const cryptoTransfer =\n            /** @type {HashgraphProto.proto.ICryptoTransferTransactionBody} */ (\n                body.cryptoTransfer\n            );\n\n        const transfers = new TransferTransaction();\n\n        transfers._tokenTransfers = TokenTransfer._fromProtobuf(\n            cryptoTransfer.tokenTransfers != null\n                ? cryptoTransfer.tokenTransfers\n                : []\n        );\n\n        transfers._hbarTransfers = Transfer._fromProtobuf(\n            cryptoTransfer.transfers != null\n                ? cryptoTransfer.transfers.accountAmounts != null\n                    ? cryptoTransfer.transfers.accountAmounts\n                    : []\n                : []\n        );\n\n        transfers._nftTransfers = TokenNftTransfer._fromProtobuf(\n            cryptoTransfer.tokenTransfers != null\n                ? cryptoTransfer.tokenTransfers\n                : []\n        );\n\n        return Transaction._fromProtobufTransactions(\n            transfers,\n            transactions,\n            signedTransactions,\n            transactionIds,\n            nodeIds,\n            bodies\n        );\n    }\n\n    /**\n     * @returns {TokenTransferMap}\n     */\n    get tokenTransfers() {\n        const map = new TokenTransferMap();\n\n        for (const transfer of this._tokenTransfers) {\n            let transferMap = map.get(transfer.tokenId);\n\n            if (transferMap != null) {\n                transferMap._set(transfer.accountId, transfer.amount);\n            } else {\n                transferMap = new TokenTransferAccountMap();\n                transferMap._set(transfer.accountId, transfer.amount);\n                map._set(transfer.tokenId, transferMap);\n            }\n        }\n\n        return map;\n    }\n\n    /**\n     * @param {TokenId | string} tokenId\n     * @param {AccountId | string} accountId\n     * @param {number | Long} amount\n     * @param {boolean} isApproved\n     * @returns {this}\n     */\n    _addTokenTransfer(tokenId, accountId, amount, isApproved) {\n        this._requireNotFrozen();\n\n        const token =\n            tokenId instanceof TokenId ? tokenId : TokenId.fromString(tokenId);\n        const account =\n            accountId instanceof AccountId\n                ? accountId\n                : AccountId.fromString(accountId);\n        const value = amount instanceof Long ? amount : Long.fromNumber(amount);\n\n        for (const tokenTransfer of this._tokenTransfers) {\n            if (\n                tokenTransfer.tokenId.compare(token) === 0 &&\n                tokenTransfer.accountId.compare(account) === 0\n            ) {\n                tokenTransfer.amount = tokenTransfer.amount.add(value);\n                tokenTransfer.expectedDecimals = null;\n                return this;\n            }\n        }\n\n        this._tokenTransfers.push(\n            new TokenTransfer({\n                tokenId,\n                accountId,\n                expectedDecimals: null,\n                amount,\n                isApproved,\n            })\n        );\n\n        return this;\n    }\n\n    /**\n     * @param {TokenId | string} tokenId\n     * @param {AccountId | string} accountId\n     * @param {number | Long} amount\n     * @returns {this}\n     */\n    addTokenTransfer(tokenId, accountId, amount) {\n        return this._addTokenTransfer(tokenId, accountId, amount, false);\n    }\n\n    /**\n     * @param {TokenId | string} tokenId\n     * @param {AccountId | string} accountId\n     * @param {number | Long} amount\n     * @returns {this}\n     */\n    addApprovedTokenTransfer(tokenId, accountId, amount) {\n        return this._addTokenTransfer(tokenId, accountId, amount, true);\n    }\n\n    /**\n     * @param {TokenId | string} tokenId\n     * @param {AccountId | string} accountId\n     * @param {number | Long} amount\n     * @param {number} decimals\n     * @returns {this}\n     */\n    addTokenTransferWithDecimals(tokenId, accountId, amount, decimals) {\n        this._requireNotFrozen();\n\n        const token =\n            tokenId instanceof TokenId ? tokenId : TokenId.fromString(tokenId);\n        const account =\n            accountId instanceof AccountId\n                ? accountId\n                : AccountId.fromString(accountId);\n        const value = amount instanceof Long ? amount : Long.fromNumber(amount);\n\n        let found = false;\n\n        for (const tokenTransfer of this._tokenTransfers) {\n            if (tokenTransfer.tokenId.compare(token) === 0) {\n                if (\n                    tokenTransfer.expectedDecimals != null &&\n                    tokenTransfer.expectedDecimals !== decimals\n                ) {\n                    throw new Error(\"expected decimals mis-match\");\n                } else {\n                    tokenTransfer.expectedDecimals = decimals;\n                }\n\n                if (tokenTransfer.accountId.compare(account) === 0) {\n                    tokenTransfer.amount = tokenTransfer.amount.add(value);\n                    tokenTransfer.expectedDecimals = decimals;\n                    found = true;\n                }\n            }\n        }\n\n        if (found) {\n            return this;\n        }\n\n        this._tokenTransfers.push(\n            new TokenTransfer({\n                tokenId,\n                accountId,\n                expectedDecimals: decimals,\n                amount,\n                isApproved: false,\n            })\n        );\n\n        return this;\n    }\n\n    /**\n     * @returns {NullableTokenDecimalMap}\n     */\n    get tokenIdDecimals() {\n        const map = new NullableTokenDecimalMap();\n\n        for (const transfer of this._tokenTransfers) {\n            map._set(transfer.tokenId, transfer.expectedDecimals);\n        }\n\n        return map;\n    }\n\n    /**\n     * @returns {HbarTransferMap}\n     */\n    get hbarTransfers() {\n        const map = new HbarTransferMap();\n\n        for (const transfer of this._hbarTransfers) {\n            map._set(transfer.accountId, transfer.amount);\n        }\n\n        return map;\n    }\n\n    /**\n     * @internal\n     * @param {AccountId | string} accountId\n     * @param {number | string | Long | LongObject | BigNumber | Hbar} amount\n     * @param {boolean} isApproved\n     * @returns {TransferTransaction}\n     */\n    _addHbarTransfer(accountId, amount, isApproved) {\n        this._requireNotFrozen();\n\n        const account =\n            accountId instanceof AccountId\n                ? accountId.clone()\n                : AccountId.fromString(accountId);\n        const hbars = amount instanceof Hbar ? amount : new Hbar(amount);\n\n        for (const transfer of this._hbarTransfers) {\n            if (transfer.accountId.compare(account) === 0) {\n                transfer.amount = Hbar.fromTinybars(\n                    transfer.amount.toTinybars().add(hbars.toTinybars())\n                );\n                return this;\n            }\n        }\n\n        this._hbarTransfers.push(\n            new Transfer({\n                accountId: account,\n                amount: hbars,\n                isApproved,\n            })\n        );\n\n        return this;\n    }\n\n    /**\n     * @internal\n     * @param {AccountId | string} accountId\n     * @param {number | string | Long | LongObject | BigNumber | Hbar} amount\n     * @returns {TransferTransaction}\n     */\n    addHbarTransfer(accountId, amount) {\n        return this._addHbarTransfer(accountId, amount, false);\n    }\n\n    /**\n     * @internal\n     * @param {AccountId | string} accountId\n     * @param {number | string | Long | LongObject | BigNumber | Hbar} amount\n     * @returns {TransferTransaction}\n     */\n    addApprovedHbarTransfer(accountId, amount) {\n        return this._addHbarTransfer(accountId, amount, true);\n    }\n\n    /**\n     * @param {Client} client\n     */\n    _validateChecksums(client) {\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        for (const transfer of this._hbarTransfers) {\n            transfer.accountId.validateChecksum(client);\n        }\n\n        for (const transfer of this._tokenTransfers) {\n            transfer.tokenId.validateChecksum(client);\n            transfer.accountId.validateChecksum(client);\n        }\n\n        for (const transfer of this._nftTransfers) {\n            transfer.tokenId.validateChecksum(client);\n            transfer.senderAccountId.validateChecksum(client);\n            transfer.receiverAccountId.validateChecksum(client);\n        }\n    }\n\n    /**\n     * @returns {TokenNftTransferMap}\n     */\n    get nftTransfers() {\n        const map = new TokenNftTransferMap();\n\n        for (const transfer of this._nftTransfers) {\n            const transferList = map.get(transfer.tokenId);\n\n            const nftTransfer = {\n                sender: transfer.senderAccountId,\n                recipient: transfer.receiverAccountId,\n                serial: transfer.serialNumber,\n                isApproved: transfer.isApproved,\n            };\n\n            if (transferList != null) {\n                transferList.push(nftTransfer);\n            } else {\n                map._set(transfer.tokenId, [nftTransfer]);\n            }\n        }\n\n        return map;\n    }\n\n    /**\n     * @param {boolean} isApproved\n     * @param {NftId | TokenId | string} tokenIdOrNftId\n     * @param {AccountId | string | Long | number} senderAccountIdOrSerialNumber\n     * @param {AccountId | string} receiverAccountIdOrSenderAccountId\n     * @param {(AccountId | string)=} receiver\n     * @returns {TransferTransaction}\n     */\n    _addNftTransfer(\n        isApproved,\n        tokenIdOrNftId,\n        senderAccountIdOrSerialNumber,\n        receiverAccountIdOrSenderAccountId,\n        receiver\n    ) {\n        this._requireNotFrozen();\n\n        let nftId;\n        let senderAccountId;\n        let receiverAccountId;\n\n        if (tokenIdOrNftId instanceof NftId) {\n            nftId = tokenIdOrNftId;\n            senderAccountId =\n                typeof senderAccountIdOrSerialNumber === \"string\"\n                    ? AccountId.fromString(senderAccountIdOrSerialNumber)\n                    : /** @type {AccountId} */ (senderAccountIdOrSerialNumber);\n            receiverAccountId =\n                typeof receiverAccountIdOrSenderAccountId === \"string\"\n                    ? AccountId.fromString(receiverAccountIdOrSenderAccountId)\n                    : /** @type {AccountId} */ (\n                          receiverAccountIdOrSenderAccountId\n                      );\n        } else if (tokenIdOrNftId instanceof TokenId) {\n            nftId = new NftId(\n                tokenIdOrNftId,\n                /** @type {Long} */ (senderAccountIdOrSerialNumber)\n            );\n            senderAccountId =\n                typeof receiverAccountIdOrSenderAccountId === \"string\"\n                    ? AccountId.fromString(receiverAccountIdOrSenderAccountId)\n                    : /** @type {AccountId} */ (\n                          receiverAccountIdOrSenderAccountId\n                      );\n            receiverAccountId =\n                typeof receiver === \"string\"\n                    ? AccountId.fromString(receiver)\n                    : /** @type {AccountId} */ (receiver);\n        } else {\n            try {\n                nftId = NftId.fromString(tokenIdOrNftId);\n                senderAccountId =\n                    typeof senderAccountIdOrSerialNumber === \"string\"\n                        ? AccountId.fromString(senderAccountIdOrSerialNumber)\n                        : /** @type {AccountId} */ (\n                              senderAccountIdOrSerialNumber\n                          );\n                receiverAccountId =\n                    typeof receiverAccountIdOrSenderAccountId === \"string\"\n                        ? AccountId.fromString(\n                              receiverAccountIdOrSenderAccountId\n                          )\n                        : /** @type {AccountId} */ (\n                              receiverAccountIdOrSenderAccountId\n                          );\n            } catch (_) {\n                const tokenId = TokenId.fromString(tokenIdOrNftId);\n                nftId = new NftId(\n                    tokenId,\n                    /** @type {Long} */ (senderAccountIdOrSerialNumber)\n                );\n                senderAccountId =\n                    typeof receiverAccountIdOrSenderAccountId === \"string\"\n                        ? AccountId.fromString(\n                              receiverAccountIdOrSenderAccountId\n                          )\n                        : /** @type {AccountId} */ (\n                              receiverAccountIdOrSenderAccountId\n                          );\n                receiverAccountId =\n                    typeof receiver === \"string\"\n                        ? AccountId.fromString(receiver)\n                        : /** @type {AccountId} */ (receiver);\n            }\n        }\n\n        for (const nftTransfer of this._nftTransfers) {\n            if (\n                nftTransfer.tokenId.compare(nftId.tokenId) === 0 &&\n                nftTransfer.serialNumber.compare(nftId.serial) === 0\n            ) {\n                nftTransfer.senderAccountId = senderAccountId;\n                nftTransfer.receiverAccountId = receiverAccountId;\n                return this;\n            }\n        }\n\n        this._nftTransfers.push(\n            new TokenNftTransfer({\n                tokenId: nftId.tokenId,\n                serialNumber: nftId.serial,\n                senderAccountId,\n                receiverAccountId,\n                isApproved,\n            })\n        );\n\n        return this;\n    }\n\n    /**\n     * @param {NftId | TokenId | string} tokenIdOrNftId\n     * @param {AccountId | string | Long | number} senderAccountIdOrSerialNumber\n     * @param {AccountId | string} receiverAccountIdOrSenderAccountId\n     * @param {(AccountId | string)=} receiver\n     * @returns {TransferTransaction}\n     */\n    addNftTransfer(\n        tokenIdOrNftId,\n        senderAccountIdOrSerialNumber,\n        receiverAccountIdOrSenderAccountId,\n        receiver\n    ) {\n        return this._addNftTransfer(\n            false,\n            tokenIdOrNftId,\n            senderAccountIdOrSerialNumber,\n            receiverAccountIdOrSenderAccountId,\n            receiver\n        );\n    }\n\n    /**\n     * @param {NftId | TokenId | string} tokenIdOrNftId\n     * @param {AccountId | string | Long | number} senderAccountIdOrSerialNumber\n     * @param {AccountId | string} receiverAccountIdOrSenderAccountId\n     * @param {(AccountId | string)=} receiver\n     * @returns {TransferTransaction}\n     */\n    addApprovedNftTransfer(\n        tokenIdOrNftId,\n        senderAccountIdOrSerialNumber,\n        receiverAccountIdOrSenderAccountId,\n        receiver\n    ) {\n        return this._addNftTransfer(\n            true,\n            tokenIdOrNftId,\n            senderAccountIdOrSerialNumber,\n            receiverAccountIdOrSenderAccountId,\n            receiver\n        );\n    }\n\n    /**\n     * @deprecated - Use `addApprovedHbarTransfer()` instead\n     * @param {AccountId | string} accountId\n     * @param {boolean} isApproved\n     * @returns {TransferTransaction}\n     */\n    setHbarTransferApproval(accountId, isApproved) {\n        const account =\n            typeof accountId === \"string\"\n                ? AccountId.fromString(accountId)\n                : accountId;\n\n        for (const transfer of this._hbarTransfers) {\n            if (transfer.accountId.compare(account) === 0) {\n                transfer.isApproved = isApproved;\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * @deprecated - Use `addApprovedTokenTransfer()` instead\n     * @param {TokenId | string} tokenId\n     * @param {AccountId | string} accountId\n     * @param {boolean} isApproved\n     * @returns {TransferTransaction}\n     */\n    setTokenTransferApproval(tokenId, accountId, isApproved) {\n        const token =\n            typeof tokenId === \"string\" ? TokenId.fromString(tokenId) : tokenId;\n        const account =\n            typeof accountId === \"string\"\n                ? AccountId.fromString(accountId)\n                : accountId;\n\n        for (const tokenTransfer of this._tokenTransfers) {\n            if (\n                tokenTransfer.tokenId.compare(token) === 0 &&\n                tokenTransfer.accountId.compare(account) === 0\n            ) {\n                tokenTransfer.isApproved = isApproved;\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * @deprecated - Use `addApprovedNftTransfer()` instead\n     * @param {NftId | string} nftId\n     * @param {boolean} isApproved\n     * @returns {TransferTransaction}\n     */\n    setNftTransferApproval(nftId, isApproved) {\n        const nft = typeof nftId === \"string\" ? NftId.fromString(nftId) : nftId;\n\n        for (const transfer of this._nftTransfers) {\n            if (\n                transfer.tokenId.compare(nft.tokenId) === 0 &&\n                transfer.serialNumber.compare(nft.serial) === 0\n            ) {\n                transfer.isApproved = isApproved;\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * @override\n     * @internal\n     * @param {Channel} channel\n     * @param {HashgraphProto.proto.ITransaction} request\n     * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}\n     */\n    _execute(channel, request) {\n        return channel.crypto.cryptoTransfer(request);\n    }\n\n    /**\n     * @override\n     * @protected\n     * @returns {NonNullable<HashgraphProto.proto.TransactionBody[\"data\"]>}\n     */\n    _getTransactionDataCase() {\n        return \"cryptoTransfer\";\n    }\n\n    /**\n     * @override\n     * @protected\n     * @returns {HashgraphProto.proto.ICryptoTransferTransactionBody}\n     */\n    _makeTransactionData() {\n        /** @type {{tokenId: TokenId; expectedDecimals: number | null; transfers: TokenTransfer[]; nftTransfers: TokenNftTransfer[];}[]} */\n        const tokenTransferList = [];\n\n        this._tokenTransfers.sort((a, b) => {\n            const compare = a.tokenId.compare(b.tokenId);\n\n            if (compare !== 0) {\n                return compare;\n            }\n\n            return a.accountId.compare(b.accountId);\n        });\n\n        this._nftTransfers.sort((a, b) => {\n            const senderComparision = a.senderAccountId.compare(\n                b.senderAccountId\n            );\n            if (senderComparision != 0) {\n                return senderComparision;\n            }\n\n            const recipientComparision = a.receiverAccountId.compare(\n                b.receiverAccountId\n            );\n            if (recipientComparision != 0) {\n                return recipientComparision;\n            }\n\n            return a.serialNumber.compare(b.serialNumber);\n        });\n\n        let i = 0;\n        let j = 0;\n        while (\n            i < this._tokenTransfers.length ||\n            j < this._nftTransfers.length\n        ) {\n            if (\n                i < this._tokenTransfers.length &&\n                j < this._nftTransfers.length\n            ) {\n                const iTokenId = this._tokenTransfers[i].tokenId;\n                const jTokenId = this._nftTransfers[j].tokenId;\n\n                const last =\n                    tokenTransferList.length > 0\n                        ? tokenTransferList[tokenTransferList.length - 1]\n                        : null;\n                const lastTokenId = last != null ? last.tokenId : null;\n\n                if (\n                    last != null &&\n                    lastTokenId != null &&\n                    lastTokenId.compare(iTokenId) === 0\n                ) {\n                    last.transfers.push(this._tokenTransfers[i++]);\n                    continue;\n                }\n\n                if (\n                    last != null &&\n                    lastTokenId != null &&\n                    lastTokenId.compare(jTokenId) === 0\n                ) {\n                    last.nftTransfers.push(this._nftTransfers[j++]);\n                    continue;\n                }\n\n                const result = iTokenId.compare(jTokenId);\n\n                if (result === 0) {\n                    tokenTransferList.push({\n                        tokenId: iTokenId,\n                        expectedDecimals:\n                            this._tokenTransfers[i].expectedDecimals,\n                        transfers: [this._tokenTransfers[i++]],\n                        nftTransfers: [this._nftTransfers[j++]],\n                    });\n                } else if (result < 0) {\n                    tokenTransferList.push({\n                        tokenId: iTokenId,\n                        expectedDecimals:\n                            this._tokenTransfers[i].expectedDecimals,\n                        transfers: [this._tokenTransfers[i++]],\n                        nftTransfers: [],\n                    });\n                } else {\n                    tokenTransferList.push({\n                        tokenId: jTokenId,\n                        expectedDecimals: null,\n                        transfers: [],\n                        nftTransfers: [this._nftTransfers[j++]],\n                    });\n                }\n            } else if (i < this._tokenTransfers.length) {\n                const iTokenId = this._tokenTransfers[i].tokenId;\n\n                let last;\n                for (const transfer of tokenTransferList) {\n                    if (transfer.tokenId.compare(iTokenId) === 0) {\n                        last = transfer;\n                    }\n                }\n                const lastTokenId = last != null ? last.tokenId : null;\n\n                if (\n                    last != null &&\n                    lastTokenId != null &&\n                    lastTokenId.compare(iTokenId) === 0\n                ) {\n                    last.transfers.push(this._tokenTransfers[i++]);\n                    continue;\n                }\n\n                tokenTransferList.push({\n                    tokenId: iTokenId,\n                    expectedDecimals: this._tokenTransfers[i].expectedDecimals,\n                    transfers: [this._tokenTransfers[i++]],\n                    nftTransfers: [],\n                });\n            } else if (j < this._nftTransfers.length) {\n                const jTokenId = this._nftTransfers[j].tokenId;\n\n                let last;\n                for (const transfer of tokenTransferList) {\n                    if (transfer.tokenId.compare(jTokenId) === 0) {\n                        last = transfer;\n                    }\n                }\n                const lastTokenId = last != null ? last.tokenId : null;\n\n                if (\n                    last != null &&\n                    lastTokenId != null &&\n                    lastTokenId.compare(jTokenId) === 0\n                ) {\n                    last.nftTransfers.push(this._nftTransfers[j++]);\n                    continue;\n                }\n\n                tokenTransferList.push({\n                    tokenId: jTokenId,\n                    expectedDecimals: null,\n                    transfers: [],\n                    nftTransfers: [this._nftTransfers[j++]],\n                });\n            }\n        }\n\n        this._hbarTransfers.sort((a, b) => a.accountId.compare(b.accountId));\n\n        return {\n            transfers: {\n                accountAmounts: this._hbarTransfers.map((transfer) => {\n                    return {\n                        accountID: transfer.accountId._toProtobuf(),\n                        amount: transfer.amount.toTinybars(),\n                        isApproval: transfer.isApproved,\n                    };\n                }),\n            },\n            tokenTransfers: tokenTransferList.map((tokenTransfer) => {\n                return {\n                    token: tokenTransfer.tokenId._toProtobuf(),\n                    expectedDecimals:\n                        tokenTransfer.expectedDecimals != null\n                            ? { value: tokenTransfer.expectedDecimals }\n                            : null,\n                    transfers: tokenTransfer.transfers.map((transfer) =>\n                        transfer._toProtobuf()\n                    ),\n                    nftTransfers: tokenTransfer.nftTransfers.map((transfer) =>\n                        transfer._toProtobuf()\n                    ),\n                };\n            }),\n        };\n    }\n\n    /**\n     * @returns {string}\n     */\n    _getLogId() {\n        const timestamp = /** @type {import(\"../Timestamp.js\").default} */ (\n            this._transactionIds.current.validStart\n        );\n        return `TransferTransaction:${timestamp.toString()}`;\n    }\n}\n\nTRANSACTION_REGISTRY.set(\n    \"cryptoTransfer\",\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    TransferTransaction._fromProtobuf\n);\n"]},"metadata":{},"sourceType":"module"}