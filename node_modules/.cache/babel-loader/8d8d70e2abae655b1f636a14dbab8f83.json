{"ast":null,"code":"/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\n\n/**\n * A simple \"map\" type that allows indexing by objects other than\n * strings, numbers, or booleans, and doesn't use the object pointer.\n *\n * @abstract\n * @template {{ toString(): string }} KeyT\n * @template {any} ValueT\n */\nexport default class ObjectMap {\n  /**\n   * @param {(s: string) => KeyT} fromString\n   */\n  constructor(fromString) {\n    /**\n     * This map is from the stringified version of the key, to the value\n     *\n     * @type {Map<string, ValueT>}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    this._map = new Map();\n    /**\n     * This map is from the key, to the value\n     *\n     * @type {Map<KeyT, ValueT>}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\n    this.__map = new Map();\n    /**\n     * A function pointer to convert a key into a string. So we can set each\n     * value in both maps.\n     */\n\n    this._fromString = fromString;\n  }\n  /**\n   * Get a value by key or string.\n   *\n   * This is the main benefit of this class. If a user provides a `KeyT` we\n   * implicitly serialize it to a string and use the string version. Otherwise\n   * the user will get `undefined` even for a key that exists in the map since\n   * the `KeyT` the provided has a different pointer than the one we have stored.\n   * The string version doesn't have this issue since JS hashes the string and\n   * that would result in both `KeyT` hitting the same value even if they're\n   * different pointers.\n   *\n   * @param {KeyT | string} key\n   * @returns {?ValueT}\n   */\n\n\n  get(key) {\n    const k = typeof key === \"string\" ? key : key.toString();\n\n    const value = this._map.get(k);\n\n    return value != null ? value : null;\n  }\n  /**\n   * Set the key to a value in both maps\n   *\n   * @internal\n   * @param {KeyT} key\n   * @param {ValueT} value\n   */\n\n\n  _set(key, value) {\n    const k = typeof key === \"string\" ? key : key.toString();\n\n    this._map.set(k, value);\n\n    this.__map.set(key, value);\n  }\n  /**\n   * Create iterator of values\n   *\n   * @returns {IterableIterator<ValueT>}\n   */\n\n\n  values() {\n    return this._map.values();\n  }\n  /**\n   * Get the size of the map\n   *\n   * @returns {number}\n   */\n\n\n  get size() {\n    return this._map.size;\n  }\n  /**\n   * Get the keys of the map.\n   *\n   * @returns {IterableIterator<KeyT>}\n   */\n\n\n  keys() {\n    return this.__map.keys();\n  }\n  /**\n   * Create an iterator over key, value pairs\n   *\n   * @returns {IterableIterator<[KeyT, ValueT]>}\n   */\n\n\n  [Symbol.iterator]() {\n    return this.__map[Symbol.iterator]();\n  }\n  /**\n   * Stringify the map into _something_ readable.\n   * **NOTE**: This implementation is not stable and can change.\n   *\n   * @returns {string}\n   */\n\n\n  toString() {\n    /** @type {Object.<string, any>} */\n    const map = {};\n\n    for (const [key, value] of this._map) {\n      map[key] = value;\n    }\n\n    return JSON.stringify(map);\n  }\n\n}","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/hbar-shop/hbar-shopify-coupon-client/node_modules/@hashgraph/sdk/src/ObjectMap.js"],"names":["ObjectMap","constructor","fromString","_map","Map","__map","_fromString","get","key","k","toString","value","_set","set","values","size","keys","Symbol","iterator","map","JSON","stringify"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMA,SAAN,CAAgB;AAC3B;AACJ;AACA;AACIC,EAAAA,WAAW,CAACC,UAAD,EAAa;AACpB;AACR;AACA;AACA;AACA;AACQ;AACA,SAAKC,IAAL,GAAY,IAAIC,GAAJ,EAAZ;AAEA;AACR;AACA;AACA;AACA;AACQ;;AACA,SAAKC,KAAL,GAAa,IAAID,GAAJ,EAAb;AAEA;AACR;AACA;AACA;;AACQ,SAAKE,WAAL,GAAmBJ,UAAnB;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIK,EAAAA,GAAG,CAACC,GAAD,EAAM;AACL,UAAMC,CAAC,GAAG,OAAOD,GAAP,KAAe,QAAf,GAA0BA,GAA1B,GAAgCA,GAAG,CAACE,QAAJ,EAA1C;;AAEA,UAAMC,KAAK,GAAG,KAAKR,IAAL,CAAUI,GAAV,CAAcE,CAAd,CAAd;;AACA,WAAOE,KAAK,IAAI,IAAT,GAAgBA,KAAhB,GAAwB,IAA/B;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,IAAI,CAACJ,GAAD,EAAMG,KAAN,EAAa;AACb,UAAMF,CAAC,GAAG,OAAOD,GAAP,KAAe,QAAf,GAA0BA,GAA1B,GAAgCA,GAAG,CAACE,QAAJ,EAA1C;;AAEA,SAAKP,IAAL,CAAUU,GAAV,CAAcJ,CAAd,EAAiBE,KAAjB;;AACA,SAAKN,KAAL,CAAWQ,GAAX,CAAeL,GAAf,EAAoBG,KAApB;AACH;AAED;AACJ;AACA;AACA;AACA;;;AACIG,EAAAA,MAAM,GAAG;AACL,WAAO,KAAKX,IAAL,CAAUW,MAAV,EAAP;AACH;AAED;AACJ;AACA;AACA;AACA;;;AACY,MAAJC,IAAI,GAAG;AACP,WAAO,KAAKZ,IAAL,CAAUY,IAAjB;AACH;AAED;AACJ;AACA;AACA;AACA;;;AACIC,EAAAA,IAAI,GAAG;AACH,WAAO,KAAKX,KAAL,CAAWW,IAAX,EAAP;AACH;AAED;AACJ;AACA;AACA;AACA;;;AACoB,GAAfC,MAAM,CAACC,QAAQ,IAAI;AAChB,WAAO,KAAKb,KAAL,CAAWY,MAAM,CAACC,QAAlB,GAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACIR,EAAAA,QAAQ,GAAG;AACP;AACA,UAAMS,GAAG,GAAG,EAAZ;;AAEA,SAAK,MAAM,CAACX,GAAD,EAAMG,KAAN,CAAX,IAA2B,KAAKR,IAAhC,EAAsC;AAClCgB,MAAAA,GAAG,CAACX,GAAD,CAAH,GAAWG,KAAX;AACH;;AAED,WAAOS,IAAI,CAACC,SAAL,CAAeF,GAAf,CAAP;AACH;;AAlH0B","sourcesContent":["/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\n\n/**\n * A simple \"map\" type that allows indexing by objects other than\n * strings, numbers, or booleans, and doesn't use the object pointer.\n *\n * @abstract\n * @template {{ toString(): string }} KeyT\n * @template {any} ValueT\n */\nexport default class ObjectMap {\n    /**\n     * @param {(s: string) => KeyT} fromString\n     */\n    constructor(fromString) {\n        /**\n         * This map is from the stringified version of the key, to the value\n         *\n         * @type {Map<string, ValueT>}\n         */\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this._map = new Map();\n\n        /**\n         * This map is from the key, to the value\n         *\n         * @type {Map<KeyT, ValueT>}\n         */\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.__map = new Map();\n\n        /**\n         * A function pointer to convert a key into a string. So we can set each\n         * value in both maps.\n         */\n        this._fromString = fromString;\n    }\n\n    /**\n     * Get a value by key or string.\n     *\n     * This is the main benefit of this class. If a user provides a `KeyT` we\n     * implicitly serialize it to a string and use the string version. Otherwise\n     * the user will get `undefined` even for a key that exists in the map since\n     * the `KeyT` the provided has a different pointer than the one we have stored.\n     * The string version doesn't have this issue since JS hashes the string and\n     * that would result in both `KeyT` hitting the same value even if they're\n     * different pointers.\n     *\n     * @param {KeyT | string} key\n     * @returns {?ValueT}\n     */\n    get(key) {\n        const k = typeof key === \"string\" ? key : key.toString();\n\n        const value = this._map.get(k);\n        return value != null ? value : null;\n    }\n\n    /**\n     * Set the key to a value in both maps\n     *\n     * @internal\n     * @param {KeyT} key\n     * @param {ValueT} value\n     */\n    _set(key, value) {\n        const k = typeof key === \"string\" ? key : key.toString();\n\n        this._map.set(k, value);\n        this.__map.set(key, value);\n    }\n\n    /**\n     * Create iterator of values\n     *\n     * @returns {IterableIterator<ValueT>}\n     */\n    values() {\n        return this._map.values();\n    }\n\n    /**\n     * Get the size of the map\n     *\n     * @returns {number}\n     */\n    get size() {\n        return this._map.size;\n    }\n\n    /**\n     * Get the keys of the map.\n     *\n     * @returns {IterableIterator<KeyT>}\n     */\n    keys() {\n        return this.__map.keys();\n    }\n\n    /**\n     * Create an iterator over key, value pairs\n     *\n     * @returns {IterableIterator<[KeyT, ValueT]>}\n     */\n    [Symbol.iterator]() {\n        return this.__map[Symbol.iterator]();\n    }\n\n    /**\n     * Stringify the map into _something_ readable.\n     * **NOTE**: This implementation is not stable and can change.\n     *\n     * @returns {string}\n     */\n    toString() {\n        /** @type {Object.<string, any>} */\n        const map = {};\n\n        for (const [key, value] of this._map) {\n            map[key] = value;\n        }\n\n        return JSON.stringify(map);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}