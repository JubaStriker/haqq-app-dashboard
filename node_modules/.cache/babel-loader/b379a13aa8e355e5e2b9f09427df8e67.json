{"ast":null,"code":"/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\nimport Hbar from \"../Hbar.js\";\nimport Transaction, { TRANSACTION_REGISTRY, DEFAULT_AUTO_RENEW_PERIOD } from \"../transaction/Transaction.js\";\nimport * as utf8 from \"../encoding/utf8.js\";\nimport Timestamp from \"../Timestamp.js\";\nimport Key from \"../Key.js\";\nimport KeyList from \"../KeyList.js\";\nimport Long from \"long\";\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").proto.ITransaction} HashgraphProto.proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").proto.ISignedTransaction} HashgraphProto.proto.ISignedTransaction\n * @typedef {import(\"@hashgraph/proto\").proto.TransactionBody} HashgraphProto.proto.TransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionBody} HashgraphProto.proto.ITransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionResponse} HashgraphProto.proto.ITransactionResponse\n * @typedef {import(\"@hashgraph/proto\").proto.IFileCreateTransactionBody} HashgraphProto.proto.IFileCreateTransactionBody\n */\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../account/AccountId.js\").default} AccountId\n * @typedef {import(\"../transaction/TransactionId.js\").default} TransactionId\n */\n\n/**\n * Create a new Hedera™ crypto-currency file.\n */\n\nexport default class FileCreateTransaction extends Transaction {\n  /**\n   * @param {object} [props]\n   * @param {Key[] | KeyList} [props.keys]\n   * @param {Timestamp | Date} [props.expirationTime]\n   * @param {Uint8Array | string} [props.contents]\n   * @param {string} [props.fileMemo]\n   */\n  constructor() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    /**\n     * @private\n     * @type {?Key[]}\n     */\n\n    this._keys = null;\n    /**\n     * @private\n     * @type {Timestamp}\n     */\n\n    this._expirationTime = new Timestamp(0, 0).plusNanos(Long.fromNumber(Date.now()).mul(1000000).add(DEFAULT_AUTO_RENEW_PERIOD.mul(1000000000)));\n    /**\n     * @private\n     * @type {?Uint8Array}\n     */\n\n    this._contents = null;\n    /**\n     * @private\n     * @type {?string}\n     */\n\n    this._fileMemo = null;\n    this._defaultMaxTransactionFee = new Hbar(5);\n\n    if (props.keys != null) {\n      this.setKeys(props.keys);\n    }\n\n    if (props.expirationTime != null) {\n      this.setExpirationTime(props.expirationTime);\n    }\n\n    if (props.contents != null) {\n      this.setContents(props.contents);\n    }\n\n    if (props.fileMemo != null) {\n      this.setFileMemo(props.fileMemo);\n    }\n  }\n  /**\n   * @internal\n   * @param {HashgraphProto.proto.ITransaction[]} transactions\n   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions\n   * @param {TransactionId[]} transactionIds\n   * @param {AccountId[]} nodeIds\n   * @param {HashgraphProto.proto.ITransactionBody[]} bodies\n   * @returns {FileCreateTransaction}\n   */\n\n\n  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {\n    const body = bodies[0];\n    const create =\n    /** @type {HashgraphProto.proto.IFileCreateTransactionBody} */\n    body.fileCreate;\n    return Transaction._fromProtobufTransactions(new FileCreateTransaction({\n      keys: create.keys != null ? create.keys.keys != null ? create.keys.keys.map(key => Key._fromProtobufKey(key)) : undefined : undefined,\n      expirationTime: create.expirationTime != null ? Timestamp._fromProtobuf(create.expirationTime) : undefined,\n      contents: create.contents != null ? create.contents : undefined,\n      fileMemo: create.memo != null ? create.memo : undefined\n    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);\n  }\n  /**\n   * @returns {?Key[]}\n   */\n\n\n  get keys() {\n    return this._keys;\n  }\n  /**\n   * Set the keys which must sign any transactions modifying this file. Required.\n   *\n   * All keys must sign to modify the file's contents or keys. No key is required\n   * to sign for extending the expiration time (except the one for the operator account\n   * paying for the transaction). Only one key must sign to delete the file, however.\n   *\n   * To require more than one key to sign to delete a file, add them to a\n   * KeyList and pass that here.\n   *\n   * The network currently requires a file to have at least one key (or key list or threshold key)\n   * but this requirement may be lifted in the future.\n   *\n   * @param {Key[] | KeyList} keys\n   * @returns {this}\n   */\n\n\n  setKeys(keys) {\n    this._requireNotFrozen();\n\n    if (keys instanceof KeyList && keys.threshold != null) {\n      throw new Error(\"Cannot set threshold key as file key\");\n    }\n\n    this._keys = keys instanceof KeyList ? keys.toArray() : keys;\n    return this;\n  }\n  /**\n   * @returns {Timestamp}\n   */\n\n\n  get expirationTime() {\n    return this._expirationTime;\n  }\n  /**\n   * Set the instant at which this file will expire, after which its contents will no longer be\n   * available.\n   *\n   * Defaults to 1/4 of a Julian year from the instant FileCreateTransaction\n   * was invoked.\n   *\n   * May be extended using FileUpdateTransaction#setExpirationTime(Timestamp).\n   *\n   * @param {Timestamp | Date} expirationTime\n   * @returns {this}\n   */\n\n\n  setExpirationTime(expirationTime) {\n    this._requireNotFrozen();\n\n    this._expirationTime = expirationTime instanceof Timestamp ? expirationTime : Timestamp.fromDate(expirationTime);\n    return this;\n  }\n  /**\n   * @returns {?Uint8Array}\n   */\n\n\n  get contents() {\n    return this._contents;\n  }\n  /**\n   * Set the given byte array as the file's contents.\n   *\n   * This may be omitted to create an empty file.\n   *\n   * Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the\n   * network; if you exceed this you may receive a HederaPreCheckStatusException\n   * with Status#TransactionOversize.\n   *\n   * In this case, you will need to break the data into chunks of less than ~6KiB and execute this\n   * transaction with the first chunk and then use FileAppendTransaction with\n   * FileAppendTransaction#setContents(Uint8Array) for the remaining chunks.\n   *\n   * @param {Uint8Array | string} contents\n   * @returns {this}\n   */\n\n\n  setContents(contents) {\n    this._requireNotFrozen();\n\n    this._contents = contents instanceof Uint8Array ? contents : utf8.encode(contents);\n    return this;\n  }\n  /**\n   * @returns {?string}\n   */\n\n\n  get fileMemo() {\n    return this._fileMemo;\n  }\n  /**\n   * @param {string} memo\n   * @returns {this}\n   */\n\n\n  setFileMemo(memo) {\n    this._requireNotFrozen();\n\n    this._fileMemo = memo;\n    return this;\n  }\n  /**\n   * @override\n   * @internal\n   * @param {Channel} channel\n   * @param {HashgraphProto.proto.ITransaction} request\n   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}\n   */\n\n\n  _execute(channel, request) {\n    return channel.file.createFile(request);\n  }\n  /**\n   * @override\n   * @protected\n   * @returns {NonNullable<HashgraphProto.proto.TransactionBody[\"data\"]>}\n   */\n\n\n  _getTransactionDataCase() {\n    return \"fileCreate\";\n  }\n  /**\n   * @override\n   * @protected\n   * @returns {HashgraphProto.proto.IFileCreateTransactionBody}\n   */\n\n\n  _makeTransactionData() {\n    return {\n      keys: this._keys != null ? {\n        keys: this._keys.map(key => key._toProtobufKey())\n      } : null,\n      expirationTime: this._expirationTime._toProtobuf(),\n      contents: this._contents,\n      memo: this._fileMemo\n    };\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  _getLogId() {\n    const timestamp =\n    /** @type {import(\"../Timestamp.js\").default} */\n    this._transactionIds.current.validStart;\n    return `FileCreateTransaction:${timestamp.toString()}`;\n  }\n\n} // eslint-disable-next-line @typescript-eslint/unbound-method\n\nTRANSACTION_REGISTRY.set(\"fileCreate\", FileCreateTransaction._fromProtobuf);","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/hbar-shop/hbar-shopify-coupon-client/node_modules/@hashgraph/sdk/src/file/FileCreateTransaction.js"],"names":["Hbar","Transaction","TRANSACTION_REGISTRY","DEFAULT_AUTO_RENEW_PERIOD","utf8","Timestamp","Key","KeyList","Long","FileCreateTransaction","constructor","props","_keys","_expirationTime","plusNanos","fromNumber","Date","now","mul","add","_contents","_fileMemo","_defaultMaxTransactionFee","keys","setKeys","expirationTime","setExpirationTime","contents","setContents","fileMemo","setFileMemo","_fromProtobuf","transactions","signedTransactions","transactionIds","nodeIds","bodies","body","create","fileCreate","_fromProtobufTransactions","map","key","_fromProtobufKey","undefined","memo","_requireNotFrozen","threshold","Error","toArray","fromDate","Uint8Array","encode","_execute","channel","request","file","createFile","_getTransactionDataCase","_makeTransactionData","_toProtobufKey","_toProtobuf","_getLogId","timestamp","_transactionIds","current","validStart","toString","set"],"mappings":"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","sourcesContent":["/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\n\nimport Hbar from \"../Hbar.js\";\nimport Transaction, {\n    TRANSACTION_REGISTRY,\n    DEFAULT_AUTO_RENEW_PERIOD,\n} from \"../transaction/Transaction.js\";\nimport * as utf8 from \"../encoding/utf8.js\";\nimport Timestamp from \"../Timestamp.js\";\nimport Key from \"../Key.js\";\nimport KeyList from \"../KeyList.js\";\nimport Long from \"long\";\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").proto.ITransaction} HashgraphProto.proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").proto.ISignedTransaction} HashgraphProto.proto.ISignedTransaction\n * @typedef {import(\"@hashgraph/proto\").proto.TransactionBody} HashgraphProto.proto.TransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionBody} HashgraphProto.proto.ITransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionResponse} HashgraphProto.proto.ITransactionResponse\n * @typedef {import(\"@hashgraph/proto\").proto.IFileCreateTransactionBody} HashgraphProto.proto.IFileCreateTransactionBody\n */\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../account/AccountId.js\").default} AccountId\n * @typedef {import(\"../transaction/TransactionId.js\").default} TransactionId\n */\n\n/**\n * Create a new Hedera™ crypto-currency file.\n */\nexport default class FileCreateTransaction extends Transaction {\n    /**\n     * @param {object} [props]\n     * @param {Key[] | KeyList} [props.keys]\n     * @param {Timestamp | Date} [props.expirationTime]\n     * @param {Uint8Array | string} [props.contents]\n     * @param {string} [props.fileMemo]\n     */\n    constructor(props = {}) {\n        super();\n\n        /**\n         * @private\n         * @type {?Key[]}\n         */\n        this._keys = null;\n\n        /**\n         * @private\n         * @type {Timestamp}\n         */\n        this._expirationTime = new Timestamp(0, 0).plusNanos(\n            Long.fromNumber(Date.now())\n                .mul(1000000)\n                .add(DEFAULT_AUTO_RENEW_PERIOD.mul(1000000000))\n        );\n\n        /**\n         * @private\n         * @type {?Uint8Array}\n         */\n        this._contents = null;\n\n        /**\n         * @private\n         * @type {?string}\n         */\n        this._fileMemo = null;\n\n        this._defaultMaxTransactionFee = new Hbar(5);\n\n        if (props.keys != null) {\n            this.setKeys(props.keys);\n        }\n\n        if (props.expirationTime != null) {\n            this.setExpirationTime(props.expirationTime);\n        }\n\n        if (props.contents != null) {\n            this.setContents(props.contents);\n        }\n\n        if (props.fileMemo != null) {\n            this.setFileMemo(props.fileMemo);\n        }\n    }\n\n    /**\n     * @internal\n     * @param {HashgraphProto.proto.ITransaction[]} transactions\n     * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions\n     * @param {TransactionId[]} transactionIds\n     * @param {AccountId[]} nodeIds\n     * @param {HashgraphProto.proto.ITransactionBody[]} bodies\n     * @returns {FileCreateTransaction}\n     */\n    static _fromProtobuf(\n        transactions,\n        signedTransactions,\n        transactionIds,\n        nodeIds,\n        bodies\n    ) {\n        const body = bodies[0];\n        const create =\n            /** @type {HashgraphProto.proto.IFileCreateTransactionBody} */ (\n                body.fileCreate\n            );\n\n        return Transaction._fromProtobufTransactions(\n            new FileCreateTransaction({\n                keys:\n                    create.keys != null\n                        ? create.keys.keys != null\n                            ? create.keys.keys.map((key) =>\n                                  Key._fromProtobufKey(key)\n                              )\n                            : undefined\n                        : undefined,\n                expirationTime:\n                    create.expirationTime != null\n                        ? Timestamp._fromProtobuf(create.expirationTime)\n                        : undefined,\n                contents: create.contents != null ? create.contents : undefined,\n                fileMemo: create.memo != null ? create.memo : undefined,\n            }),\n            transactions,\n            signedTransactions,\n            transactionIds,\n            nodeIds,\n            bodies\n        );\n    }\n\n    /**\n     * @returns {?Key[]}\n     */\n    get keys() {\n        return this._keys;\n    }\n\n    /**\n     * Set the keys which must sign any transactions modifying this file. Required.\n     *\n     * All keys must sign to modify the file's contents or keys. No key is required\n     * to sign for extending the expiration time (except the one for the operator account\n     * paying for the transaction). Only one key must sign to delete the file, however.\n     *\n     * To require more than one key to sign to delete a file, add them to a\n     * KeyList and pass that here.\n     *\n     * The network currently requires a file to have at least one key (or key list or threshold key)\n     * but this requirement may be lifted in the future.\n     *\n     * @param {Key[] | KeyList} keys\n     * @returns {this}\n     */\n    setKeys(keys) {\n        this._requireNotFrozen();\n        if (keys instanceof KeyList && keys.threshold != null) {\n            throw new Error(\"Cannot set threshold key as file key\");\n        }\n\n        this._keys = keys instanceof KeyList ? keys.toArray() : keys;\n\n        return this;\n    }\n\n    /**\n     * @returns {Timestamp}\n     */\n    get expirationTime() {\n        return this._expirationTime;\n    }\n\n    /**\n     * Set the instant at which this file will expire, after which its contents will no longer be\n     * available.\n     *\n     * Defaults to 1/4 of a Julian year from the instant FileCreateTransaction\n     * was invoked.\n     *\n     * May be extended using FileUpdateTransaction#setExpirationTime(Timestamp).\n     *\n     * @param {Timestamp | Date} expirationTime\n     * @returns {this}\n     */\n    setExpirationTime(expirationTime) {\n        this._requireNotFrozen();\n        this._expirationTime =\n            expirationTime instanceof Timestamp\n                ? expirationTime\n                : Timestamp.fromDate(expirationTime);\n\n        return this;\n    }\n\n    /**\n     * @returns {?Uint8Array}\n     */\n    get contents() {\n        return this._contents;\n    }\n\n    /**\n     * Set the given byte array as the file's contents.\n     *\n     * This may be omitted to create an empty file.\n     *\n     * Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the\n     * network; if you exceed this you may receive a HederaPreCheckStatusException\n     * with Status#TransactionOversize.\n     *\n     * In this case, you will need to break the data into chunks of less than ~6KiB and execute this\n     * transaction with the first chunk and then use FileAppendTransaction with\n     * FileAppendTransaction#setContents(Uint8Array) for the remaining chunks.\n     *\n     * @param {Uint8Array | string} contents\n     * @returns {this}\n     */\n    setContents(contents) {\n        this._requireNotFrozen();\n        this._contents =\n            contents instanceof Uint8Array ? contents : utf8.encode(contents);\n\n        return this;\n    }\n\n    /**\n     * @returns {?string}\n     */\n    get fileMemo() {\n        return this._fileMemo;\n    }\n\n    /**\n     * @param {string} memo\n     * @returns {this}\n     */\n    setFileMemo(memo) {\n        this._requireNotFrozen();\n        this._fileMemo = memo;\n\n        return this;\n    }\n\n    /**\n     * @override\n     * @internal\n     * @param {Channel} channel\n     * @param {HashgraphProto.proto.ITransaction} request\n     * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}\n     */\n    _execute(channel, request) {\n        return channel.file.createFile(request);\n    }\n\n    /**\n     * @override\n     * @protected\n     * @returns {NonNullable<HashgraphProto.proto.TransactionBody[\"data\"]>}\n     */\n    _getTransactionDataCase() {\n        return \"fileCreate\";\n    }\n\n    /**\n     * @override\n     * @protected\n     * @returns {HashgraphProto.proto.IFileCreateTransactionBody}\n     */\n    _makeTransactionData() {\n        return {\n            keys:\n                this._keys != null\n                    ? {\n                          keys: this._keys.map((key) => key._toProtobufKey()),\n                      }\n                    : null,\n            expirationTime: this._expirationTime._toProtobuf(),\n            contents: this._contents,\n            memo: this._fileMemo,\n        };\n    }\n\n    /**\n     * @returns {string}\n     */\n    _getLogId() {\n        const timestamp = /** @type {import(\"../Timestamp.js\").default} */ (\n            this._transactionIds.current.validStart\n        );\n        return `FileCreateTransaction:${timestamp.toString()}`;\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/unbound-method\nTRANSACTION_REGISTRY.set(\"fileCreate\", FileCreateTransaction._fromProtobuf);\n"]},"metadata":{},"sourceType":"module"}