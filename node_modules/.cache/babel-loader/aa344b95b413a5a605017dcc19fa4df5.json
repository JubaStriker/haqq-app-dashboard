{"ast":null,"code":"import * as hmac from \"./hmac.js\";\nimport * as hex from \"../encoding/hex.js\";\nimport elliptic from \"elliptic\";\nconst secp256k1 = new elliptic.ec(\"secp256k1\");\nconst HIGHEST_BIT = 0x80000000;\n/**\n * Mostly copied from https://github.com/bitcoinjs/bip32/blob/master/ts-src/bip32.ts\n * We cannot use that library directly because it uses `Buffer` and we want to avoid\n * polyfills as much as possible. Also, we only need the `derive` function.\n *\n * @param {Uint8Array} parentKey\n * @param {Uint8Array} chainCode\n * @param {number} index\n * @returns {Promise<{ keyData: Uint8Array; chainCode: Uint8Array }>}\n */\n\nexport async function derive(parentKey, chainCode, index) {\n  const isHardened = (index & HIGHEST_BIT) !== 0;\n  const data = new Uint8Array(37);\n  const publicKey = hex.decode(secp256k1.keyFromPrivate(parentKey).getPublic(true, \"hex\")); // Hardened child\n\n  if (isHardened) {\n    // data = 0x00 || ser256(kpar) || ser32(index)\n    data[0] = 0x00;\n    data.set(parentKey, 1); // Normal child\n  } else {\n    // data = serP(point(kpar)) || ser32(index)\n    //      = serP(Kpar) || ser32(index)\n    data.set(publicKey, 0);\n  }\n\n  new DataView(data.buffer, data.byteOffset, data.byteLength).setUint32(33, index, false);\n  const I = await hmac.hash(hmac.HashAlgorithm.Sha512, chainCode, data);\n  const IL = I.subarray(0, 32);\n  const IR = I.subarray(32); // if parse256(IL) >= n, proceed with the next value for i\n\n  try {\n    // ki = parse256(IL) + kpar (mod n)\n    const ki = secp256k1.keyFromPrivate(parentKey).getPrivate().add(secp256k1.keyFromPrivate(IL).getPrivate()); // const ki = Buffer.from(ecc.privateAdd(this.privateKey!, IL)!);\n    // In case ki == 0, proceed with the next value for i\n\n    if (ki.eqn(0)) {\n      return derive(parentKey, chainCode, index + 1);\n    }\n\n    return {\n      keyData: hex.decode(secp256k1.keyFromPrivate(ki.toArray()).getPrivate(\"hex\")),\n      chainCode: IR\n    };\n  } catch {\n    return derive(parentKey, chainCode, index + 1);\n  }\n}","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/hbar-shop/hbar-shopify-coupon-client/node_modules/@hashgraph/cryptography/src/primitive/bip32.js"],"names":["hmac","hex","elliptic","secp256k1","ec","HIGHEST_BIT","derive","parentKey","chainCode","index","isHardened","data","Uint8Array","publicKey","decode","keyFromPrivate","getPublic","set","DataView","buffer","byteOffset","byteLength","setUint32","I","hash","HashAlgorithm","Sha512","IL","subarray","IR","ki","getPrivate","add","eqn","keyData","toArray"],"mappings":"AAAA,OAAO,KAAKA,IAAZ,MAAsB,WAAtB;AACA,OAAO,KAAKC,GAAZ,MAAqB,oBAArB;AACA,OAAOC,QAAP,MAAqB,UAArB;AAEA,MAAMC,SAAS,GAAG,IAAID,QAAQ,CAACE,EAAb,CAAgB,WAAhB,CAAlB;AAEA,MAAMC,WAAW,GAAG,UAApB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,eAAeC,MAAf,CAAsBC,SAAtB,EAAiCC,SAAjC,EAA4CC,KAA5C,EAAmD;AACtD,QAAMC,UAAU,GAAG,CAACD,KAAK,GAAGJ,WAAT,MAA0B,CAA7C;AACA,QAAMM,IAAI,GAAG,IAAIC,UAAJ,CAAe,EAAf,CAAb;AAEA,QAAMC,SAAS,GAAGZ,GAAG,CAACa,MAAJ,CACdX,SAAS,CAACY,cAAV,CAAyBR,SAAzB,EAAoCS,SAApC,CAA8C,IAA9C,EAAoD,KAApD,CADc,CAAlB,CAJsD,CAQtD;;AACA,MAAIN,UAAJ,EAAgB;AACZ;AACAC,IAAAA,IAAI,CAAC,CAAD,CAAJ,GAAU,IAAV;AACAA,IAAAA,IAAI,CAACM,GAAL,CAASV,SAAT,EAAoB,CAApB,EAHY,CAKZ;AACH,GAND,MAMO;AACH;AACA;AACAI,IAAAA,IAAI,CAACM,GAAL,CAASJ,SAAT,EAAoB,CAApB;AACH;;AAED,MAAIK,QAAJ,CAAaP,IAAI,CAACQ,MAAlB,EAA0BR,IAAI,CAACS,UAA/B,EAA2CT,IAAI,CAACU,UAAhD,EAA4DC,SAA5D,CACI,EADJ,EAEIb,KAFJ,EAGI,KAHJ;AAMA,QAAMc,CAAC,GAAG,MAAMvB,IAAI,CAACwB,IAAL,CAAUxB,IAAI,CAACyB,aAAL,CAAmBC,MAA7B,EAAqClB,SAArC,EAAgDG,IAAhD,CAAhB;AACA,QAAMgB,EAAE,GAAGJ,CAAC,CAACK,QAAF,CAAW,CAAX,EAAc,EAAd,CAAX;AACA,QAAMC,EAAE,GAAGN,CAAC,CAACK,QAAF,CAAW,EAAX,CAAX,CA7BsD,CA+BtD;;AACA,MAAI;AACA;AACA,UAAME,EAAE,GAAG3B,SAAS,CACfY,cADM,CACSR,SADT,EAENwB,UAFM,GAGNC,GAHM,CAGF7B,SAAS,CAACY,cAAV,CAAyBY,EAAzB,EAA6BI,UAA7B,EAHE,CAAX,CAFA,CAMA;AAEA;;AACA,QAAID,EAAE,CAACG,GAAH,CAAO,CAAP,CAAJ,EAAe;AACX,aAAO3B,MAAM,CAACC,SAAD,EAAYC,SAAZ,EAAuBC,KAAK,GAAG,CAA/B,CAAb;AACH;;AAED,WAAO;AACHyB,MAAAA,OAAO,EAAEjC,GAAG,CAACa,MAAJ,CACLX,SAAS,CAACY,cAAV,CAAyBe,EAAE,CAACK,OAAH,EAAzB,EAAuCJ,UAAvC,CAAkD,KAAlD,CADK,CADN;AAIHvB,MAAAA,SAAS,EAAEqB;AAJR,KAAP;AAMH,GAnBD,CAmBE,MAAM;AACJ,WAAOvB,MAAM,CAACC,SAAD,EAAYC,SAAZ,EAAuBC,KAAK,GAAG,CAA/B,CAAb;AACH;AACJ","sourcesContent":["import * as hmac from \"./hmac.js\";\nimport * as hex from \"../encoding/hex.js\";\nimport elliptic from \"elliptic\";\n\nconst secp256k1 = new elliptic.ec(\"secp256k1\");\n\nconst HIGHEST_BIT = 0x80000000;\n\n/**\n * Mostly copied from https://github.com/bitcoinjs/bip32/blob/master/ts-src/bip32.ts\n * We cannot use that library directly because it uses `Buffer` and we want to avoid\n * polyfills as much as possible. Also, we only need the `derive` function.\n *\n * @param {Uint8Array} parentKey\n * @param {Uint8Array} chainCode\n * @param {number} index\n * @returns {Promise<{ keyData: Uint8Array; chainCode: Uint8Array }>}\n */\nexport async function derive(parentKey, chainCode, index) {\n    const isHardened = (index & HIGHEST_BIT) !== 0;\n    const data = new Uint8Array(37);\n\n    const publicKey = hex.decode(\n        secp256k1.keyFromPrivate(parentKey).getPublic(true, \"hex\")\n    );\n\n    // Hardened child\n    if (isHardened) {\n        // data = 0x00 || ser256(kpar) || ser32(index)\n        data[0] = 0x00;\n        data.set(parentKey, 1);\n\n        // Normal child\n    } else {\n        // data = serP(point(kpar)) || ser32(index)\n        //      = serP(Kpar) || ser32(index)\n        data.set(publicKey, 0);\n    }\n\n    new DataView(data.buffer, data.byteOffset, data.byteLength).setUint32(\n        33,\n        index,\n        false\n    );\n\n    const I = await hmac.hash(hmac.HashAlgorithm.Sha512, chainCode, data);\n    const IL = I.subarray(0, 32);\n    const IR = I.subarray(32);\n\n    // if parse256(IL) >= n, proceed with the next value for i\n    try {\n        // ki = parse256(IL) + kpar (mod n)\n        const ki = secp256k1\n            .keyFromPrivate(parentKey)\n            .getPrivate()\n            .add(secp256k1.keyFromPrivate(IL).getPrivate());\n        // const ki = Buffer.from(ecc.privateAdd(this.privateKey!, IL)!);\n\n        // In case ki == 0, proceed with the next value for i\n        if (ki.eqn(0)) {\n            return derive(parentKey, chainCode, index + 1);\n        }\n\n        return {\n            keyData: hex.decode(\n                secp256k1.keyFromPrivate(ki.toArray()).getPrivate(\"hex\")\n            ),\n            chainCode: IR,\n        };\n    } catch {\n        return derive(parentKey, chainCode, index + 1);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}