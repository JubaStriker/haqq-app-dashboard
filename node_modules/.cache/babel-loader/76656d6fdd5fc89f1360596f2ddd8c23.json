{"ast":null,"code":"\"use strict\";\n/*\n  GIFEncoder.js\n\n  Authors\n  Kevin Weiner (original Java version - kweiner@fmsware.com)\n  Thibault Imbert (AS3 version - bytearray.org)\n  Johan Nordberg (JS version - code@johan-nordberg.com)\n  Makito (Optimized for AwesomeQR - sumimakito@hotmail,com)\n*/\n\nvar NeuQuant = require(\"./TypedNeuQuant.js\");\n\nvar LZWEncoder = require(\"./LZWEncoder.js\");\n\nfunction ByteArray() {\n  this.page = -1;\n  this.pages = [];\n  this.newPage();\n}\n\nByteArray.pageSize = 4096;\nByteArray.charMap = {};\n\nfor (var i = 0; i < 256; i++) ByteArray.charMap[i] = String.fromCharCode(i);\n\nByteArray.prototype.newPage = function () {\n  this.pages[++this.page] = new Uint8Array(ByteArray.pageSize);\n  this.cursor = 0;\n};\n\nByteArray.prototype.getData = function () {\n  var rv = \"\";\n\n  for (var p = 0; p < this.pages.length; p++) {\n    for (var i = 0; i < ByteArray.pageSize; i++) {\n      rv += ByteArray.charMap[this.pages[p][i]];\n    }\n  }\n\n  return rv;\n};\n\nByteArray.prototype.toFlattenUint8Array = function () {\n  var chunks = [];\n\n  for (var p = 0; p < this.pages.length; p++) {\n    if (p === this.pages.length - 1) {\n      var chunk = Uint8Array.from(this.pages[p].slice(0, this.cursor));\n      chunks.push(chunk);\n    } else {\n      chunks.push(this.pages[p]);\n    }\n  }\n\n  var flatten = new Uint8Array(chunks.reduce(function (acc, chunk) {\n    return acc + chunk.length;\n  }, 0));\n  chunks.reduce(function (lastLength, chunk) {\n    flatten.set(chunk, lastLength);\n    return lastLength + chunk.length;\n  }, 0);\n  return flatten;\n};\n\nByteArray.prototype.writeByte = function (val) {\n  if (this.cursor >= ByteArray.pageSize) this.newPage();\n  this.pages[this.page][this.cursor++] = val;\n};\n\nByteArray.prototype.writeUTFBytes = function (string) {\n  for (var l = string.length, i = 0; i < l; i++) this.writeByte(string.charCodeAt(i));\n};\n\nByteArray.prototype.writeBytes = function (array, offset, length) {\n  for (var l = length || array.length, i = offset || 0; i < l; i++) this.writeByte(array[i]);\n};\n\nfunction GIFEncoder(width, height) {\n  // image size\n  this.width = ~~width;\n  this.height = ~~height; // transparent color if given\n\n  this.transparent = null; // transparent index in color table\n\n  this.transIndex = 0; // -1 = no repeat, 0 = forever. anything else is repeat count\n\n  this.repeat = -1; // frame delay (hundredths)\n\n  this.delay = 0;\n  this.image = null; // current frame\n\n  this.pixels = null; // BGR byte array from frame\n\n  this.indexedPixels = null; // converted frame indexed to palette\n\n  this.colorDepth = null; // number of bit planes\n\n  this.colorTab = null; // RGB palette\n\n  this.neuQuant = null; // NeuQuant instance that was used to generate this.colorTab.\n\n  this.usedEntry = new Array(); // active palette entries\n\n  this.palSize = 7; // color table size (bits-1)\n\n  this.dispose = -1; // disposal code (-1 = use default)\n\n  this.firstFrame = true;\n  this.sample = 10; // default sample interval for quantizer\n\n  this.dither = false; // default dithering\n\n  this.globalPalette = false;\n  this.out = new ByteArray();\n}\n/*\n  Sets the delay time between each frame, or changes it for subsequent frames\n  (applies to last frame added)\n*/\n\n\nGIFEncoder.prototype.setDelay = function (milliseconds) {\n  this.delay = Math.round(milliseconds / 10);\n};\n/*\n  Sets frame rate in frames per second.\n*/\n\n\nGIFEncoder.prototype.setFrameRate = function (fps) {\n  this.delay = Math.round(100 / fps);\n};\n/*\n  Sets the GIF frame disposal code for the last added frame and any\n  subsequent frames.\n\n  Default is 0 if no transparent color has been set, otherwise 2.\n*/\n\n\nGIFEncoder.prototype.setDispose = function (disposalCode) {\n  if (disposalCode >= 0) this.dispose = disposalCode;\n};\n/*\n  Sets the number of times the set of GIF frames should be played.\n\n  -1 = play once\n  0 = repeat indefinitely\n\n  Default is -1\n\n  Must be invoked before the first image is added\n*/\n\n\nGIFEncoder.prototype.setRepeat = function (repeat) {\n  this.repeat = repeat;\n};\n/*\n  Sets the transparent color for the last added frame and any subsequent\n  frames. Since all colors are subject to modification in the quantization\n  process, the color in the final palette for each frame closest to the given\n  color becomes the transparent color for that frame. May be set to null to\n  indicate no transparent color.\n*/\n\n\nGIFEncoder.prototype.setTransparent = function (color) {\n  this.transparent = color;\n};\n/*\n  Adds next GIF frame. The frame is not written immediately, but is\n  actually deferred until the next frame is received so that timing\n  data can be inserted.  Invoking finish() flushes all frames.\n*/\n\n\nGIFEncoder.prototype.addFrame = function (imageData) {\n  this.image = imageData;\n  this.colorTab = this.globalPalette && this.globalPalette.slice ? this.globalPalette : null;\n  this.getImagePixels(); // convert to correct format if necessary\n\n  this.analyzePixels(); // build color table & map pixels\n\n  if (this.globalPalette === true) this.globalPalette = this.colorTab;\n\n  if (this.firstFrame) {\n    this.writeHeader();\n    this.writeLSD(); // logical screen descriptior\n\n    this.writePalette(); // global color table\n\n    if (this.repeat >= 0) {\n      // use NS app extension to indicate reps\n      this.writeNetscapeExt();\n    }\n  }\n\n  this.writeGraphicCtrlExt(); // write graphic control extension\n\n  this.writeImageDesc(); // image descriptor\n\n  if (!this.firstFrame && !this.globalPalette) this.writePalette(); // local color table\n\n  this.writePixels(); // encode and write pixel data\n\n  this.firstFrame = false;\n};\n/*\n  Adds final trailer to the GIF stream, if you don't call the finish method\n  the GIF stream will not be valid.\n*/\n\n\nGIFEncoder.prototype.finish = function () {\n  this.out.writeByte(0x3b); // gif trailer\n};\n/*\n  Sets quality of color quantization (conversion of images to the maximum 256\n  colors allowed by the GIF specification). Lower values (minimum = 1)\n  produce better colors, but slow processing significantly. 10 is the\n  default, and produces good color mapping at reasonable speeds. Values\n  greater than 20 do not yield significant improvements in speed.\n*/\n\n\nGIFEncoder.prototype.setQuality = function (quality) {\n  if (quality < 1) quality = 1;\n  this.sample = quality;\n};\n/*\n  Sets dithering method. Available are:\n  - FALSE no dithering\n  - TRUE or FloydSteinberg\n  - FalseFloydSteinberg\n  - Stucki\n  - Atkinson\n  You can add '-serpentine' to use serpentine scanning\n*/\n\n\nGIFEncoder.prototype.setDither = function (dither) {\n  if (dither === true) dither = \"FloydSteinberg\";\n  this.dither = dither;\n};\n/*\n  Sets global palette for all frames.\n  You can provide TRUE to create global palette from first picture.\n  Or an array of r,g,b,r,g,b,...\n*/\n\n\nGIFEncoder.prototype.setGlobalPalette = function (palette) {\n  this.globalPalette = palette;\n};\n/*\n  Returns global palette used for all frames.\n  If setGlobalPalette(true) was used, then this function will return\n  calculated palette after the first frame is added.\n*/\n\n\nGIFEncoder.prototype.getGlobalPalette = function () {\n  return this.globalPalette && this.globalPalette.slice && this.globalPalette.slice(0) || this.globalPalette;\n};\n/*\n  Writes GIF file header\n*/\n\n\nGIFEncoder.prototype.writeHeader = function () {\n  this.out.writeUTFBytes(\"GIF89a\");\n};\n/*\n  Analyzes current frame colors and creates color map.\n*/\n\n\nGIFEncoder.prototype.analyzePixels = function () {\n  if (!this.colorTab) {\n    this.neuQuant = new NeuQuant(this.pixels, this.sample);\n    this.neuQuant.buildColormap(); // create reduced palette\n\n    this.colorTab = this.neuQuant.getColormap();\n  } // map image pixels to new palette\n\n\n  if (this.dither) {\n    this.ditherPixels(this.dither.replace(\"-serpentine\", \"\"), this.dither.match(/-serpentine/) !== null);\n  } else {\n    this.indexPixels();\n  }\n\n  this.pixels = null;\n  this.colorDepth = 8;\n  this.palSize = 7; // get closest match to transparent color if specified\n\n  if (this.transparent !== null) {\n    this.transIndex = this.findClosest(this.transparent, true);\n  }\n};\n/*\n  Index pixels, without dithering\n*/\n\n\nGIFEncoder.prototype.indexPixels = function (imgq) {\n  var nPix = this.pixels.length / 3;\n  this.indexedPixels = new Uint8Array(nPix);\n  var k = 0;\n\n  for (var j = 0; j < nPix; j++) {\n    var index = this.findClosestRGB(this.pixels[k++] & 0xff, this.pixels[k++] & 0xff, this.pixels[k++] & 0xff);\n    this.usedEntry[index] = true;\n    this.indexedPixels[j] = index;\n  }\n};\n/*\n  Taken from http://jsbin.com/iXofIji/2/edit by PAEz\n*/\n\n\nGIFEncoder.prototype.ditherPixels = function (kernel, serpentine) {\n  var kernels = {\n    FalseFloydSteinberg: [[3 / 8, 1, 0], [3 / 8, 0, 1], [2 / 8, 1, 1]],\n    FloydSteinberg: [[7 / 16, 1, 0], [3 / 16, -1, 1], [5 / 16, 0, 1], [1 / 16, 1, 1]],\n    Stucki: [[8 / 42, 1, 0], [4 / 42, 2, 0], [2 / 42, -2, 1], [4 / 42, -1, 1], [8 / 42, 0, 1], [4 / 42, 1, 1], [2 / 42, 2, 1], [1 / 42, -2, 2], [2 / 42, -1, 2], [4 / 42, 0, 2], [2 / 42, 1, 2], [1 / 42, 2, 2]],\n    Atkinson: [[1 / 8, 1, 0], [1 / 8, 2, 0], [1 / 8, -1, 1], [1 / 8, 0, 1], [1 / 8, 1, 1], [1 / 8, 0, 2]]\n  };\n\n  if (!kernel || !kernels[kernel]) {\n    throw \"Unknown dithering kernel: \" + kernel;\n  }\n\n  var ds = kernels[kernel];\n  var index = 0,\n      height = this.height,\n      width = this.width,\n      data = this.pixels;\n  var direction = serpentine ? -1 : 1;\n  this.indexedPixels = new Uint8Array(this.pixels.length / 3);\n\n  for (var y = 0; y < height; y++) {\n    if (serpentine) direction = direction * -1;\n\n    for (var x = direction == 1 ? 0 : width - 1, xend = direction == 1 ? width : 0; x !== xend; x += direction) {\n      index = y * width + x; // Get original colour\n\n      var idx = index * 3;\n      var r1 = data[idx];\n      var g1 = data[idx + 1];\n      var b1 = data[idx + 2]; // Get converted colour\n\n      idx = this.findClosestRGB(r1, g1, b1);\n      this.usedEntry[idx] = true;\n      this.indexedPixels[index] = idx;\n      idx *= 3;\n      var r2 = this.colorTab[idx];\n      var g2 = this.colorTab[idx + 1];\n      var b2 = this.colorTab[idx + 2];\n      var er = r1 - r2;\n      var eg = g1 - g2;\n      var eb = b1 - b2;\n\n      for (var i = direction == 1 ? 0 : ds.length - 1, end = direction == 1 ? ds.length : 0; i !== end; i += direction) {\n        var x1 = ds[i][1]; // *direction;  //  Should this by timesd by direction?..to make the kernel go in the opposite direction....got no idea....\n\n        var y1 = ds[i][2];\n\n        if (x1 + x >= 0 && x1 + x < width && y1 + y >= 0 && y1 + y < height) {\n          var d = ds[i][0];\n          idx = index + x1 + y1 * width;\n          idx *= 3;\n          data[idx] = Math.max(0, Math.min(255, data[idx] + er * d));\n          data[idx + 1] = Math.max(0, Math.min(255, data[idx + 1] + eg * d));\n          data[idx + 2] = Math.max(0, Math.min(255, data[idx + 2] + eb * d));\n        }\n      }\n    }\n  }\n};\n/*\n  Returns index of palette color closest to c\n*/\n\n\nGIFEncoder.prototype.findClosest = function (c, used) {\n  return this.findClosestRGB((c & 0xff0000) >> 16, (c & 0x00ff00) >> 8, c & 0x0000ff, used);\n};\n\nGIFEncoder.prototype.findClosestRGB = function (r, g, b, used) {\n  if (this.colorTab === null) return -1;\n\n  if (this.neuQuant && !used) {\n    return this.neuQuant.lookupRGB(r, g, b);\n  }\n\n  var c = b | g << 8 | r << 16;\n  var minpos = 0;\n  var dmin = 256 * 256 * 256;\n  var len = this.colorTab.length;\n\n  for (var i = 0, index = 0; i < len; index++) {\n    var dr = r - (this.colorTab[i++] & 0xff);\n    var dg = g - (this.colorTab[i++] & 0xff);\n    var db = b - (this.colorTab[i++] & 0xff);\n    var d = dr * dr + dg * dg + db * db;\n\n    if ((!used || this.usedEntry[index]) && d < dmin) {\n      dmin = d;\n      minpos = index;\n    }\n  }\n\n  return minpos;\n};\n/*\n  Extracts image pixels into byte array pixels\n  (removes alphachannel from canvas imagedata)\n*/\n\n\nGIFEncoder.prototype.getImagePixels = function () {\n  var w = this.width;\n  var h = this.height;\n  this.pixels = new Uint8Array(w * h * 3);\n  var data = this.image;\n  var srcPos = 0;\n  var count = 0;\n\n  for (var i = 0; i < h; i++) {\n    for (var j = 0; j < w; j++) {\n      this.pixels[count++] = data[srcPos++];\n      this.pixels[count++] = data[srcPos++];\n      this.pixels[count++] = data[srcPos++];\n      srcPos++;\n    }\n  }\n};\n/*\n  Writes Graphic Control Extension\n*/\n\n\nGIFEncoder.prototype.writeGraphicCtrlExt = function () {\n  this.out.writeByte(0x21); // extension introducer\n\n  this.out.writeByte(0xf9); // GCE label\n\n  this.out.writeByte(4); // data block size\n\n  var transp, disp;\n\n  if (this.transparent === null) {\n    transp = 0;\n    disp = 0; // dispose = no action\n  } else {\n    transp = 1;\n    disp = 2; // force clear if using transparent color\n  }\n\n  if (this.dispose >= 0) {\n    disp = this.dispose & 7; // user override\n  }\n\n  disp <<= 2; // packed fields\n\n  this.out.writeByte(0 | // 1:3 reserved\n  disp | // 4:6 disposal\n  0 | // 7 user input - 0 = none\n  transp // 8 transparency flag\n  );\n  this.writeShort(this.delay); // delay x 1/100 sec\n\n  this.out.writeByte(this.transIndex); // transparent color index\n\n  this.out.writeByte(0); // block terminator\n};\n/*\n  Writes Image Descriptor\n*/\n\n\nGIFEncoder.prototype.writeImageDesc = function () {\n  this.out.writeByte(0x2c); // image separator\n\n  this.writeShort(0); // image position x,y = 0,0\n\n  this.writeShort(0);\n  this.writeShort(this.width); // image size\n\n  this.writeShort(this.height); // packed fields\n\n  if (this.firstFrame || this.globalPalette) {\n    // no LCT - GCT is used for first (or only) frame\n    this.out.writeByte(0);\n  } else {\n    // specify normal LCT\n    this.out.writeByte(0x80 | // 1 local color table 1=yes\n    0 | // 2 interlace - 0=no\n    0 | // 3 sorted - 0=no\n    0 | // 4-5 reserved\n    this.palSize // 6-8 size of color table\n    );\n  }\n};\n/*\n  Writes Logical Screen Descriptor\n*/\n\n\nGIFEncoder.prototype.writeLSD = function () {\n  // logical screen size\n  this.writeShort(this.width);\n  this.writeShort(this.height); // packed fields\n\n  this.out.writeByte(0x80 | // 1 : global color table flag = 1 (gct used)\n  0x70 | // 2-4 : color resolution = 7\n  0x00 | // 5 : gct sort flag = 0\n  this.palSize // 6-8 : gct size\n  );\n  this.out.writeByte(0); // background color index\n\n  this.out.writeByte(0); // pixel aspect ratio - assume 1:1\n};\n/*\n  Writes Netscape application extension to define repeat count.\n*/\n\n\nGIFEncoder.prototype.writeNetscapeExt = function () {\n  this.out.writeByte(0x21); // extension introducer\n\n  this.out.writeByte(0xff); // app extension label\n\n  this.out.writeByte(11); // block size\n\n  this.out.writeUTFBytes(\"NETSCAPE2.0\"); // app id + auth code\n\n  this.out.writeByte(3); // sub-block size\n\n  this.out.writeByte(1); // loop sub-block id\n\n  this.writeShort(this.repeat); // loop count (extra iterations, 0=repeat forever)\n\n  this.out.writeByte(0); // block terminator\n};\n/*\n  Writes color table\n*/\n\n\nGIFEncoder.prototype.writePalette = function () {\n  this.out.writeBytes(this.colorTab);\n  var n = 3 * 256 - this.colorTab.length;\n\n  for (var i = 0; i < n; i++) this.out.writeByte(0);\n};\n\nGIFEncoder.prototype.writeShort = function (pValue) {\n  this.out.writeByte(pValue & 0xff);\n  this.out.writeByte(pValue >> 8 & 0xff);\n};\n/*\n  Encodes and writes pixel data\n*/\n\n\nGIFEncoder.prototype.writePixels = function () {\n  var enc = new LZWEncoder(this.width, this.height, this.indexedPixels, this.colorDepth);\n  enc.encode(this.out);\n};\n/*\n  Retrieves the GIF stream\n*/\n\n\nGIFEncoder.prototype.stream = function () {\n  return this.out;\n};\n\nmodule.exports = GIFEncoder;","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/hbar-shop/hbar-shop-dashboard/node_modules/awesome-qr/lib/gif.js/GIFEncoder.js"],"names":["NeuQuant","require","LZWEncoder","ByteArray","page","pages","newPage","pageSize","charMap","i","String","fromCharCode","prototype","Uint8Array","cursor","getData","rv","p","length","toFlattenUint8Array","chunks","chunk","from","slice","push","flatten","reduce","acc","lastLength","set","writeByte","val","writeUTFBytes","string","l","charCodeAt","writeBytes","array","offset","GIFEncoder","width","height","transparent","transIndex","repeat","delay","image","pixels","indexedPixels","colorDepth","colorTab","neuQuant","usedEntry","Array","palSize","dispose","firstFrame","sample","dither","globalPalette","out","setDelay","milliseconds","Math","round","setFrameRate","fps","setDispose","disposalCode","setRepeat","setTransparent","color","addFrame","imageData","getImagePixels","analyzePixels","writeHeader","writeLSD","writePalette","writeNetscapeExt","writeGraphicCtrlExt","writeImageDesc","writePixels","finish","setQuality","quality","setDither","setGlobalPalette","palette","getGlobalPalette","buildColormap","getColormap","ditherPixels","replace","match","indexPixels","findClosest","imgq","nPix","k","j","index","findClosestRGB","kernel","serpentine","kernels","FalseFloydSteinberg","FloydSteinberg","Stucki","Atkinson","ds","data","direction","y","x","xend","idx","r1","g1","b1","r2","g2","b2","er","eg","eb","end","x1","y1","d","max","min","c","used","r","g","b","lookupRGB","minpos","dmin","len","dr","dg","db","w","h","srcPos","count","transp","disp","writeShort","n","pValue","enc","encode","stream","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n/*\n  GIFEncoder.js\n\n  Authors\n  Kevin Weiner (original Java version - kweiner@fmsware.com)\n  Thibault Imbert (AS3 version - bytearray.org)\n  Johan Nordberg (JS version - code@johan-nordberg.com)\n  Makito (Optimized for AwesomeQR - sumimakito@hotmail,com)\n*/\nvar NeuQuant = require(\"./TypedNeuQuant.js\");\nvar LZWEncoder = require(\"./LZWEncoder.js\");\nfunction ByteArray() {\n    this.page = -1;\n    this.pages = [];\n    this.newPage();\n}\nByteArray.pageSize = 4096;\nByteArray.charMap = {};\nfor (var i = 0; i < 256; i++)\n    ByteArray.charMap[i] = String.fromCharCode(i);\nByteArray.prototype.newPage = function () {\n    this.pages[++this.page] = new Uint8Array(ByteArray.pageSize);\n    this.cursor = 0;\n};\nByteArray.prototype.getData = function () {\n    var rv = \"\";\n    for (var p = 0; p < this.pages.length; p++) {\n        for (var i = 0; i < ByteArray.pageSize; i++) {\n            rv += ByteArray.charMap[this.pages[p][i]];\n        }\n    }\n    return rv;\n};\nByteArray.prototype.toFlattenUint8Array = function () {\n    var chunks = [];\n    for (var p = 0; p < this.pages.length; p++) {\n        if (p === this.pages.length - 1) {\n            var chunk = Uint8Array.from(this.pages[p].slice(0, this.cursor));\n            chunks.push(chunk);\n        }\n        else {\n            chunks.push(this.pages[p]);\n        }\n    }\n    var flatten = new Uint8Array(chunks.reduce(function (acc, chunk) { return acc + chunk.length; }, 0));\n    chunks.reduce(function (lastLength, chunk) {\n        flatten.set(chunk, lastLength);\n        return lastLength + chunk.length;\n    }, 0);\n    return flatten;\n};\nByteArray.prototype.writeByte = function (val) {\n    if (this.cursor >= ByteArray.pageSize)\n        this.newPage();\n    this.pages[this.page][this.cursor++] = val;\n};\nByteArray.prototype.writeUTFBytes = function (string) {\n    for (var l = string.length, i = 0; i < l; i++)\n        this.writeByte(string.charCodeAt(i));\n};\nByteArray.prototype.writeBytes = function (array, offset, length) {\n    for (var l = length || array.length, i = offset || 0; i < l; i++)\n        this.writeByte(array[i]);\n};\nfunction GIFEncoder(width, height) {\n    // image size\n    this.width = ~~width;\n    this.height = ~~height;\n    // transparent color if given\n    this.transparent = null;\n    // transparent index in color table\n    this.transIndex = 0;\n    // -1 = no repeat, 0 = forever. anything else is repeat count\n    this.repeat = -1;\n    // frame delay (hundredths)\n    this.delay = 0;\n    this.image = null; // current frame\n    this.pixels = null; // BGR byte array from frame\n    this.indexedPixels = null; // converted frame indexed to palette\n    this.colorDepth = null; // number of bit planes\n    this.colorTab = null; // RGB palette\n    this.neuQuant = null; // NeuQuant instance that was used to generate this.colorTab.\n    this.usedEntry = new Array(); // active palette entries\n    this.palSize = 7; // color table size (bits-1)\n    this.dispose = -1; // disposal code (-1 = use default)\n    this.firstFrame = true;\n    this.sample = 10; // default sample interval for quantizer\n    this.dither = false; // default dithering\n    this.globalPalette = false;\n    this.out = new ByteArray();\n}\n/*\n  Sets the delay time between each frame, or changes it for subsequent frames\n  (applies to last frame added)\n*/\nGIFEncoder.prototype.setDelay = function (milliseconds) {\n    this.delay = Math.round(milliseconds / 10);\n};\n/*\n  Sets frame rate in frames per second.\n*/\nGIFEncoder.prototype.setFrameRate = function (fps) {\n    this.delay = Math.round(100 / fps);\n};\n/*\n  Sets the GIF frame disposal code for the last added frame and any\n  subsequent frames.\n\n  Default is 0 if no transparent color has been set, otherwise 2.\n*/\nGIFEncoder.prototype.setDispose = function (disposalCode) {\n    if (disposalCode >= 0)\n        this.dispose = disposalCode;\n};\n/*\n  Sets the number of times the set of GIF frames should be played.\n\n  -1 = play once\n  0 = repeat indefinitely\n\n  Default is -1\n\n  Must be invoked before the first image is added\n*/\nGIFEncoder.prototype.setRepeat = function (repeat) {\n    this.repeat = repeat;\n};\n/*\n  Sets the transparent color for the last added frame and any subsequent\n  frames. Since all colors are subject to modification in the quantization\n  process, the color in the final palette for each frame closest to the given\n  color becomes the transparent color for that frame. May be set to null to\n  indicate no transparent color.\n*/\nGIFEncoder.prototype.setTransparent = function (color) {\n    this.transparent = color;\n};\n/*\n  Adds next GIF frame. The frame is not written immediately, but is\n  actually deferred until the next frame is received so that timing\n  data can be inserted.  Invoking finish() flushes all frames.\n*/\nGIFEncoder.prototype.addFrame = function (imageData) {\n    this.image = imageData;\n    this.colorTab = this.globalPalette && this.globalPalette.slice ? this.globalPalette : null;\n    this.getImagePixels(); // convert to correct format if necessary\n    this.analyzePixels(); // build color table & map pixels\n    if (this.globalPalette === true)\n        this.globalPalette = this.colorTab;\n    if (this.firstFrame) {\n        this.writeHeader();\n        this.writeLSD(); // logical screen descriptior\n        this.writePalette(); // global color table\n        if (this.repeat >= 0) {\n            // use NS app extension to indicate reps\n            this.writeNetscapeExt();\n        }\n    }\n    this.writeGraphicCtrlExt(); // write graphic control extension\n    this.writeImageDesc(); // image descriptor\n    if (!this.firstFrame && !this.globalPalette)\n        this.writePalette(); // local color table\n    this.writePixels(); // encode and write pixel data\n    this.firstFrame = false;\n};\n/*\n  Adds final trailer to the GIF stream, if you don't call the finish method\n  the GIF stream will not be valid.\n*/\nGIFEncoder.prototype.finish = function () {\n    this.out.writeByte(0x3b); // gif trailer\n};\n/*\n  Sets quality of color quantization (conversion of images to the maximum 256\n  colors allowed by the GIF specification). Lower values (minimum = 1)\n  produce better colors, but slow processing significantly. 10 is the\n  default, and produces good color mapping at reasonable speeds. Values\n  greater than 20 do not yield significant improvements in speed.\n*/\nGIFEncoder.prototype.setQuality = function (quality) {\n    if (quality < 1)\n        quality = 1;\n    this.sample = quality;\n};\n/*\n  Sets dithering method. Available are:\n  - FALSE no dithering\n  - TRUE or FloydSteinberg\n  - FalseFloydSteinberg\n  - Stucki\n  - Atkinson\n  You can add '-serpentine' to use serpentine scanning\n*/\nGIFEncoder.prototype.setDither = function (dither) {\n    if (dither === true)\n        dither = \"FloydSteinberg\";\n    this.dither = dither;\n};\n/*\n  Sets global palette for all frames.\n  You can provide TRUE to create global palette from first picture.\n  Or an array of r,g,b,r,g,b,...\n*/\nGIFEncoder.prototype.setGlobalPalette = function (palette) {\n    this.globalPalette = palette;\n};\n/*\n  Returns global palette used for all frames.\n  If setGlobalPalette(true) was used, then this function will return\n  calculated palette after the first frame is added.\n*/\nGIFEncoder.prototype.getGlobalPalette = function () {\n    return (this.globalPalette && this.globalPalette.slice && this.globalPalette.slice(0)) || this.globalPalette;\n};\n/*\n  Writes GIF file header\n*/\nGIFEncoder.prototype.writeHeader = function () {\n    this.out.writeUTFBytes(\"GIF89a\");\n};\n/*\n  Analyzes current frame colors and creates color map.\n*/\nGIFEncoder.prototype.analyzePixels = function () {\n    if (!this.colorTab) {\n        this.neuQuant = new NeuQuant(this.pixels, this.sample);\n        this.neuQuant.buildColormap(); // create reduced palette\n        this.colorTab = this.neuQuant.getColormap();\n    }\n    // map image pixels to new palette\n    if (this.dither) {\n        this.ditherPixels(this.dither.replace(\"-serpentine\", \"\"), this.dither.match(/-serpentine/) !== null);\n    }\n    else {\n        this.indexPixels();\n    }\n    this.pixels = null;\n    this.colorDepth = 8;\n    this.palSize = 7;\n    // get closest match to transparent color if specified\n    if (this.transparent !== null) {\n        this.transIndex = this.findClosest(this.transparent, true);\n    }\n};\n/*\n  Index pixels, without dithering\n*/\nGIFEncoder.prototype.indexPixels = function (imgq) {\n    var nPix = this.pixels.length / 3;\n    this.indexedPixels = new Uint8Array(nPix);\n    var k = 0;\n    for (var j = 0; j < nPix; j++) {\n        var index = this.findClosestRGB(this.pixels[k++] & 0xff, this.pixels[k++] & 0xff, this.pixels[k++] & 0xff);\n        this.usedEntry[index] = true;\n        this.indexedPixels[j] = index;\n    }\n};\n/*\n  Taken from http://jsbin.com/iXofIji/2/edit by PAEz\n*/\nGIFEncoder.prototype.ditherPixels = function (kernel, serpentine) {\n    var kernels = {\n        FalseFloydSteinberg: [\n            [3 / 8, 1, 0],\n            [3 / 8, 0, 1],\n            [2 / 8, 1, 1],\n        ],\n        FloydSteinberg: [\n            [7 / 16, 1, 0],\n            [3 / 16, -1, 1],\n            [5 / 16, 0, 1],\n            [1 / 16, 1, 1],\n        ],\n        Stucki: [\n            [8 / 42, 1, 0],\n            [4 / 42, 2, 0],\n            [2 / 42, -2, 1],\n            [4 / 42, -1, 1],\n            [8 / 42, 0, 1],\n            [4 / 42, 1, 1],\n            [2 / 42, 2, 1],\n            [1 / 42, -2, 2],\n            [2 / 42, -1, 2],\n            [4 / 42, 0, 2],\n            [2 / 42, 1, 2],\n            [1 / 42, 2, 2],\n        ],\n        Atkinson: [\n            [1 / 8, 1, 0],\n            [1 / 8, 2, 0],\n            [1 / 8, -1, 1],\n            [1 / 8, 0, 1],\n            [1 / 8, 1, 1],\n            [1 / 8, 0, 2],\n        ],\n    };\n    if (!kernel || !kernels[kernel]) {\n        throw \"Unknown dithering kernel: \" + kernel;\n    }\n    var ds = kernels[kernel];\n    var index = 0, height = this.height, width = this.width, data = this.pixels;\n    var direction = serpentine ? -1 : 1;\n    this.indexedPixels = new Uint8Array(this.pixels.length / 3);\n    for (var y = 0; y < height; y++) {\n        if (serpentine)\n            direction = direction * -1;\n        for (var x = direction == 1 ? 0 : width - 1, xend = direction == 1 ? width : 0; x !== xend; x += direction) {\n            index = y * width + x;\n            // Get original colour\n            var idx = index * 3;\n            var r1 = data[idx];\n            var g1 = data[idx + 1];\n            var b1 = data[idx + 2];\n            // Get converted colour\n            idx = this.findClosestRGB(r1, g1, b1);\n            this.usedEntry[idx] = true;\n            this.indexedPixels[index] = idx;\n            idx *= 3;\n            var r2 = this.colorTab[idx];\n            var g2 = this.colorTab[idx + 1];\n            var b2 = this.colorTab[idx + 2];\n            var er = r1 - r2;\n            var eg = g1 - g2;\n            var eb = b1 - b2;\n            for (var i = direction == 1 ? 0 : ds.length - 1, end = direction == 1 ? ds.length : 0; i !== end; i += direction) {\n                var x1 = ds[i][1]; // *direction;  //  Should this by timesd by direction?..to make the kernel go in the opposite direction....got no idea....\n                var y1 = ds[i][2];\n                if (x1 + x >= 0 && x1 + x < width && y1 + y >= 0 && y1 + y < height) {\n                    var d = ds[i][0];\n                    idx = index + x1 + y1 * width;\n                    idx *= 3;\n                    data[idx] = Math.max(0, Math.min(255, data[idx] + er * d));\n                    data[idx + 1] = Math.max(0, Math.min(255, data[idx + 1] + eg * d));\n                    data[idx + 2] = Math.max(0, Math.min(255, data[idx + 2] + eb * d));\n                }\n            }\n        }\n    }\n};\n/*\n  Returns index of palette color closest to c\n*/\nGIFEncoder.prototype.findClosest = function (c, used) {\n    return this.findClosestRGB((c & 0xff0000) >> 16, (c & 0x00ff00) >> 8, c & 0x0000ff, used);\n};\nGIFEncoder.prototype.findClosestRGB = function (r, g, b, used) {\n    if (this.colorTab === null)\n        return -1;\n    if (this.neuQuant && !used) {\n        return this.neuQuant.lookupRGB(r, g, b);\n    }\n    var c = b | (g << 8) | (r << 16);\n    var minpos = 0;\n    var dmin = 256 * 256 * 256;\n    var len = this.colorTab.length;\n    for (var i = 0, index = 0; i < len; index++) {\n        var dr = r - (this.colorTab[i++] & 0xff);\n        var dg = g - (this.colorTab[i++] & 0xff);\n        var db = b - (this.colorTab[i++] & 0xff);\n        var d = dr * dr + dg * dg + db * db;\n        if ((!used || this.usedEntry[index]) && d < dmin) {\n            dmin = d;\n            minpos = index;\n        }\n    }\n    return minpos;\n};\n/*\n  Extracts image pixels into byte array pixels\n  (removes alphachannel from canvas imagedata)\n*/\nGIFEncoder.prototype.getImagePixels = function () {\n    var w = this.width;\n    var h = this.height;\n    this.pixels = new Uint8Array(w * h * 3);\n    var data = this.image;\n    var srcPos = 0;\n    var count = 0;\n    for (var i = 0; i < h; i++) {\n        for (var j = 0; j < w; j++) {\n            this.pixels[count++] = data[srcPos++];\n            this.pixels[count++] = data[srcPos++];\n            this.pixels[count++] = data[srcPos++];\n            srcPos++;\n        }\n    }\n};\n/*\n  Writes Graphic Control Extension\n*/\nGIFEncoder.prototype.writeGraphicCtrlExt = function () {\n    this.out.writeByte(0x21); // extension introducer\n    this.out.writeByte(0xf9); // GCE label\n    this.out.writeByte(4); // data block size\n    var transp, disp;\n    if (this.transparent === null) {\n        transp = 0;\n        disp = 0; // dispose = no action\n    }\n    else {\n        transp = 1;\n        disp = 2; // force clear if using transparent color\n    }\n    if (this.dispose >= 0) {\n        disp = this.dispose & 7; // user override\n    }\n    disp <<= 2;\n    // packed fields\n    this.out.writeByte(0 | // 1:3 reserved\n        disp | // 4:6 disposal\n        0 | // 7 user input - 0 = none\n        transp // 8 transparency flag\n    );\n    this.writeShort(this.delay); // delay x 1/100 sec\n    this.out.writeByte(this.transIndex); // transparent color index\n    this.out.writeByte(0); // block terminator\n};\n/*\n  Writes Image Descriptor\n*/\nGIFEncoder.prototype.writeImageDesc = function () {\n    this.out.writeByte(0x2c); // image separator\n    this.writeShort(0); // image position x,y = 0,0\n    this.writeShort(0);\n    this.writeShort(this.width); // image size\n    this.writeShort(this.height);\n    // packed fields\n    if (this.firstFrame || this.globalPalette) {\n        // no LCT - GCT is used for first (or only) frame\n        this.out.writeByte(0);\n    }\n    else {\n        // specify normal LCT\n        this.out.writeByte(0x80 | // 1 local color table 1=yes\n            0 | // 2 interlace - 0=no\n            0 | // 3 sorted - 0=no\n            0 | // 4-5 reserved\n            this.palSize // 6-8 size of color table\n        );\n    }\n};\n/*\n  Writes Logical Screen Descriptor\n*/\nGIFEncoder.prototype.writeLSD = function () {\n    // logical screen size\n    this.writeShort(this.width);\n    this.writeShort(this.height);\n    // packed fields\n    this.out.writeByte(0x80 | // 1 : global color table flag = 1 (gct used)\n        0x70 | // 2-4 : color resolution = 7\n        0x00 | // 5 : gct sort flag = 0\n        this.palSize // 6-8 : gct size\n    );\n    this.out.writeByte(0); // background color index\n    this.out.writeByte(0); // pixel aspect ratio - assume 1:1\n};\n/*\n  Writes Netscape application extension to define repeat count.\n*/\nGIFEncoder.prototype.writeNetscapeExt = function () {\n    this.out.writeByte(0x21); // extension introducer\n    this.out.writeByte(0xff); // app extension label\n    this.out.writeByte(11); // block size\n    this.out.writeUTFBytes(\"NETSCAPE2.0\"); // app id + auth code\n    this.out.writeByte(3); // sub-block size\n    this.out.writeByte(1); // loop sub-block id\n    this.writeShort(this.repeat); // loop count (extra iterations, 0=repeat forever)\n    this.out.writeByte(0); // block terminator\n};\n/*\n  Writes color table\n*/\nGIFEncoder.prototype.writePalette = function () {\n    this.out.writeBytes(this.colorTab);\n    var n = 3 * 256 - this.colorTab.length;\n    for (var i = 0; i < n; i++)\n        this.out.writeByte(0);\n};\nGIFEncoder.prototype.writeShort = function (pValue) {\n    this.out.writeByte(pValue & 0xff);\n    this.out.writeByte((pValue >> 8) & 0xff);\n};\n/*\n  Encodes and writes pixel data\n*/\nGIFEncoder.prototype.writePixels = function () {\n    var enc = new LZWEncoder(this.width, this.height, this.indexedPixels, this.colorDepth);\n    enc.encode(this.out);\n};\n/*\n  Retrieves the GIF stream\n*/\nGIFEncoder.prototype.stream = function () {\n    return this.out;\n};\nmodule.exports = GIFEncoder;\n"]},"metadata":{},"sourceType":"script"}