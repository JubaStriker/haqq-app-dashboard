{"ast":null,"code":"\"use strict\";\n/* NeuQuant Neural-Net Quantization Algorithm\n * ------------------------------------------\n *\n * Copyright (c) 1994 Anthony Dekker\n *\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994.\n * See \"Kohonen neural networks for optimal colour quantization\"\n * in \"Network: Computation in Neural Systems\" Vol. 5 (1994) pp 351-367.\n * for a discussion of the algorithm.\n * See also  http://members.ozemail.com.au/~dekker/NEUQUANT.HTML\n *\n * Any party obtaining a copy of these files from the author, directly or\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal\n * in this software and documentation files (the \"Software\"), including without\n * limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons who receive\n * copies from any such party to do so, with the only requirement being\n * that this copyright notice remain intact.\n *\n * (JavaScript port 2012 by Johan Nordberg)\n */\n\nvar ncycles = 100; // number of learning cycles\n\nvar netsize = 256; // number of colors used\n\nvar maxnetpos = netsize - 1; // defs for freq and bias\n\nvar netbiasshift = 4; // bias for colour values\n\nvar intbiasshift = 16; // bias for fractions\n\nvar intbias = 1 << intbiasshift;\nvar gammashift = 10;\nvar gamma = 1 << gammashift;\nvar betashift = 10;\nvar beta = intbias >> betashift;\n/* beta = 1/1024 */\n\nvar betagamma = intbias << gammashift - betashift; // defs for decreasing radius factor\n\nvar initrad = netsize >> 3; // for 256 cols, radius starts\n\nvar radiusbiasshift = 6; // at 32.0 biased by 6 bits\n\nvar radiusbias = 1 << radiusbiasshift;\nvar initradius = initrad * radiusbias; //and decreases by a\n\nvar radiusdec = 30; // factor of 1/30 each cycle\n// defs for decreasing alpha factor\n\nvar alphabiasshift = 10; // alpha starts at 1.0\n\nvar initalpha = 1 << alphabiasshift;\nvar alphadec; // biased by 10 bits\n\n/* radbias and alpharadbias used for radpower calculation */\n\nvar radbiasshift = 8;\nvar radbias = 1 << radbiasshift;\nvar alpharadbshift = alphabiasshift + radbiasshift;\nvar alpharadbias = 1 << alpharadbshift; // four primes near 500 - assume no image has a length so large that it is\n// divisible by all four primes\n\nvar prime1 = 499;\nvar prime2 = 491;\nvar prime3 = 487;\nvar prime4 = 503;\nvar minpicturebytes = 3 * prime4;\n/*\n  Constructor: NeuQuant\n\n  Arguments:\n\n  pixels - array of pixels in RGB format\n  samplefac - sampling factor 1 to 30 where lower is better quality\n\n  >\n  > pixels = [r, g, b, r, g, b, r, g, b, ..]\n  >\n*/\n\nfunction NeuQuant(pixels, samplefac) {\n  var network; // int[netsize][4]\n\n  var netindex; // for network lookup - really 256\n  // bias and freq arrays for learning\n\n  var bias;\n  var freq;\n  var radpower;\n  /*\n    Private Method: init\n       sets up arrays\n  */\n\n  function init() {\n    network = [];\n    netindex = new Int32Array(256);\n    bias = new Int32Array(netsize);\n    freq = new Int32Array(netsize);\n    radpower = new Int32Array(netsize >> 3);\n    var i, v;\n\n    for (i = 0; i < netsize; i++) {\n      v = (i << netbiasshift + 8) / netsize;\n      network[i] = new Float64Array([v, v, v, 0]); //network[i] = [v, v, v, 0]\n\n      freq[i] = intbias / netsize;\n      bias[i] = 0;\n    }\n  }\n  /*\n    Private Method: unbiasnet\n       unbiases network to give byte values 0..255 and record position i to prepare for sort\n  */\n\n\n  function unbiasnet() {\n    for (var i = 0; i < netsize; i++) {\n      network[i][0] >>= netbiasshift;\n      network[i][1] >>= netbiasshift;\n      network[i][2] >>= netbiasshift;\n      network[i][3] = i; // record color number\n    }\n  }\n  /*\n    Private Method: altersingle\n       moves neuron *i* towards biased (b,g,r) by factor *alpha*\n  */\n\n\n  function altersingle(alpha, i, b, g, r) {\n    network[i][0] -= alpha * (network[i][0] - b) / initalpha;\n    network[i][1] -= alpha * (network[i][1] - g) / initalpha;\n    network[i][2] -= alpha * (network[i][2] - r) / initalpha;\n  }\n  /*\n    Private Method: alterneigh\n       moves neurons in *radius* around index *i* towards biased (b,g,r) by factor *alpha*\n  */\n\n\n  function alterneigh(radius, i, b, g, r) {\n    var lo = Math.abs(i - radius);\n    var hi = Math.min(i + radius, netsize);\n    var j = i + 1;\n    var k = i - 1;\n    var m = 1;\n    var p, a;\n\n    while (j < hi || k > lo) {\n      a = radpower[m++];\n\n      if (j < hi) {\n        p = network[j++];\n        p[0] -= a * (p[0] - b) / alpharadbias;\n        p[1] -= a * (p[1] - g) / alpharadbias;\n        p[2] -= a * (p[2] - r) / alpharadbias;\n      }\n\n      if (k > lo) {\n        p = network[k--];\n        p[0] -= a * (p[0] - b) / alpharadbias;\n        p[1] -= a * (p[1] - g) / alpharadbias;\n        p[2] -= a * (p[2] - r) / alpharadbias;\n      }\n    }\n  }\n  /*\n    Private Method: contest\n       searches for biased BGR values\n  */\n\n\n  function contest(b, g, r) {\n    /*\n      finds closest neuron (min dist) and updates freq\n      finds best neuron (min dist-bias) and returns position\n      for frequently chosen neurons, freq[i] is high and bias[i] is negative\n      bias[i] = gamma * ((1 / netsize) - freq[i])\n    */\n    var bestd = ~(1 << 31);\n    var bestbiasd = bestd;\n    var bestpos = -1;\n    var bestbiaspos = bestpos;\n    var i, n, dist, biasdist, betafreq;\n\n    for (i = 0; i < netsize; i++) {\n      n = network[i];\n      dist = Math.abs(n[0] - b) + Math.abs(n[1] - g) + Math.abs(n[2] - r);\n\n      if (dist < bestd) {\n        bestd = dist;\n        bestpos = i;\n      }\n\n      biasdist = dist - (bias[i] >> intbiasshift - netbiasshift);\n\n      if (biasdist < bestbiasd) {\n        bestbiasd = biasdist;\n        bestbiaspos = i;\n      }\n\n      betafreq = freq[i] >> betashift;\n      freq[i] -= betafreq;\n      bias[i] += betafreq << gammashift;\n    }\n\n    freq[bestpos] += beta;\n    bias[bestpos] -= betagamma;\n    return bestbiaspos;\n  }\n  /*\n    Private Method: inxbuild\n       sorts network and builds netindex[0..255]\n  */\n\n\n  function inxbuild() {\n    var i,\n        j,\n        p,\n        q,\n        smallpos,\n        smallval,\n        previouscol = 0,\n        startpos = 0;\n\n    for (i = 0; i < netsize; i++) {\n      p = network[i];\n      smallpos = i;\n      smallval = p[1]; // index on g\n      // find smallest in i..netsize-1\n\n      for (j = i + 1; j < netsize; j++) {\n        q = network[j];\n\n        if (q[1] < smallval) {\n          // index on g\n          smallpos = j;\n          smallval = q[1]; // index on g\n        }\n      }\n\n      q = network[smallpos]; // swap p (i) and q (smallpos) entries\n\n      if (i != smallpos) {\n        j = q[0];\n        q[0] = p[0];\n        p[0] = j;\n        j = q[1];\n        q[1] = p[1];\n        p[1] = j;\n        j = q[2];\n        q[2] = p[2];\n        p[2] = j;\n        j = q[3];\n        q[3] = p[3];\n        p[3] = j;\n      } // smallval entry is now in position i\n\n\n      if (smallval != previouscol) {\n        netindex[previouscol] = startpos + i >> 1;\n\n        for (j = previouscol + 1; j < smallval; j++) netindex[j] = i;\n\n        previouscol = smallval;\n        startpos = i;\n      }\n    }\n\n    netindex[previouscol] = startpos + maxnetpos >> 1;\n\n    for (j = previouscol + 1; j < 256; j++) netindex[j] = maxnetpos; // really 256\n\n  }\n  /*\n    Private Method: inxsearch\n       searches for BGR values 0..255 and returns a color index\n  */\n\n\n  function inxsearch(b, g, r) {\n    var a, p, dist;\n    var bestd = 1000; // biggest possible dist is 256*3\n\n    var best = -1;\n    var i = netindex[g]; // index on g\n\n    var j = i - 1; // start at netindex[g] and work outwards\n\n    while (i < netsize || j >= 0) {\n      if (i < netsize) {\n        p = network[i];\n        dist = p[1] - g; // inx key\n\n        if (dist >= bestd) i = netsize; // stop iter\n        else {\n          i++;\n          if (dist < 0) dist = -dist;\n          a = p[0] - b;\n          if (a < 0) a = -a;\n          dist += a;\n\n          if (dist < bestd) {\n            a = p[2] - r;\n            if (a < 0) a = -a;\n            dist += a;\n\n            if (dist < bestd) {\n              bestd = dist;\n              best = p[3];\n            }\n          }\n        }\n      }\n\n      if (j >= 0) {\n        p = network[j];\n        dist = g - p[1]; // inx key - reverse dif\n\n        if (dist >= bestd) j = -1; // stop iter\n        else {\n          j--;\n          if (dist < 0) dist = -dist;\n          a = p[0] - b;\n          if (a < 0) a = -a;\n          dist += a;\n\n          if (dist < bestd) {\n            a = p[2] - r;\n            if (a < 0) a = -a;\n            dist += a;\n\n            if (dist < bestd) {\n              bestd = dist;\n              best = p[3];\n            }\n          }\n        }\n      }\n    }\n\n    return best;\n  }\n  /*\n    Private Method: learn\n       \"Main Learning Loop\"\n  */\n\n\n  function learn() {\n    var i;\n    var lengthcount = pixels.length;\n    var alphadec = 30 + (samplefac - 1) / 3;\n    var samplepixels = lengthcount / (3 * samplefac);\n    var delta = ~~(samplepixels / ncycles);\n    var alpha = initalpha;\n    var radius = initradius;\n    var rad = radius >> radiusbiasshift;\n    if (rad <= 1) rad = 0;\n\n    for (i = 0; i < rad; i++) radpower[i] = alpha * ((rad * rad - i * i) * radbias / (rad * rad));\n\n    var step;\n\n    if (lengthcount < minpicturebytes) {\n      samplefac = 1;\n      step = 3;\n    } else if (lengthcount % prime1 !== 0) {\n      step = 3 * prime1;\n    } else if (lengthcount % prime2 !== 0) {\n      step = 3 * prime2;\n    } else if (lengthcount % prime3 !== 0) {\n      step = 3 * prime3;\n    } else {\n      step = 3 * prime4;\n    }\n\n    var b, g, r, j;\n    var pix = 0; // current pixel\n\n    i = 0;\n\n    while (i < samplepixels) {\n      b = (pixels[pix] & 0xff) << netbiasshift;\n      g = (pixels[pix + 1] & 0xff) << netbiasshift;\n      r = (pixels[pix + 2] & 0xff) << netbiasshift;\n      j = contest(b, g, r);\n      altersingle(alpha, j, b, g, r);\n      if (rad !== 0) alterneigh(rad, j, b, g, r); // alter neighbours\n\n      pix += step;\n      if (pix >= lengthcount) pix -= lengthcount;\n      i++;\n      if (delta === 0) delta = 1;\n\n      if (i % delta === 0) {\n        alpha -= alpha / alphadec;\n        radius -= radius / radiusdec;\n        rad = radius >> radiusbiasshift;\n        if (rad <= 1) rad = 0;\n\n        for (j = 0; j < rad; j++) radpower[j] = alpha * ((rad * rad - j * j) * radbias / (rad * rad));\n      }\n    }\n  }\n  /*\n    Method: buildColormap\n       1. initializes network\n    2. trains it\n    3. removes misconceptions\n    4. builds colorindex\n  */\n\n\n  function buildColormap() {\n    init();\n    learn();\n    unbiasnet();\n    inxbuild();\n  }\n\n  this.buildColormap = buildColormap;\n  /*\n    Method: getColormap\n       builds colormap from the index\n       returns array in the format:\n       >\n    > [r, g, b, r, g, b, r, g, b, ..]\n    >\n  */\n\n  function getColormap() {\n    var map = [];\n    var index = [];\n\n    for (var i = 0; i < netsize; i++) index[network[i][3]] = i;\n\n    var k = 0;\n\n    for (var l = 0; l < netsize; l++) {\n      var j = index[l];\n      map[k++] = network[j][0];\n      map[k++] = network[j][1];\n      map[k++] = network[j][2];\n    }\n\n    return map;\n  }\n\n  this.getColormap = getColormap;\n  /*\n    Method: lookupRGB\n       looks for the closest *r*, *g*, *b* color in the map and\n    returns its index\n  */\n\n  this.lookupRGB = inxsearch;\n}\n\nmodule.exports = NeuQuant;","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/hbar-shop/hbar-shop-dashboard/node_modules/awesome-qr/lib/gif.js/TypedNeuQuant.js"],"names":["ncycles","netsize","maxnetpos","netbiasshift","intbiasshift","intbias","gammashift","gamma","betashift","beta","betagamma","initrad","radiusbiasshift","radiusbias","initradius","radiusdec","alphabiasshift","initalpha","alphadec","radbiasshift","radbias","alpharadbshift","alpharadbias","prime1","prime2","prime3","prime4","minpicturebytes","NeuQuant","pixels","samplefac","network","netindex","bias","freq","radpower","init","Int32Array","i","v","Float64Array","unbiasnet","altersingle","alpha","b","g","r","alterneigh","radius","lo","Math","abs","hi","min","j","k","m","p","a","contest","bestd","bestbiasd","bestpos","bestbiaspos","n","dist","biasdist","betafreq","inxbuild","q","smallpos","smallval","previouscol","startpos","inxsearch","best","learn","lengthcount","length","samplepixels","delta","rad","step","pix","buildColormap","getColormap","map","index","l","lookupRGB","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n/* NeuQuant Neural-Net Quantization Algorithm\n * ------------------------------------------\n *\n * Copyright (c) 1994 Anthony Dekker\n *\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994.\n * See \"Kohonen neural networks for optimal colour quantization\"\n * in \"Network: Computation in Neural Systems\" Vol. 5 (1994) pp 351-367.\n * for a discussion of the algorithm.\n * See also  http://members.ozemail.com.au/~dekker/NEUQUANT.HTML\n *\n * Any party obtaining a copy of these files from the author, directly or\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal\n * in this software and documentation files (the \"Software\"), including without\n * limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons who receive\n * copies from any such party to do so, with the only requirement being\n * that this copyright notice remain intact.\n *\n * (JavaScript port 2012 by Johan Nordberg)\n */\nvar ncycles = 100; // number of learning cycles\nvar netsize = 256; // number of colors used\nvar maxnetpos = netsize - 1;\n// defs for freq and bias\nvar netbiasshift = 4; // bias for colour values\nvar intbiasshift = 16; // bias for fractions\nvar intbias = (1 << intbiasshift);\nvar gammashift = 10;\nvar gamma = (1 << gammashift);\nvar betashift = 10;\nvar beta = (intbias >> betashift); /* beta = 1/1024 */\nvar betagamma = (intbias << (gammashift - betashift));\n// defs for decreasing radius factor\nvar initrad = (netsize >> 3); // for 256 cols, radius starts\nvar radiusbiasshift = 6; // at 32.0 biased by 6 bits\nvar radiusbias = (1 << radiusbiasshift);\nvar initradius = (initrad * radiusbias); //and decreases by a\nvar radiusdec = 30; // factor of 1/30 each cycle\n// defs for decreasing alpha factor\nvar alphabiasshift = 10; // alpha starts at 1.0\nvar initalpha = (1 << alphabiasshift);\nvar alphadec; // biased by 10 bits\n/* radbias and alpharadbias used for radpower calculation */\nvar radbiasshift = 8;\nvar radbias = (1 << radbiasshift);\nvar alpharadbshift = (alphabiasshift + radbiasshift);\nvar alpharadbias = (1 << alpharadbshift);\n// four primes near 500 - assume no image has a length so large that it is\n// divisible by all four primes\nvar prime1 = 499;\nvar prime2 = 491;\nvar prime3 = 487;\nvar prime4 = 503;\nvar minpicturebytes = (3 * prime4);\n/*\n  Constructor: NeuQuant\n\n  Arguments:\n\n  pixels - array of pixels in RGB format\n  samplefac - sampling factor 1 to 30 where lower is better quality\n\n  >\n  > pixels = [r, g, b, r, g, b, r, g, b, ..]\n  >\n*/\nfunction NeuQuant(pixels, samplefac) {\n    var network; // int[netsize][4]\n    var netindex; // for network lookup - really 256\n    // bias and freq arrays for learning\n    var bias;\n    var freq;\n    var radpower;\n    /*\n      Private Method: init\n  \n      sets up arrays\n    */\n    function init() {\n        network = [];\n        netindex = new Int32Array(256);\n        bias = new Int32Array(netsize);\n        freq = new Int32Array(netsize);\n        radpower = new Int32Array(netsize >> 3);\n        var i, v;\n        for (i = 0; i < netsize; i++) {\n            v = (i << (netbiasshift + 8)) / netsize;\n            network[i] = new Float64Array([v, v, v, 0]);\n            //network[i] = [v, v, v, 0]\n            freq[i] = intbias / netsize;\n            bias[i] = 0;\n        }\n    }\n    /*\n      Private Method: unbiasnet\n  \n      unbiases network to give byte values 0..255 and record position i to prepare for sort\n    */\n    function unbiasnet() {\n        for (var i = 0; i < netsize; i++) {\n            network[i][0] >>= netbiasshift;\n            network[i][1] >>= netbiasshift;\n            network[i][2] >>= netbiasshift;\n            network[i][3] = i; // record color number\n        }\n    }\n    /*\n      Private Method: altersingle\n  \n      moves neuron *i* towards biased (b,g,r) by factor *alpha*\n    */\n    function altersingle(alpha, i, b, g, r) {\n        network[i][0] -= (alpha * (network[i][0] - b)) / initalpha;\n        network[i][1] -= (alpha * (network[i][1] - g)) / initalpha;\n        network[i][2] -= (alpha * (network[i][2] - r)) / initalpha;\n    }\n    /*\n      Private Method: alterneigh\n  \n      moves neurons in *radius* around index *i* towards biased (b,g,r) by factor *alpha*\n    */\n    function alterneigh(radius, i, b, g, r) {\n        var lo = Math.abs(i - radius);\n        var hi = Math.min(i + radius, netsize);\n        var j = i + 1;\n        var k = i - 1;\n        var m = 1;\n        var p, a;\n        while ((j < hi) || (k > lo)) {\n            a = radpower[m++];\n            if (j < hi) {\n                p = network[j++];\n                p[0] -= (a * (p[0] - b)) / alpharadbias;\n                p[1] -= (a * (p[1] - g)) / alpharadbias;\n                p[2] -= (a * (p[2] - r)) / alpharadbias;\n            }\n            if (k > lo) {\n                p = network[k--];\n                p[0] -= (a * (p[0] - b)) / alpharadbias;\n                p[1] -= (a * (p[1] - g)) / alpharadbias;\n                p[2] -= (a * (p[2] - r)) / alpharadbias;\n            }\n        }\n    }\n    /*\n      Private Method: contest\n  \n      searches for biased BGR values\n    */\n    function contest(b, g, r) {\n        /*\n          finds closest neuron (min dist) and updates freq\n          finds best neuron (min dist-bias) and returns position\n          for frequently chosen neurons, freq[i] is high and bias[i] is negative\n          bias[i] = gamma * ((1 / netsize) - freq[i])\n        */\n        var bestd = ~(1 << 31);\n        var bestbiasd = bestd;\n        var bestpos = -1;\n        var bestbiaspos = bestpos;\n        var i, n, dist, biasdist, betafreq;\n        for (i = 0; i < netsize; i++) {\n            n = network[i];\n            dist = Math.abs(n[0] - b) + Math.abs(n[1] - g) + Math.abs(n[2] - r);\n            if (dist < bestd) {\n                bestd = dist;\n                bestpos = i;\n            }\n            biasdist = dist - ((bias[i]) >> (intbiasshift - netbiasshift));\n            if (biasdist < bestbiasd) {\n                bestbiasd = biasdist;\n                bestbiaspos = i;\n            }\n            betafreq = (freq[i] >> betashift);\n            freq[i] -= betafreq;\n            bias[i] += (betafreq << gammashift);\n        }\n        freq[bestpos] += beta;\n        bias[bestpos] -= betagamma;\n        return bestbiaspos;\n    }\n    /*\n      Private Method: inxbuild\n  \n      sorts network and builds netindex[0..255]\n    */\n    function inxbuild() {\n        var i, j, p, q, smallpos, smallval, previouscol = 0, startpos = 0;\n        for (i = 0; i < netsize; i++) {\n            p = network[i];\n            smallpos = i;\n            smallval = p[1]; // index on g\n            // find smallest in i..netsize-1\n            for (j = i + 1; j < netsize; j++) {\n                q = network[j];\n                if (q[1] < smallval) { // index on g\n                    smallpos = j;\n                    smallval = q[1]; // index on g\n                }\n            }\n            q = network[smallpos];\n            // swap p (i) and q (smallpos) entries\n            if (i != smallpos) {\n                j = q[0];\n                q[0] = p[0];\n                p[0] = j;\n                j = q[1];\n                q[1] = p[1];\n                p[1] = j;\n                j = q[2];\n                q[2] = p[2];\n                p[2] = j;\n                j = q[3];\n                q[3] = p[3];\n                p[3] = j;\n            }\n            // smallval entry is now in position i\n            if (smallval != previouscol) {\n                netindex[previouscol] = (startpos + i) >> 1;\n                for (j = previouscol + 1; j < smallval; j++)\n                    netindex[j] = i;\n                previouscol = smallval;\n                startpos = i;\n            }\n        }\n        netindex[previouscol] = (startpos + maxnetpos) >> 1;\n        for (j = previouscol + 1; j < 256; j++)\n            netindex[j] = maxnetpos; // really 256\n    }\n    /*\n      Private Method: inxsearch\n  \n      searches for BGR values 0..255 and returns a color index\n    */\n    function inxsearch(b, g, r) {\n        var a, p, dist;\n        var bestd = 1000; // biggest possible dist is 256*3\n        var best = -1;\n        var i = netindex[g]; // index on g\n        var j = i - 1; // start at netindex[g] and work outwards\n        while ((i < netsize) || (j >= 0)) {\n            if (i < netsize) {\n                p = network[i];\n                dist = p[1] - g; // inx key\n                if (dist >= bestd)\n                    i = netsize; // stop iter\n                else {\n                    i++;\n                    if (dist < 0)\n                        dist = -dist;\n                    a = p[0] - b;\n                    if (a < 0)\n                        a = -a;\n                    dist += a;\n                    if (dist < bestd) {\n                        a = p[2] - r;\n                        if (a < 0)\n                            a = -a;\n                        dist += a;\n                        if (dist < bestd) {\n                            bestd = dist;\n                            best = p[3];\n                        }\n                    }\n                }\n            }\n            if (j >= 0) {\n                p = network[j];\n                dist = g - p[1]; // inx key - reverse dif\n                if (dist >= bestd)\n                    j = -1; // stop iter\n                else {\n                    j--;\n                    if (dist < 0)\n                        dist = -dist;\n                    a = p[0] - b;\n                    if (a < 0)\n                        a = -a;\n                    dist += a;\n                    if (dist < bestd) {\n                        a = p[2] - r;\n                        if (a < 0)\n                            a = -a;\n                        dist += a;\n                        if (dist < bestd) {\n                            bestd = dist;\n                            best = p[3];\n                        }\n                    }\n                }\n            }\n        }\n        return best;\n    }\n    /*\n      Private Method: learn\n  \n      \"Main Learning Loop\"\n    */\n    function learn() {\n        var i;\n        var lengthcount = pixels.length;\n        var alphadec = 30 + ((samplefac - 1) / 3);\n        var samplepixels = lengthcount / (3 * samplefac);\n        var delta = ~~(samplepixels / ncycles);\n        var alpha = initalpha;\n        var radius = initradius;\n        var rad = radius >> radiusbiasshift;\n        if (rad <= 1)\n            rad = 0;\n        for (i = 0; i < rad; i++)\n            radpower[i] = alpha * (((rad * rad - i * i) * radbias) / (rad * rad));\n        var step;\n        if (lengthcount < minpicturebytes) {\n            samplefac = 1;\n            step = 3;\n        }\n        else if ((lengthcount % prime1) !== 0) {\n            step = 3 * prime1;\n        }\n        else if ((lengthcount % prime2) !== 0) {\n            step = 3 * prime2;\n        }\n        else if ((lengthcount % prime3) !== 0) {\n            step = 3 * prime3;\n        }\n        else {\n            step = 3 * prime4;\n        }\n        var b, g, r, j;\n        var pix = 0; // current pixel\n        i = 0;\n        while (i < samplepixels) {\n            b = (pixels[pix] & 0xff) << netbiasshift;\n            g = (pixels[pix + 1] & 0xff) << netbiasshift;\n            r = (pixels[pix + 2] & 0xff) << netbiasshift;\n            j = contest(b, g, r);\n            altersingle(alpha, j, b, g, r);\n            if (rad !== 0)\n                alterneigh(rad, j, b, g, r); // alter neighbours\n            pix += step;\n            if (pix >= lengthcount)\n                pix -= lengthcount;\n            i++;\n            if (delta === 0)\n                delta = 1;\n            if (i % delta === 0) {\n                alpha -= alpha / alphadec;\n                radius -= radius / radiusdec;\n                rad = radius >> radiusbiasshift;\n                if (rad <= 1)\n                    rad = 0;\n                for (j = 0; j < rad; j++)\n                    radpower[j] = alpha * (((rad * rad - j * j) * radbias) / (rad * rad));\n            }\n        }\n    }\n    /*\n      Method: buildColormap\n  \n      1. initializes network\n      2. trains it\n      3. removes misconceptions\n      4. builds colorindex\n    */\n    function buildColormap() {\n        init();\n        learn();\n        unbiasnet();\n        inxbuild();\n    }\n    this.buildColormap = buildColormap;\n    /*\n      Method: getColormap\n  \n      builds colormap from the index\n  \n      returns array in the format:\n  \n      >\n      > [r, g, b, r, g, b, r, g, b, ..]\n      >\n    */\n    function getColormap() {\n        var map = [];\n        var index = [];\n        for (var i = 0; i < netsize; i++)\n            index[network[i][3]] = i;\n        var k = 0;\n        for (var l = 0; l < netsize; l++) {\n            var j = index[l];\n            map[k++] = (network[j][0]);\n            map[k++] = (network[j][1]);\n            map[k++] = (network[j][2]);\n        }\n        return map;\n    }\n    this.getColormap = getColormap;\n    /*\n      Method: lookupRGB\n  \n      looks for the closest *r*, *g*, *b* color in the map and\n      returns its index\n    */\n    this.lookupRGB = inxsearch;\n}\nmodule.exports = NeuQuant;\n"]},"metadata":{},"sourceType":"script"}