{"ast":null,"code":"/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\nimport Status from \"../Status.js\";\nimport AccountId from \"../account/AccountId.js\";\nimport Hbar from \"../Hbar.js\";\nimport Executable, { ExecutionState } from \"../Executable.js\";\nimport TransactionId from \"../transaction/TransactionId.js\";\nimport * as HashgraphProto from \"@hashgraph/proto\";\nimport PrecheckStatusError from \"../PrecheckStatusError.js\";\nimport MaxQueryPaymentExceeded from \"../MaxQueryPaymentExceeded.js\";\nimport Long from \"long\";\nimport Logger from \"js-logger\";\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../PublicKey.js\").default} PublicKey\n */\n\n/**\n * @typedef {import(\"../client/Client.js\").ClientOperator} ClientOperator\n * @typedef {import(\"../client/Client.js\").default<*, *>} Client\n */\n\n/**\n * This registry holds a bunch of callbacks for `fromProtobuf()` implementations\n * Since this is essentially aa cache, perhaps we should move this variable into the `Cache`\n * type for consistency?\n *\n * @type {Map<HashgraphProto.proto.Query[\"query\"], (query: HashgraphProto.proto.IQuery) => Query<*>>}\n */\n\nexport const QUERY_REGISTRY = new Map();\n/**\n * Base class for all queries that can be submitted to Hedera.\n *\n * @abstract\n * @template OutputT\n * @augments {Executable<HashgraphProto.proto.IQuery, HashgraphProto.proto.IResponse, OutputT>}\n */\n\nexport default class Query extends Executable {\n  constructor() {\n    super();\n    /**\n     * The payment transaction ID\n     *\n     * @type {?TransactionId}\n     */\n\n    this._paymentTransactionId = null;\n    /**\n     * The payment transactions list where each index points to a different node\n     *\n     * @type {HashgraphProto.proto.ITransaction[]}\n     */\n\n    this._paymentTransactions = [];\n    /**\n     * The amount being paid to the node for this query.\n     * A user can set this field explicitly, or we'll query the value during execution.\n     *\n     * @type {?Hbar}\n     */\n\n    this._queryPayment = null;\n    /**\n     * The maximum query payment a user is willing to pay. Unlike `Transaction.maxTransactionFee`\n     * this field only exists in the SDK; there is no protobuf field equivalent. If and when\n     * we query the actual cost of the query and the cost is greater than the max query payment\n     * we'll throw a `MaxQueryPaymentExceeded` error.\n     *\n     * @type {?Hbar}\n     */\n\n    this._maxQueryPayment = null;\n    /**\n     * This is strictly used for `_getLogId()` which requires a timestamp. The timestamp it typically\n     * uses comes from the payment transaction ID, but that field is not set if this query is free.\n     * For those occasions we use this timestamp field generated at query construction instead.\n     *\n     * @type {number}\n     */\n\n    this._timestamp = Date.now();\n  }\n  /**\n   * Deserialize a query from bytes. The bytes should be a `proto.Query`.\n   *\n   * @template T\n   * @param {Uint8Array} bytes\n   * @returns {Query<T>}\n   */\n\n\n  static fromBytes(bytes) {\n    const query = HashgraphProto.proto.Query.decode(bytes);\n\n    if (query.query == null) {\n      throw new Error(\"(BUG) query.query was not set in the protobuf\");\n    }\n\n    const fromProtobuf =\n    /** @type {(query: HashgraphProto.proto.IQuery) => Query<T>} */\n    QUERY_REGISTRY.get(query.query);\n\n    if (fromProtobuf == null) {\n      throw new Error(`(BUG) Query.fromBytes() not implemented for type ${query.query}`);\n    }\n\n    return fromProtobuf(query);\n  }\n  /**\n   * Serialize the query into bytes.\n   *\n   * **NOTE**: Does not preserve payment transactions\n   *\n   * @returns {Uint8Array}\n   */\n\n\n  toBytes() {\n    return HashgraphProto.proto.Query.encode(this._makeRequest()).finish();\n  }\n  /**\n   * Set an explicit payment amount for this query.\n   *\n   * The client will submit exactly this amount for the payment of this query. Hedera\n   * will not return any remainder.\n   *\n   * @param {Hbar} queryPayment\n   * @returns {this}\n   */\n\n\n  setQueryPayment(queryPayment) {\n    this._queryPayment = queryPayment;\n    return this;\n  }\n  /**\n   * Set the maximum payment allowable for this query.\n   *\n   * @param {Hbar} maxQueryPayment\n   * @returns {this}\n   */\n\n\n  setMaxQueryPayment(maxQueryPayment) {\n    this._maxQueryPayment = maxQueryPayment;\n    return this;\n  }\n  /**\n   * Fetch the cost of this query from a consensus node\n   *\n   * @param {import(\"../client/Client.js\").default<Channel, *>} client\n   * @returns {Promise<Hbar>}\n   */\n\n\n  getCost(client) {\n    // The node account IDs must be set to execute a cost query\n    if (this._nodeAccountIds.isEmpty) {\n      this._nodeAccountIds.setList(client._network.getNodeAccountIdsForExecute());\n    }\n\n    if (COST_QUERY.length != 1) {\n      throw new Error(\"CostQuery has not been loaded yet\");\n    } // Change the timestamp. Should we be doing this?\n\n\n    this._timestamp = Date.now();\n    return COST_QUERY[0](this).execute(client);\n  }\n  /**\n   * Set he payment transaction explicitly\n   *\n   * @param {TransactionId} paymentTransactionId\n   * @returns {this}\n   */\n\n\n  setPaymentTransactionId(paymentTransactionId) {\n    this._paymentTransactionId = paymentTransactionId;\n    return this;\n  }\n  /**\n   * Get the payment transaction ID\n   *\n   * @returns {?TransactionId}\n   */\n\n\n  get paymentTransactionId() {\n    return this._paymentTransactionId;\n  }\n  /**\n   * Get the current transaction ID, and make sure it's not null\n   *\n   * @returns {TransactionId}\n   */\n\n\n  _getTransactionId() {\n    if (this._paymentTransactionId == null) {\n      throw new Error(\"Query.PaymentTransactionId was not set duration execution\");\n    }\n\n    return this._paymentTransactionId;\n  }\n  /**\n   * Is payment required for this query. By default most queries require payment\n   * so the default implementation returns true.\n   *\n   * @protected\n   * @returns {boolean}\n   */\n\n\n  _isPaymentRequired() {\n    return true;\n  }\n  /**\n   * Validate checksums of the query.\n   *\n   * @param {Client} client\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/no-empty-function\n\n\n  _validateChecksums(client) {// Shouldn't we be checking `paymentTransactionId` here sine it contains an `accountId`?\n    // Do nothing\n  }\n  /**\n   * Before we proceed exeuction, we need to do a couple checks\n   *\n   * @template MirrorChannelT\n   * @param {import(\"../client/Client.js\").default<Channel, MirrorChannelT>} client\n   * @returns {Promise<void>}\n   */\n\n\n  async _beforeExecute(client) {\n    // If we're executing this query multiple times the the payment transaction ID list\n    // will already be set\n    if (this._paymentTransactions.length > 0) {\n      return;\n    } // Check checksums if enabled\n\n\n    if (client.isAutoValidateChecksumsEnabled()) {\n      this._validateChecksums(client);\n    } // If the nodes aren't set, set them.\n\n\n    if (this._nodeAccountIds.isEmpty) {\n      this._nodeAccountIds.setList(client._network.getNodeAccountIdsForExecute());\n    } // Save the operator\n\n\n    this._operator = this._operator != null ? this._operator : client._operator; // If the payment transaction ID is not set\n\n    if (this._paymentTransactionId == null) {\n      // And payment is required\n      if (this._isPaymentRequired()) {\n        // And the client has an operator\n        if (this._operator != null) {\n          // Generate the payment transaction ID\n          this._paymentTransactionId = TransactionId.generate(this._operator.accountId);\n        } else {\n          // If payment is required, but an operator did not exist, throw an error\n          throw new Error(\"`client` must have an `operator` or an explicit payment transaction must be provided\");\n        }\n      } else {\n        // If the payment transaction ID is not set, but this query doesn't require a payment\n        // set the payment transaction ID to an empty transaction ID.\n        // FIXME: Should use `TransactionId.withValidStart()` instead\n        this._paymentTransactionId = TransactionId.generate(new AccountId(0));\n      }\n    }\n\n    let cost = new Hbar(0);\n    const maxQueryPayment = this._maxQueryPayment != null ? this._maxQueryPayment : client.maxQueryPayment;\n\n    if (this._queryPayment != null) {\n      cost = this._queryPayment;\n    } else if (this._paymentTransactions.length === 0 && this._isPaymentRequired()) {\n      // If the query payment was not explictly set, fetch the actual cost.\n      const actualCost = await this.getCost(client); // Confirm it's less than max query payment\n\n      if (maxQueryPayment.toTinybars().toInt() < actualCost.toTinybars().toInt()) {\n        throw new MaxQueryPaymentExceeded(actualCost, maxQueryPayment);\n      }\n\n      cost = actualCost;\n      Logger.debug(`[${this._getLogId()}] received cost for query ${cost.toString()}`);\n    } // Set the either queried cost, or the original value back into `queryPayment`\n    // in case a user executes same query multiple times. However, users should\n    // really not be executing the same query multiple times meaning this is\n    // typically not needed.\n\n\n    this._queryPayment = cost; // Not sure if we should be overwritting this field tbh.\n\n    this._timestamp = Date.now();\n\n    if (!this._nodeAccountIds.locked) {\n      return;\n    } // Generate the payment transactions\n\n\n    for (const node of this._nodeAccountIds.list) {\n      this._paymentTransactions.push(await _makePaymentTransaction(this._getLogId(),\n      /** @type {import(\"../transaction/TransactionId.js\").default} */\n      this._paymentTransactionId, node, this._isPaymentRequired() ? this._operator : null,\n      /** @type {Hbar} */\n      cost));\n    }\n  }\n  /**\n   * @abstract\n   * @internal\n   * @param {HashgraphProto.proto.IResponse} response\n   * @returns {HashgraphProto.proto.IResponseHeader}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _mapResponseHeader(response) {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * @protected\n   * @returns {HashgraphProto.proto.IQueryHeader}\n   */\n\n\n  _makeRequestHeader() {\n    /** @type {HashgraphProto.proto.IQueryHeader} */\n    let header = {};\n\n    if (this._isPaymentRequired() && this._paymentTransactions.length > 0) {\n      header = {\n        responseType: HashgraphProto.proto.ResponseType.ANSWER_ONLY,\n        payment: this._paymentTransactions[this._nodeAccountIds.index]\n      };\n    }\n\n    return header;\n  }\n  /**\n   * @abstract\n   * @internal\n   * @param {HashgraphProto.proto.IQueryHeader} header\n   * @returns {HashgraphProto.proto.IQuery}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _onMakeRequest(header) {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * @internal\n   * @returns {HashgraphProto.proto.IQuery}\n   */\n\n\n  _makeRequest() {\n    /** @type {HashgraphProto.proto.IQueryHeader} */\n    let header = {};\n\n    if (this._isPaymentRequired() && this._paymentTransactions != null) {\n      header = {\n        payment: this._paymentTransactions[this._nodeAccountIds.index],\n        responseType: HashgraphProto.proto.ResponseType.ANSWER_ONLY\n      };\n    }\n\n    return this._onMakeRequest(header);\n  }\n  /**\n   * @override\n   * @internal\n   * @returns {Promise<HashgraphProto.proto.IQuery>}\n   */\n\n\n  async _makeRequestAsync() {\n    /** @type {HashgraphProto.proto.IQueryHeader} */\n    let header = {\n      responseType: HashgraphProto.proto.ResponseType.ANSWER_ONLY\n    };\n\n    if (this._isPaymentRequired() && this._paymentTransactions != null) {\n      if (this._nodeAccountIds.locked) {\n        header.payment = this._paymentTransactions[this._nodeAccountIds.index];\n      } else {\n        header.payment = await _makePaymentTransaction(this._getLogId(),\n        /** @type {import(\"../transaction/TransactionId.js\").default} */\n        this._paymentTransactionId, this._nodeAccountIds.current, this._isPaymentRequired() ? this._operator : null,\n        /** @type {Hbar} */\n        this._queryPayment);\n      }\n    }\n\n    return this._onMakeRequest(header);\n  }\n  /**\n   * @override\n   * @internal\n   * @param {HashgraphProto.proto.IQuery} request\n   * @param {HashgraphProto.proto.IResponse} response\n   * @returns {[Status, ExecutionState]}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _shouldRetry(request, response) {\n    const {\n      nodeTransactionPrecheckCode\n    } = this._mapResponseHeader(response);\n\n    const status = Status._fromCode(nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : HashgraphProto.proto.ResponseCodeEnum.OK);\n\n    Logger.debug(`[${this._getLogId()}] received status ${status.toString()}`);\n\n    switch (status) {\n      case Status.Busy:\n      case Status.Unknown:\n      case Status.PlatformTransactionNotCreated:\n        return [status, ExecutionState.Retry];\n\n      case Status.Ok:\n        return [status, ExecutionState.Finished];\n\n      default:\n        return [status, ExecutionState.Error];\n    }\n  }\n  /**\n   * @override\n   * @internal\n   * @param {HashgraphProto.proto.IQuery} request\n   * @param {HashgraphProto.proto.IResponse} response\n   * @returns {Error}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _mapStatusError(request, response) {\n    const {\n      nodeTransactionPrecheckCode\n    } = this._mapResponseHeader(response);\n\n    const status = Status._fromCode(nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : HashgraphProto.proto.ResponseCodeEnum.OK);\n\n    return new PrecheckStatusError({\n      status,\n      transactionId: this._getTransactionId()\n    });\n  }\n  /**\n   * @param {HashgraphProto.proto.Query} request\n   * @returns {Uint8Array}\n   */\n\n\n  _requestToBytes(request) {\n    return HashgraphProto.proto.Query.encode(request).finish();\n  }\n  /**\n   * @param {HashgraphProto.proto.Response} response\n   * @returns {Uint8Array}\n   */\n\n\n  _responseToBytes(response) {\n    return HashgraphProto.proto.Response.encode(response).finish();\n  }\n\n}\n/**\n * Generate a payment transaction given, aka. `TransferTransaction`\n *\n * @param {string} logId\n * @param {TransactionId} paymentTransactionId\n * @param {AccountId} nodeId\n * @param {?ClientOperator} operator\n * @param {Hbar} paymentAmount\n * @returns {Promise<HashgraphProto.proto.ITransaction>}\n */\n\nexport async function _makePaymentTransaction(logId, paymentTransactionId, nodeId, operator, paymentAmount) {\n  Logger.debug(`[${logId}] making a payment transaction for node ${nodeId.toString()} and transaction ID ${paymentTransactionId.toString()} with amount ${paymentAmount.toString()}`);\n  const accountAmounts = []; // If an operator is provided then we should make sure we transfer\n  // from the operator to the node.\n  // If an operator is not provided we simply create an effectively\n  // empty account amounts\n\n  if (operator != null) {\n    accountAmounts.push({\n      accountID: operator.accountId._toProtobuf(),\n      amount: paymentAmount.negated().toTinybars()\n    });\n    accountAmounts.push({\n      accountID: nodeId._toProtobuf(),\n      amount: paymentAmount.toTinybars()\n    });\n  } else {\n    accountAmounts.push({\n      accountID: new AccountId(0)._toProtobuf(),\n      // If the account ID is 0, shouldn't we just hard\n      // code this value to 0? Same for the latter.\n      amount: paymentAmount.negated().toTinybars()\n    });\n    accountAmounts.push({\n      accountID: nodeId._toProtobuf(),\n      amount: paymentAmount.toTinybars()\n    });\n  }\n  /**\n   * @type {HashgraphProto.proto.ITransactionBody}\n   */\n\n\n  const body = {\n    transactionID: paymentTransactionId._toProtobuf(),\n    nodeAccountID: nodeId._toProtobuf(),\n    transactionFee: new Hbar(1).toTinybars(),\n    transactionValidDuration: {\n      seconds: Long.fromNumber(120)\n    },\n    cryptoTransfer: {\n      transfers: {\n        accountAmounts\n      }\n    }\n  };\n  /** @type {HashgraphProto.proto.ISignedTransaction} */\n\n  const signedTransaction = {\n    bodyBytes: HashgraphProto.proto.TransactionBody.encode(body).finish()\n  }; // Sign the transaction if an operator is provided\n  //\n  // We have _several_ places where we build the transactions, maybe this is\n  // something we can deduplicate?\n\n  if (operator != null) {\n    const signature = await operator.transactionSigner(\n    /** @type {Uint8Array} */\n    signedTransaction.bodyBytes);\n    signedTransaction.sigMap = {\n      sigPair: [operator.publicKey._toProtobufSignature(signature)]\n    };\n  } // Create and return a `proto.Transaction`\n\n\n  return {\n    signedTransactionBytes: HashgraphProto.proto.SignedTransaction.encode(signedTransaction).finish()\n  };\n}\n/**\n * Cache for the cost query constructor. This prevents cyclic dependencies.\n *\n * @type {((query: Query<*>) => import(\"./CostQuery.js\").default<*>)[]}\n */\n\nexport const COST_QUERY = [];","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/hbar-shop/hbar-shopify-coupon-client/node_modules/@hashgraph/sdk/src/query/Query.js"],"names":["Status","AccountId","Hbar","Executable","ExecutionState","TransactionId","HashgraphProto","PrecheckStatusError","MaxQueryPaymentExceeded","Long","Logger","QUERY_REGISTRY","Map","Query","constructor","_paymentTransactionId","_paymentTransactions","_queryPayment","_maxQueryPayment","_timestamp","Date","now","fromBytes","bytes","query","proto","decode","Error","fromProtobuf","get","toBytes","encode","_makeRequest","finish","setQueryPayment","queryPayment","setMaxQueryPayment","maxQueryPayment","getCost","client","_nodeAccountIds","isEmpty","setList","_network","getNodeAccountIdsForExecute","COST_QUERY","length","execute","setPaymentTransactionId","paymentTransactionId","_getTransactionId","_isPaymentRequired","_validateChecksums","_beforeExecute","isAutoValidateChecksumsEnabled","_operator","generate","accountId","cost","actualCost","toTinybars","toInt","debug","_getLogId","toString","locked","node","list","push","_makePaymentTransaction","_mapResponseHeader","response","_makeRequestHeader","header","responseType","ResponseType","ANSWER_ONLY","payment","index","_onMakeRequest","_makeRequestAsync","current","_shouldRetry","request","nodeTransactionPrecheckCode","status","_fromCode","ResponseCodeEnum","OK","Busy","Unknown","PlatformTransactionNotCreated","Retry","Ok","Finished","_mapStatusError","transactionId","_requestToBytes","_responseToBytes","Response","logId","nodeId","operator","paymentAmount","accountAmounts","accountID","_toProtobuf","amount","negated","body","transactionID","nodeAccountID","transactionFee","transactionValidDuration","seconds","fromNumber","cryptoTransfer","transfers","signedTransaction","bodyBytes","TransactionBody","signature","transactionSigner","sigMap","sigPair","publicKey","_toProtobufSignature","signedTransactionBytes","SignedTransaction"],"mappings":"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","sourcesContent":["/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\n\nimport Status from \"../Status.js\";\nimport AccountId from \"../account/AccountId.js\";\nimport Hbar from \"../Hbar.js\";\nimport Executable, { ExecutionState } from \"../Executable.js\";\nimport TransactionId from \"../transaction/TransactionId.js\";\nimport * as HashgraphProto from \"@hashgraph/proto\";\nimport PrecheckStatusError from \"../PrecheckStatusError.js\";\nimport MaxQueryPaymentExceeded from \"../MaxQueryPaymentExceeded.js\";\nimport Long from \"long\";\nimport Logger from \"js-logger\";\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../PublicKey.js\").default} PublicKey\n */\n\n/**\n * @typedef {import(\"../client/Client.js\").ClientOperator} ClientOperator\n * @typedef {import(\"../client/Client.js\").default<*, *>} Client\n */\n\n/**\n * This registry holds a bunch of callbacks for `fromProtobuf()` implementations\n * Since this is essentially aa cache, perhaps we should move this variable into the `Cache`\n * type for consistency?\n *\n * @type {Map<HashgraphProto.proto.Query[\"query\"], (query: HashgraphProto.proto.IQuery) => Query<*>>}\n */\nexport const QUERY_REGISTRY = new Map();\n\n/**\n * Base class for all queries that can be submitted to Hedera.\n *\n * @abstract\n * @template OutputT\n * @augments {Executable<HashgraphProto.proto.IQuery, HashgraphProto.proto.IResponse, OutputT>}\n */\nexport default class Query extends Executable {\n    constructor() {\n        super();\n\n        /**\n         * The payment transaction ID\n         *\n         * @type {?TransactionId}\n         */\n        this._paymentTransactionId = null;\n\n        /**\n         * The payment transactions list where each index points to a different node\n         *\n         * @type {HashgraphProto.proto.ITransaction[]}\n         */\n        this._paymentTransactions = [];\n\n        /**\n         * The amount being paid to the node for this query.\n         * A user can set this field explicitly, or we'll query the value during execution.\n         *\n         * @type {?Hbar}\n         */\n        this._queryPayment = null;\n\n        /**\n         * The maximum query payment a user is willing to pay. Unlike `Transaction.maxTransactionFee`\n         * this field only exists in the SDK; there is no protobuf field equivalent. If and when\n         * we query the actual cost of the query and the cost is greater than the max query payment\n         * we'll throw a `MaxQueryPaymentExceeded` error.\n         *\n         * @type {?Hbar}\n         */\n        this._maxQueryPayment = null;\n\n        /**\n         * This is strictly used for `_getLogId()` which requires a timestamp. The timestamp it typically\n         * uses comes from the payment transaction ID, but that field is not set if this query is free.\n         * For those occasions we use this timestamp field generated at query construction instead.\n         *\n         * @type {number}\n         */\n        this._timestamp = Date.now();\n    }\n\n    /**\n     * Deserialize a query from bytes. The bytes should be a `proto.Query`.\n     *\n     * @template T\n     * @param {Uint8Array} bytes\n     * @returns {Query<T>}\n     */\n    static fromBytes(bytes) {\n        const query = HashgraphProto.proto.Query.decode(bytes);\n\n        if (query.query == null) {\n            throw new Error(\"(BUG) query.query was not set in the protobuf\");\n        }\n\n        const fromProtobuf =\n            /** @type {(query: HashgraphProto.proto.IQuery) => Query<T>} */ (\n                QUERY_REGISTRY.get(query.query)\n            );\n\n        if (fromProtobuf == null) {\n            throw new Error(\n                `(BUG) Query.fromBytes() not implemented for type ${query.query}`\n            );\n        }\n\n        return fromProtobuf(query);\n    }\n\n    /**\n     * Serialize the query into bytes.\n     *\n     * **NOTE**: Does not preserve payment transactions\n     *\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        return HashgraphProto.proto.Query.encode(this._makeRequest()).finish();\n    }\n\n    /**\n     * Set an explicit payment amount for this query.\n     *\n     * The client will submit exactly this amount for the payment of this query. Hedera\n     * will not return any remainder.\n     *\n     * @param {Hbar} queryPayment\n     * @returns {this}\n     */\n    setQueryPayment(queryPayment) {\n        this._queryPayment = queryPayment;\n\n        return this;\n    }\n\n    /**\n     * Set the maximum payment allowable for this query.\n     *\n     * @param {Hbar} maxQueryPayment\n     * @returns {this}\n     */\n    setMaxQueryPayment(maxQueryPayment) {\n        this._maxQueryPayment = maxQueryPayment;\n\n        return this;\n    }\n\n    /**\n     * Fetch the cost of this query from a consensus node\n     *\n     * @param {import(\"../client/Client.js\").default<Channel, *>} client\n     * @returns {Promise<Hbar>}\n     */\n    getCost(client) {\n        // The node account IDs must be set to execute a cost query\n        if (this._nodeAccountIds.isEmpty) {\n            this._nodeAccountIds.setList(\n                client._network.getNodeAccountIdsForExecute()\n            );\n        }\n\n        if (COST_QUERY.length != 1) {\n            throw new Error(\"CostQuery has not been loaded yet\");\n        }\n\n        // Change the timestamp. Should we be doing this?\n        this._timestamp = Date.now();\n\n        return COST_QUERY[0](this).execute(client);\n    }\n\n    /**\n     * Set he payment transaction explicitly\n     *\n     * @param {TransactionId} paymentTransactionId\n     * @returns {this}\n     */\n    setPaymentTransactionId(paymentTransactionId) {\n        this._paymentTransactionId = paymentTransactionId;\n        return this;\n    }\n\n    /**\n     * Get the payment transaction ID\n     *\n     * @returns {?TransactionId}\n     */\n    get paymentTransactionId() {\n        return this._paymentTransactionId;\n    }\n\n    /**\n     * Get the current transaction ID, and make sure it's not null\n     *\n     * @returns {TransactionId}\n     */\n    _getTransactionId() {\n        if (this._paymentTransactionId == null) {\n            throw new Error(\n                \"Query.PaymentTransactionId was not set duration execution\"\n            );\n        }\n\n        return this._paymentTransactionId;\n    }\n\n    /**\n     * Is payment required for this query. By default most queries require payment\n     * so the default implementation returns true.\n     *\n     * @protected\n     * @returns {boolean}\n     */\n    _isPaymentRequired() {\n        return true;\n    }\n\n    /**\n     * Validate checksums of the query.\n     *\n     * @param {Client} client\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/no-empty-function\n    _validateChecksums(client) {\n        // Shouldn't we be checking `paymentTransactionId` here sine it contains an `accountId`?\n        // Do nothing\n    }\n\n    /**\n     * Before we proceed exeuction, we need to do a couple checks\n     *\n     * @template MirrorChannelT\n     * @param {import(\"../client/Client.js\").default<Channel, MirrorChannelT>} client\n     * @returns {Promise<void>}\n     */\n    async _beforeExecute(client) {\n        // If we're executing this query multiple times the the payment transaction ID list\n        // will already be set\n        if (this._paymentTransactions.length > 0) {\n            return;\n        }\n\n        // Check checksums if enabled\n        if (client.isAutoValidateChecksumsEnabled()) {\n            this._validateChecksums(client);\n        }\n\n        // If the nodes aren't set, set them.\n        if (this._nodeAccountIds.isEmpty) {\n            this._nodeAccountIds.setList(\n                client._network.getNodeAccountIdsForExecute()\n            );\n        }\n\n        // Save the operator\n        this._operator =\n            this._operator != null ? this._operator : client._operator;\n\n        // If the payment transaction ID is not set\n        if (this._paymentTransactionId == null) {\n            // And payment is required\n            if (this._isPaymentRequired()) {\n                // And the client has an operator\n                if (this._operator != null) {\n                    // Generate the payment transaction ID\n                    this._paymentTransactionId = TransactionId.generate(\n                        this._operator.accountId\n                    );\n                } else {\n                    // If payment is required, but an operator did not exist, throw an error\n                    throw new Error(\n                        \"`client` must have an `operator` or an explicit payment transaction must be provided\"\n                    );\n                }\n            } else {\n                // If the payment transaction ID is not set, but this query doesn't require a payment\n                // set the payment transaction ID to an empty transaction ID.\n                // FIXME: Should use `TransactionId.withValidStart()` instead\n                this._paymentTransactionId = TransactionId.generate(\n                    new AccountId(0)\n                );\n            }\n        }\n\n        let cost = new Hbar(0);\n\n        const maxQueryPayment =\n            this._maxQueryPayment != null\n                ? this._maxQueryPayment\n                : client.maxQueryPayment;\n\n        if (this._queryPayment != null) {\n            cost = this._queryPayment;\n        } else if (\n            this._paymentTransactions.length === 0 &&\n            this._isPaymentRequired()\n        ) {\n            // If the query payment was not explictly set, fetch the actual cost.\n            const actualCost = await this.getCost(client);\n\n            // Confirm it's less than max query payment\n            if (\n                maxQueryPayment.toTinybars().toInt() <\n                actualCost.toTinybars().toInt()\n            ) {\n                throw new MaxQueryPaymentExceeded(actualCost, maxQueryPayment);\n            }\n\n            cost = actualCost;\n            Logger.debug(\n                `[${this._getLogId()}] received cost for query ${cost.toString()}`\n            );\n        }\n\n        // Set the either queried cost, or the original value back into `queryPayment`\n        // in case a user executes same query multiple times. However, users should\n        // really not be executing the same query multiple times meaning this is\n        // typically not needed.\n        this._queryPayment = cost;\n\n        // Not sure if we should be overwritting this field tbh.\n        this._timestamp = Date.now();\n\n        if (!this._nodeAccountIds.locked) {\n            return;\n        }\n\n        // Generate the payment transactions\n        for (const node of this._nodeAccountIds.list) {\n            this._paymentTransactions.push(\n                await _makePaymentTransaction(\n                    this._getLogId(),\n                    /** @type {import(\"../transaction/TransactionId.js\").default} */ (\n                        this._paymentTransactionId\n                    ),\n                    node,\n                    this._isPaymentRequired() ? this._operator : null,\n                    /** @type {Hbar} */ (cost)\n                )\n            );\n        }\n    }\n\n    /**\n     * @abstract\n     * @internal\n     * @param {HashgraphProto.proto.IResponse} response\n     * @returns {HashgraphProto.proto.IResponseHeader}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _mapResponseHeader(response) {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * @protected\n     * @returns {HashgraphProto.proto.IQueryHeader}\n     */\n    _makeRequestHeader() {\n        /** @type {HashgraphProto.proto.IQueryHeader} */\n        let header = {};\n\n        if (this._isPaymentRequired() && this._paymentTransactions.length > 0) {\n            header = {\n                responseType: HashgraphProto.proto.ResponseType.ANSWER_ONLY,\n                payment: this._paymentTransactions[this._nodeAccountIds.index],\n            };\n        }\n\n        return header;\n    }\n\n    /**\n     * @abstract\n     * @internal\n     * @param {HashgraphProto.proto.IQueryHeader} header\n     * @returns {HashgraphProto.proto.IQuery}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _onMakeRequest(header) {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * @internal\n     * @returns {HashgraphProto.proto.IQuery}\n     */\n    _makeRequest() {\n        /** @type {HashgraphProto.proto.IQueryHeader} */\n        let header = {};\n\n        if (this._isPaymentRequired() && this._paymentTransactions != null) {\n            header = {\n                payment: this._paymentTransactions[this._nodeAccountIds.index],\n                responseType: HashgraphProto.proto.ResponseType.ANSWER_ONLY,\n            };\n        }\n\n        return this._onMakeRequest(header);\n    }\n\n    /**\n     * @override\n     * @internal\n     * @returns {Promise<HashgraphProto.proto.IQuery>}\n     */\n    async _makeRequestAsync() {\n        /** @type {HashgraphProto.proto.IQueryHeader} */\n        let header = {\n            responseType: HashgraphProto.proto.ResponseType.ANSWER_ONLY,\n        };\n\n        if (this._isPaymentRequired() && this._paymentTransactions != null) {\n            if (this._nodeAccountIds.locked) {\n                header.payment =\n                    this._paymentTransactions[this._nodeAccountIds.index];\n            } else {\n                header.payment = await _makePaymentTransaction(\n                    this._getLogId(),\n                    /** @type {import(\"../transaction/TransactionId.js\").default} */ (\n                        this._paymentTransactionId\n                    ),\n                    this._nodeAccountIds.current,\n                    this._isPaymentRequired() ? this._operator : null,\n                    /** @type {Hbar} */ (this._queryPayment)\n                );\n            }\n        }\n\n        return this._onMakeRequest(header);\n    }\n\n    /**\n     * @override\n     * @internal\n     * @param {HashgraphProto.proto.IQuery} request\n     * @param {HashgraphProto.proto.IResponse} response\n     * @returns {[Status, ExecutionState]}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _shouldRetry(request, response) {\n        const { nodeTransactionPrecheckCode } =\n            this._mapResponseHeader(response);\n\n        const status = Status._fromCode(\n            nodeTransactionPrecheckCode != null\n                ? nodeTransactionPrecheckCode\n                : HashgraphProto.proto.ResponseCodeEnum.OK\n        );\n\n        Logger.debug(\n            `[${this._getLogId()}] received status ${status.toString()}`\n        );\n\n        switch (status) {\n            case Status.Busy:\n            case Status.Unknown:\n            case Status.PlatformTransactionNotCreated:\n                return [status, ExecutionState.Retry];\n            case Status.Ok:\n                return [status, ExecutionState.Finished];\n            default:\n                return [status, ExecutionState.Error];\n        }\n    }\n\n    /**\n     * @override\n     * @internal\n     * @param {HashgraphProto.proto.IQuery} request\n     * @param {HashgraphProto.proto.IResponse} response\n     * @returns {Error}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _mapStatusError(request, response) {\n        const { nodeTransactionPrecheckCode } =\n            this._mapResponseHeader(response);\n\n        const status = Status._fromCode(\n            nodeTransactionPrecheckCode != null\n                ? nodeTransactionPrecheckCode\n                : HashgraphProto.proto.ResponseCodeEnum.OK\n        );\n\n        return new PrecheckStatusError({\n            status,\n            transactionId: this._getTransactionId(),\n        });\n    }\n\n    /**\n     * @param {HashgraphProto.proto.Query} request\n     * @returns {Uint8Array}\n     */\n    _requestToBytes(request) {\n        return HashgraphProto.proto.Query.encode(request).finish();\n    }\n\n    /**\n     * @param {HashgraphProto.proto.Response} response\n     * @returns {Uint8Array}\n     */\n    _responseToBytes(response) {\n        return HashgraphProto.proto.Response.encode(response).finish();\n    }\n}\n\n/**\n * Generate a payment transaction given, aka. `TransferTransaction`\n *\n * @param {string} logId\n * @param {TransactionId} paymentTransactionId\n * @param {AccountId} nodeId\n * @param {?ClientOperator} operator\n * @param {Hbar} paymentAmount\n * @returns {Promise<HashgraphProto.proto.ITransaction>}\n */\nexport async function _makePaymentTransaction(\n    logId,\n    paymentTransactionId,\n    nodeId,\n    operator,\n    paymentAmount\n) {\n    Logger.debug(\n        `[${logId}] making a payment transaction for node ${nodeId.toString()} and transaction ID ${paymentTransactionId.toString()} with amount ${paymentAmount.toString()}`\n    );\n    const accountAmounts = [];\n\n    // If an operator is provided then we should make sure we transfer\n    // from the operator to the node.\n    // If an operator is not provided we simply create an effectively\n    // empty account amounts\n    if (operator != null) {\n        accountAmounts.push({\n            accountID: operator.accountId._toProtobuf(),\n            amount: paymentAmount.negated().toTinybars(),\n        });\n        accountAmounts.push({\n            accountID: nodeId._toProtobuf(),\n            amount: paymentAmount.toTinybars(),\n        });\n    } else {\n        accountAmounts.push({\n            accountID: new AccountId(0)._toProtobuf(),\n            // If the account ID is 0, shouldn't we just hard\n            // code this value to 0? Same for the latter.\n            amount: paymentAmount.negated().toTinybars(),\n        });\n        accountAmounts.push({\n            accountID: nodeId._toProtobuf(),\n            amount: paymentAmount.toTinybars(),\n        });\n    }\n    /**\n     * @type {HashgraphProto.proto.ITransactionBody}\n     */\n    const body = {\n        transactionID: paymentTransactionId._toProtobuf(),\n        nodeAccountID: nodeId._toProtobuf(),\n        transactionFee: new Hbar(1).toTinybars(),\n        transactionValidDuration: {\n            seconds: Long.fromNumber(120),\n        },\n        cryptoTransfer: {\n            transfers: {\n                accountAmounts,\n            },\n        },\n    };\n\n    /** @type {HashgraphProto.proto.ISignedTransaction} */\n    const signedTransaction = {\n        bodyBytes: HashgraphProto.proto.TransactionBody.encode(body).finish(),\n    };\n\n    // Sign the transaction if an operator is provided\n    //\n    // We have _several_ places where we build the transactions, maybe this is\n    // something we can deduplicate?\n    if (operator != null) {\n        const signature = await operator.transactionSigner(\n            /** @type {Uint8Array} */ (signedTransaction.bodyBytes)\n        );\n\n        signedTransaction.sigMap = {\n            sigPair: [operator.publicKey._toProtobufSignature(signature)],\n        };\n    }\n\n    // Create and return a `proto.Transaction`\n    return {\n        signedTransactionBytes:\n            HashgraphProto.proto.SignedTransaction.encode(\n                signedTransaction\n            ).finish(),\n    };\n}\n\n/**\n * Cache for the cost query constructor. This prevents cyclic dependencies.\n *\n * @type {((query: Query<*>) => import(\"./CostQuery.js\").default<*>)[]}\n */\nexport const COST_QUERY = [];\n"]},"metadata":{},"sourceType":"module"}