{"ast":null,"code":"/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\nimport ManagedNodeAddress from \"./ManagedNodeAddress.js\";\n/**\n * @typedef {import(\"./account/AccountId.js\").default} AccountId\n * @typedef {import(\"./channel/Channel.js\").default} Channel\n * @typedef {import(\"./channel/MirrorChannel.js\").default} MirrorChannel\n * @typedef {import(\"./address_book/NodeAddress.js\").default} NodeAddress\n */\n\n/**\n * @template {Channel | MirrorChannel} ChannelT\n * @typedef {object} NewNode\n * @property {string | ManagedNodeAddress} address\n * @property {(address: string, cert?: string) => ChannelT} channelInitFunction\n */\n\n/**\n * @template {Channel | MirrorChannel} ChannelT\n * @typedef {object} CloneNode\n * @property {ManagedNode<ChannelT>} node\n * @property {ManagedNodeAddress} address\n */\n\n/**\n * @abstract\n * @template {Channel | MirrorChannel} ChannelT\n */\n\nexport default class ManagedNode {\n  /**\n   * @param {object} props\n   * @param {NewNode<ChannelT>=} [props.newNode]\n   * @param {CloneNode<ChannelT>=} [props.cloneNode]\n   */\n  constructor() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (props.newNode != null) {\n      this._address = typeof props.newNode.address === \"string\" ? ManagedNodeAddress.fromString(props.newNode.address) : props.newNode.address;\n      /** @type {string=} */\n\n      this._cert = undefined;\n      /** @type {ChannelT | null} */\n\n      this._channel = null;\n      /** @type {(address: string, cert?: string) => ChannelT} */\n\n      this._channelInitFunction = props.newNode.channelInitFunction;\n      this._lastUsed = Date.now();\n      this._readmitTime = Date.now();\n      this._useCount = 0;\n      this._badGrpcStatusCount = 0;\n      this._minBackoff = 8000;\n      this._maxBackoff = 1000 * 60 * 60;\n      this._currentBackoff = this._minBackoff;\n    } else if (props.cloneNode != null) {\n      /** @type {ManagedNodeAddress} */\n      this._address = props.cloneNode.address;\n      /** @type {string=} */\n\n      this._cert = props.cloneNode.node._cert;\n      /** @type {ChannelT | null} */\n\n      this._channel = props.cloneNode.node._channel;\n      /** @type {(address: string, cert?: string) => ChannelT} */\n\n      this._channelInitFunction = props.cloneNode.node._channelInitFunction;\n      /** @type {number} */\n\n      this._currentBackoff = props.cloneNode.node._currentBackoff;\n      /** @type {number} */\n\n      this._lastUsed = props.cloneNode.node._lastUsed;\n      /** @type {number} */\n\n      this._readmitTime = props.cloneNode.node._readmitTime;\n      /** @type {number} */\n\n      this._useCount = props.cloneNode.node._useCount;\n      /** @type {number} */\n\n      this._badGrpcStatusCount = props.cloneNode.node._badGrpcStatusCount;\n      /** @type {number} */\n\n      this._minBackoff = props.cloneNode.node._minBackoff;\n      /** @type {number} */\n\n      this._maxBackoff = props.cloneNode.node._minBackoff;\n    } else {\n      throw new Error(`failed to create ManagedNode: ${JSON.stringify(props)}`);\n    }\n  }\n  /**\n   * @abstract\n   * @returns {string}\n   */\n  // eslint-disable-next-line jsdoc/require-returns-check\n\n\n  getKey() {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * @abstract\n   * @returns {ManagedNode<ChannelT>}\n   */\n  // eslint-disable-next-line jsdoc/require-returns-check\n\n\n  toInsecure() {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * @abstract\n   * @returns {ManagedNode<ChannelT>}\n   */\n  // eslint-disable-next-line jsdoc/require-returns-check\n\n\n  toSecure() {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * @param {string} ledgerId\n   * @returns {this}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  setCert(ledgerId) {\n    return this;\n  }\n  /**\n   * @returns {ManagedNodeAddress}\n   */\n\n\n  get address() {\n    return this._address;\n  }\n  /**\n   * @returns {number}\n   */\n\n\n  get attempts() {\n    return this._badGrpcStatusCount;\n  }\n  /**\n   * @returns {number}\n   */\n\n\n  get minBackoff() {\n    return this._minBackoff;\n  }\n  /**\n   * @param {number} minBackoff\n   * @returns {this}\n   */\n\n\n  setMinBackoff(minBackoff) {\n    if (this._currentBackoff <= minBackoff) {\n      this._currentBackoff = minBackoff;\n    }\n\n    this._minBackoff = minBackoff;\n    return this;\n  }\n  /**\n   * @returns {number}\n   */\n\n\n  get maxBackoff() {\n    return this._maxBackoff;\n  }\n  /**\n   * @param {number} maxBackoff\n   * @returns {this}\n   */\n\n\n  setMaxBackoff(maxBackoff) {\n    if (this._currentBackoff <= maxBackoff) {\n      this._currentBackoff = maxBackoff;\n    }\n\n    this._maxBackoff = maxBackoff;\n    return this;\n  }\n\n  getChannel() {\n    this._useCount++;\n    this.__lastUsed = Date.now();\n\n    if (this._channel != null) {\n      return this._channel;\n    }\n\n    this._channel = this._channelInitFunction(this.address.toString(), this._cert);\n    return this._channel;\n  }\n  /**\n   * Determines if this node is healthy by checking if this node hasn't been\n   * in use for a the required `_currentBackoff` period. Since this looks at `this._lastUsed`\n   * and that value is only set in the `wait()` method, any node that has not\n   * returned a bad gRPC status will always be considered healthy.\n   *\n   * @returns {boolean}\n   */\n\n\n  isHealthy() {\n    return this._readmitTime <= Date.now();\n  }\n\n  increaseBackoff() {\n    this._currentBackoff = Math.min(this._currentBackoff * 2, this._maxBackoff);\n    this._readmitTime = Date.now() + this._currentBackoff;\n  }\n\n  decreaseBackoff() {\n    this._currentBackoff = Math.max(this._currentBackoff / 2, this._minBackoff);\n  }\n  /**\n   * @returns {number}\n   */\n\n\n  getRemainingTime() {\n    return this._readmitTime - this._lastUsed;\n  }\n  /**\n   * This is only ever called if the node itself is down.\n   * A node returning a transaction with a bad status code does not indicate\n   * the node is down, and hence this method will not be called.\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  backoff() {\n    return new Promise(resolve => setTimeout(resolve, this.getRemainingTime()));\n  }\n  /**\n   * @param {ManagedNode<*>} node\n   * @returns {number}\n   */\n\n\n  compare(node) {\n    let comparison = this.getRemainingTime() - node.getRemainingTime();\n\n    if (comparison != 0) {\n      return comparison;\n    }\n\n    comparison = this._currentBackoff - node._currentBackoff;\n\n    if (comparison != 0) {\n      return comparison;\n    }\n\n    comparison = this._badGrpcStatusCount - node._badGrpcStatusCount;\n\n    if (comparison != 0) {\n      return comparison;\n    }\n\n    comparison = this._useCount - node._useCount;\n\n    if (comparison != 0) {\n      return comparison;\n    }\n\n    return this._lastUsed - node._lastUsed;\n  }\n\n  close() {\n    if (this._channel != null) {\n      this._channel.close();\n    }\n\n    this._channel = null;\n  }\n\n}","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/hbar-shop/hbar-shop-dashboard/node_modules/@hashgraph/sdk/src/ManagedNode.js"],"names":["ManagedNodeAddress","ManagedNode","constructor","props","newNode","_address","address","fromString","_cert","undefined","_channel","_channelInitFunction","channelInitFunction","_lastUsed","Date","now","_readmitTime","_useCount","_badGrpcStatusCount","_minBackoff","_maxBackoff","_currentBackoff","cloneNode","node","Error","JSON","stringify","getKey","toInsecure","toSecure","setCert","ledgerId","attempts","minBackoff","setMinBackoff","maxBackoff","setMaxBackoff","getChannel","__lastUsed","toString","isHealthy","increaseBackoff","Math","min","decreaseBackoff","max","getRemainingTime","backoff","Promise","resolve","setTimeout","compare","comparison","close"],"mappings":"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","sourcesContent":["/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\n\nimport ManagedNodeAddress from \"./ManagedNodeAddress.js\";\n\n/**\n * @typedef {import(\"./account/AccountId.js\").default} AccountId\n * @typedef {import(\"./channel/Channel.js\").default} Channel\n * @typedef {import(\"./channel/MirrorChannel.js\").default} MirrorChannel\n * @typedef {import(\"./address_book/NodeAddress.js\").default} NodeAddress\n */\n\n/**\n * @template {Channel | MirrorChannel} ChannelT\n * @typedef {object} NewNode\n * @property {string | ManagedNodeAddress} address\n * @property {(address: string, cert?: string) => ChannelT} channelInitFunction\n */\n\n/**\n * @template {Channel | MirrorChannel} ChannelT\n * @typedef {object} CloneNode\n * @property {ManagedNode<ChannelT>} node\n * @property {ManagedNodeAddress} address\n */\n\n/**\n * @abstract\n * @template {Channel | MirrorChannel} ChannelT\n */\nexport default class ManagedNode {\n    /**\n     * @param {object} props\n     * @param {NewNode<ChannelT>=} [props.newNode]\n     * @param {CloneNode<ChannelT>=} [props.cloneNode]\n     */\n    constructor(props = {}) {\n        if (props.newNode != null) {\n            this._address =\n                typeof props.newNode.address === \"string\"\n                    ? ManagedNodeAddress.fromString(props.newNode.address)\n                    : props.newNode.address;\n\n            /** @type {string=} */\n            this._cert = undefined;\n\n            /** @type {ChannelT | null} */\n            this._channel = null;\n\n            /** @type {(address: string, cert?: string) => ChannelT} */\n            this._channelInitFunction = props.newNode.channelInitFunction;\n\n            this._lastUsed = Date.now();\n            this._readmitTime = Date.now();\n            this._useCount = 0;\n            this._badGrpcStatusCount = 0;\n            this._minBackoff = 8000;\n            this._maxBackoff = 1000 * 60 * 60;\n            this._currentBackoff = this._minBackoff;\n        } else if (props.cloneNode != null) {\n            /** @type {ManagedNodeAddress} */\n            this._address = props.cloneNode.address;\n\n            /** @type {string=} */\n            this._cert = props.cloneNode.node._cert;\n\n            /** @type {ChannelT | null} */\n            this._channel = props.cloneNode.node._channel;\n\n            /** @type {(address: string, cert?: string) => ChannelT} */\n            this._channelInitFunction =\n                props.cloneNode.node._channelInitFunction;\n\n            /** @type {number} */\n            this._currentBackoff = props.cloneNode.node._currentBackoff;\n\n            /** @type {number} */\n            this._lastUsed = props.cloneNode.node._lastUsed;\n\n            /** @type {number} */\n            this._readmitTime = props.cloneNode.node._readmitTime;\n\n            /** @type {number} */\n            this._useCount = props.cloneNode.node._useCount;\n\n            /** @type {number} */\n            this._badGrpcStatusCount = props.cloneNode.node._badGrpcStatusCount;\n\n            /** @type {number} */\n            this._minBackoff = props.cloneNode.node._minBackoff;\n\n            /** @type {number} */\n            this._maxBackoff = props.cloneNode.node._minBackoff;\n        } else {\n            throw new Error(\n                `failed to create ManagedNode: ${JSON.stringify(props)}`\n            );\n        }\n    }\n\n    /**\n     * @abstract\n     * @returns {string}\n     */\n    // eslint-disable-next-line jsdoc/require-returns-check\n    getKey() {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * @abstract\n     * @returns {ManagedNode<ChannelT>}\n     */\n    // eslint-disable-next-line jsdoc/require-returns-check\n    toInsecure() {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * @abstract\n     * @returns {ManagedNode<ChannelT>}\n     */\n    // eslint-disable-next-line jsdoc/require-returns-check\n    toSecure() {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * @param {string} ledgerId\n     * @returns {this}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    setCert(ledgerId) {\n        return this;\n    }\n\n    /**\n     * @returns {ManagedNodeAddress}\n     */\n    get address() {\n        return this._address;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get attempts() {\n        return this._badGrpcStatusCount;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get minBackoff() {\n        return this._minBackoff;\n    }\n\n    /**\n     * @param {number} minBackoff\n     * @returns {this}\n     */\n    setMinBackoff(minBackoff) {\n        if (this._currentBackoff <= minBackoff) {\n            this._currentBackoff = minBackoff;\n        }\n\n        this._minBackoff = minBackoff;\n        return this;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get maxBackoff() {\n        return this._maxBackoff;\n    }\n\n    /**\n     * @param {number} maxBackoff\n     * @returns {this}\n     */\n    setMaxBackoff(maxBackoff) {\n        if (this._currentBackoff <= maxBackoff) {\n            this._currentBackoff = maxBackoff;\n        }\n\n        this._maxBackoff = maxBackoff;\n        return this;\n    }\n\n    getChannel() {\n        this._useCount++;\n        this.__lastUsed = Date.now();\n\n        if (this._channel != null) {\n            return this._channel;\n        }\n\n        this._channel = this._channelInitFunction(\n            this.address.toString(),\n            this._cert\n        );\n        return this._channel;\n    }\n\n    /**\n     * Determines if this node is healthy by checking if this node hasn't been\n     * in use for a the required `_currentBackoff` period. Since this looks at `this._lastUsed`\n     * and that value is only set in the `wait()` method, any node that has not\n     * returned a bad gRPC status will always be considered healthy.\n     *\n     * @returns {boolean}\n     */\n    isHealthy() {\n        return this._readmitTime <= Date.now();\n    }\n\n    increaseBackoff() {\n        this._currentBackoff = Math.min(\n            this._currentBackoff * 2,\n            this._maxBackoff\n        );\n        this._readmitTime = Date.now() + this._currentBackoff;\n    }\n\n    decreaseBackoff() {\n        this._currentBackoff = Math.max(\n            this._currentBackoff / 2,\n            this._minBackoff\n        );\n    }\n\n    /**\n     * @returns {number}\n     */\n    getRemainingTime() {\n        return this._readmitTime - this._lastUsed;\n    }\n\n    /**\n     * This is only ever called if the node itself is down.\n     * A node returning a transaction with a bad status code does not indicate\n     * the node is down, and hence this method will not be called.\n     *\n     * @returns {Promise<void>}\n     */\n    backoff() {\n        return new Promise((resolve) =>\n            setTimeout(resolve, this.getRemainingTime())\n        );\n    }\n\n    /**\n     * @param {ManagedNode<*>} node\n     * @returns {number}\n     */\n    compare(node) {\n        let comparison = this.getRemainingTime() - node.getRemainingTime();\n        if (comparison != 0) {\n            return comparison;\n        }\n\n        comparison = this._currentBackoff - node._currentBackoff;\n        if (comparison != 0) {\n            return comparison;\n        }\n\n        comparison = this._badGrpcStatusCount - node._badGrpcStatusCount;\n        if (comparison != 0) {\n            return comparison;\n        }\n\n        comparison = this._useCount - node._useCount;\n        if (comparison != 0) {\n            return comparison;\n        }\n\n        return this._lastUsed - node._lastUsed;\n    }\n\n    close() {\n        if (this._channel != null) {\n            this._channel.close();\n        }\n\n        this._channel = null;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}