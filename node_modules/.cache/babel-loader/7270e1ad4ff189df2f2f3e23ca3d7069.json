{"ast":null,"code":"/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\nimport NodeAddress from \"../address_book/NodeAddress.js\";\nimport NodeAddressBook from \"../address_book/NodeAddressBook.js\";\nimport * as HashgraphProto from \"@hashgraph/proto\";\nimport FileId from \"../file/FileId.js\";\nimport { RST_STREAM } from \"../Executable.js\";\nimport CACHE from \"../Cache.js\";\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../channel/MirrorChannel.js\").default} MirrorChannel\n * @typedef {import(\"../channel/MirrorChannel.js\").MirrorError} MirrorError\n */\n\n/**\n * @template {Channel} ChannelT\n * @typedef {import(\"../client/Client.js\").default<ChannelT, MirrorChannel>} Client<ChannelT, MirrorChannel>\n */\n\nexport default class AddressBookQuery {\n  /**\n   * @param {object} props\n   * @param {FileId | string} [props.fileId]\n   * @param {number} [props.limit]\n   */\n  constructor() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    /**\n     * @private\n     * @type {?FileId}\n     */\n    this._fileId = null;\n\n    if (props.fileId != null) {\n      this.setFileId(props.fileId);\n    }\n    /**\n     * @private\n     * @type {?number}\n     */\n\n\n    this._limit = null;\n\n    if (props.limit != null) {\n      this.setLimit(props.limit);\n    }\n    /**\n     * @private\n     * @type {(error: MirrorError | Error | null) => boolean}\n     */\n\n\n    this._retryHandler = error => {\n      if (error != null) {\n        if (error instanceof Error) {\n          // Retry on all errors which are not `MirrorError` because they're\n          // likely lower level HTTP/2 errors\n          return true;\n        } else {\n          // Retry on `NOT_FOUND`, `RESOURCE_EXHAUSTED`, `UNAVAILABLE`, and conditionally on `INTERNAL`\n          // if the message matches the right regex.\n          switch (error.code) {\n            // INTERNAL\n            // eslint-disable-next-line no-fallthrough\n            case 13:\n              return RST_STREAM.test(error.details.toString());\n            // NOT_FOUND\n            // eslint-disable-next-line no-fallthrough\n\n            case 5: // RESOURCE_EXHAUSTED\n            // eslint-disable-next-line no-fallthrough\n\n            case 8: // UNAVAILABLE\n            // eslint-disable-next-line no-fallthrough\n\n            case 14:\n              return true;\n\n            default:\n              return false;\n          }\n        }\n      }\n\n      return false;\n    };\n    /** @type {NodeAddress[]} */\n\n\n    this._addresses = [];\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this._maxAttempts = 10;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this._maxBackoff = 8000;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this._attempt = 0;\n  }\n  /**\n   * @returns {?FileId}\n   */\n\n\n  get fileId() {\n    return this._fileId;\n  }\n  /**\n   * @param {FileId | string} fileId\n   * @returns {AddressBookQuery}\n   */\n\n\n  setFileId(fileId) {\n    this._fileId = typeof fileId === \"string\" ? FileId.fromString(fileId) : fileId.clone();\n    return this;\n  }\n  /**\n   * @returns {?number}\n   */\n\n\n  get limit() {\n    return this._limit;\n  }\n  /**\n   * @param {number} limit\n   * @returns {AddressBookQuery}\n   */\n\n\n  setLimit(limit) {\n    this._limit = limit;\n    return this;\n  }\n  /**\n   * @param {number} attempts\n   */\n\n\n  setMaxAttempts(attempts) {\n    this._maxAttempts = attempts;\n  }\n  /**\n   * @param {number} backoff\n   */\n\n\n  setMaxBackoff(backoff) {\n    this._maxBackoff = backoff;\n  }\n  /**\n   * @param {Client<Channel>} client\n   * @param {number=} requestTimeout\n   * @returns {Promise<NodeAddressBook>}\n   */\n\n\n  execute(client, requestTimeout) {\n    return new Promise((resolve, reject) => {\n      this._makeServerStreamRequest(client,\n      /** @type {(value: NodeAddressBook) => void} */\n      resolve, reject, requestTimeout);\n    });\n  }\n  /**\n   * @private\n   * @param {Client<Channel>} client\n   * @param {(value: NodeAddressBook) => void} resolve\n   * @param {(error: Error) => void} reject\n   * @param {number=} requestTimeout\n   */\n\n\n  _makeServerStreamRequest(client, resolve, reject, requestTimeout) {\n    const request = HashgraphProto.com.hedera.mirror.api.proto.AddressBookQuery.encode({\n      fileId: this._fileId != null ? this._fileId._toProtobuf() : null,\n      limit: this._limit\n    }).finish();\n\n    client._mirrorNetwork.getNextMirrorNode().getChannel().makeServerStreamRequest(\"NetworkService\", \"getNodes\", request, data => {\n      this._addresses.push(NodeAddress._fromProtobuf(HashgraphProto.proto.NodeAddress.decode(data)));\n\n      if (this._limit != null && this._limit > 0) {\n        this._limit = this._limit - 1;\n      }\n    }, error => {\n      const message = error instanceof Error ? error.message : error.details;\n\n      if (this._attempt < this._maxAttempts && this._retryHandler(error)) {\n        const delay = Math.min(250 * 2 ** this._attempt, this._maxBackoff);\n        console.warn(`Error getting nodes from mirror for file ${this._fileId != null ? this._fileId.toString() : \"UNKNOWN\"} during attempt ${this._attempt}. Waiting ${delay} ms before next attempt: ${message}`);\n        this._attempt += 1;\n        setTimeout(() => {\n          this._makeServerStreamRequest(client, resolve, reject, requestTimeout);\n        }, delay);\n      } else {\n        reject(new Error(\"failed to query address book\"));\n      }\n    }, () => {\n      resolve(new NodeAddressBook({\n        nodeAddresses: this._addresses\n      }));\n    });\n  }\n\n}\nCACHE.setAddressBookQueryConstructor(() => new AddressBookQuery());","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/hbar-shop/hbar-shopify-coupon-client/node_modules/@hashgraph/sdk/src/network/AddressBookQuery.js"],"names":["NodeAddress","NodeAddressBook","HashgraphProto","FileId","RST_STREAM","CACHE","AddressBookQuery","constructor","props","_fileId","fileId","setFileId","_limit","limit","setLimit","_retryHandler","error","Error","code","test","details","toString","_addresses","_maxAttempts","_maxBackoff","_attempt","fromString","clone","setMaxAttempts","attempts","setMaxBackoff","backoff","execute","client","requestTimeout","Promise","resolve","reject","_makeServerStreamRequest","request","com","hedera","mirror","api","proto","encode","_toProtobuf","finish","_mirrorNetwork","getNextMirrorNode","getChannel","makeServerStreamRequest","data","push","_fromProtobuf","decode","message","delay","Math","min","console","warn","setTimeout","nodeAddresses","setAddressBookQueryConstructor"],"mappings":"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","sourcesContent":["/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\n\nimport NodeAddress from \"../address_book/NodeAddress.js\";\nimport NodeAddressBook from \"../address_book/NodeAddressBook.js\";\nimport * as HashgraphProto from \"@hashgraph/proto\";\nimport FileId from \"../file/FileId.js\";\nimport { RST_STREAM } from \"../Executable.js\";\nimport CACHE from \"../Cache.js\";\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../channel/MirrorChannel.js\").default} MirrorChannel\n * @typedef {import(\"../channel/MirrorChannel.js\").MirrorError} MirrorError\n */\n\n/**\n * @template {Channel} ChannelT\n * @typedef {import(\"../client/Client.js\").default<ChannelT, MirrorChannel>} Client<ChannelT, MirrorChannel>\n */\n\nexport default class AddressBookQuery {\n    /**\n     * @param {object} props\n     * @param {FileId | string} [props.fileId]\n     * @param {number} [props.limit]\n     */\n    constructor(props = {}) {\n        /**\n         * @private\n         * @type {?FileId}\n         */\n        this._fileId = null;\n        if (props.fileId != null) {\n            this.setFileId(props.fileId);\n        }\n\n        /**\n         * @private\n         * @type {?number}\n         */\n        this._limit = null;\n        if (props.limit != null) {\n            this.setLimit(props.limit);\n        }\n\n        /**\n         * @private\n         * @type {(error: MirrorError | Error | null) => boolean}\n         */\n        this._retryHandler = (error) => {\n            if (error != null) {\n                if (error instanceof Error) {\n                    // Retry on all errors which are not `MirrorError` because they're\n                    // likely lower level HTTP/2 errors\n                    return true;\n                } else {\n                    // Retry on `NOT_FOUND`, `RESOURCE_EXHAUSTED`, `UNAVAILABLE`, and conditionally on `INTERNAL`\n                    // if the message matches the right regex.\n                    switch (error.code) {\n                        // INTERNAL\n                        // eslint-disable-next-line no-fallthrough\n                        case 13:\n                            return RST_STREAM.test(error.details.toString());\n                        // NOT_FOUND\n                        // eslint-disable-next-line no-fallthrough\n                        case 5:\n                        // RESOURCE_EXHAUSTED\n                        // eslint-disable-next-line no-fallthrough\n                        case 8:\n                        // UNAVAILABLE\n                        // eslint-disable-next-line no-fallthrough\n                        case 14:\n                            return true;\n                        default:\n                            return false;\n                    }\n                }\n            }\n\n            return false;\n        };\n\n        /** @type {NodeAddress[]} */\n        this._addresses = [];\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._maxAttempts = 10;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._maxBackoff = 8000;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._attempt = 0;\n    }\n\n    /**\n     * @returns {?FileId}\n     */\n    get fileId() {\n        return this._fileId;\n    }\n\n    /**\n     * @param {FileId | string} fileId\n     * @returns {AddressBookQuery}\n     */\n    setFileId(fileId) {\n        this._fileId =\n            typeof fileId === \"string\"\n                ? FileId.fromString(fileId)\n                : fileId.clone();\n\n        return this;\n    }\n\n    /**\n     * @returns {?number}\n     */\n    get limit() {\n        return this._limit;\n    }\n\n    /**\n     * @param {number} limit\n     * @returns {AddressBookQuery}\n     */\n    setLimit(limit) {\n        this._limit = limit;\n\n        return this;\n    }\n\n    /**\n     * @param {number} attempts\n     */\n    setMaxAttempts(attempts) {\n        this._maxAttempts = attempts;\n    }\n\n    /**\n     * @param {number} backoff\n     */\n    setMaxBackoff(backoff) {\n        this._maxBackoff = backoff;\n    }\n\n    /**\n     * @param {Client<Channel>} client\n     * @param {number=} requestTimeout\n     * @returns {Promise<NodeAddressBook>}\n     */\n    execute(client, requestTimeout) {\n        return new Promise((resolve, reject) => {\n            this._makeServerStreamRequest(\n                client,\n                /** @type {(value: NodeAddressBook) => void} */ (resolve),\n                reject,\n                requestTimeout\n            );\n        });\n    }\n\n    /**\n     * @private\n     * @param {Client<Channel>} client\n     * @param {(value: NodeAddressBook) => void} resolve\n     * @param {(error: Error) => void} reject\n     * @param {number=} requestTimeout\n     */\n    _makeServerStreamRequest(client, resolve, reject, requestTimeout) {\n        const request =\n            HashgraphProto.com.hedera.mirror.api.proto.AddressBookQuery.encode({\n                fileId:\n                    this._fileId != null ? this._fileId._toProtobuf() : null,\n                limit: this._limit,\n            }).finish();\n\n        client._mirrorNetwork\n            .getNextMirrorNode()\n            .getChannel()\n            .makeServerStreamRequest(\n                \"NetworkService\",\n                \"getNodes\",\n                request,\n                (data) => {\n                    this._addresses.push(\n                        NodeAddress._fromProtobuf(\n                            HashgraphProto.proto.NodeAddress.decode(data)\n                        )\n                    );\n\n                    if (this._limit != null && this._limit > 0) {\n                        this._limit = this._limit - 1;\n                    }\n                },\n                (error) => {\n                    const message =\n                        error instanceof Error ? error.message : error.details;\n\n                    if (\n                        this._attempt < this._maxAttempts &&\n                        this._retryHandler(error)\n                    ) {\n                        const delay = Math.min(\n                            250 * 2 ** this._attempt,\n                            this._maxBackoff\n                        );\n                        console.warn(\n                            `Error getting nodes from mirror for file ${\n                                this._fileId != null\n                                    ? this._fileId.toString()\n                                    : \"UNKNOWN\"\n                            } during attempt ${\n                                this._attempt\n                            }. Waiting ${delay} ms before next attempt: ${message}`\n                        );\n\n                        this._attempt += 1;\n\n                        setTimeout(() => {\n                            this._makeServerStreamRequest(\n                                client,\n                                resolve,\n                                reject,\n                                requestTimeout\n                            );\n                        }, delay);\n                    } else {\n                        reject(new Error(\"failed to query address book\"));\n                    }\n                },\n                () => {\n                    resolve(\n                        new NodeAddressBook({ nodeAddresses: this._addresses })\n                    );\n                }\n            );\n    }\n}\n\nCACHE.setAddressBookQueryConstructor(() => new AddressBookQuery());\n"]},"metadata":{},"sourceType":"module"}