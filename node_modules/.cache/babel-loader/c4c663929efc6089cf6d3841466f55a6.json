{"ast":null,"code":"\"use strict\";\n/**\n * javascript port of java LZW decompression\n * Original java author url: https://gist.github.com/devunwired/4479231\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lzw = void 0;\n\nexports.lzw = function (minCodeSize, data, pixelCount) {\n  var MAX_STACK_SIZE = 4096;\n  var nullCode = -1;\n  var npix = pixelCount;\n  var available, clear, code_mask, code_size, end_of_information, in_code, old_code, bits, code, i, datum, data_size, first, top, bi, pi;\n  var dstPixels = new Array(pixelCount);\n  var prefix = new Array(MAX_STACK_SIZE);\n  var suffix = new Array(MAX_STACK_SIZE);\n  var pixelStack = new Array(MAX_STACK_SIZE + 1); // Initialize GIF data stream decoder.\n\n  data_size = minCodeSize;\n  clear = 1 << data_size;\n  end_of_information = clear + 1;\n  available = clear + 2;\n  old_code = nullCode;\n  code_size = data_size + 1;\n  code_mask = (1 << code_size) - 1;\n\n  for (code = 0; code < clear; code++) {\n    prefix[code] = 0;\n    suffix[code] = code;\n  } // Decode GIF pixel stream.\n\n\n  var datum, bits, count, first, top, pi, bi;\n  datum = bits = count = first = top = pi = bi = 0;\n\n  for (i = 0; i < npix;) {\n    if (top === 0) {\n      if (bits < code_size) {\n        // get the next byte\n        datum += data[bi] << bits;\n        bits += 8;\n        bi++;\n        continue;\n      } // Get the next code.\n\n\n      code = datum & code_mask;\n      datum >>= code_size;\n      bits -= code_size; // Interpret the code\n\n      if (code > available || code == end_of_information) {\n        break;\n      }\n\n      if (code == clear) {\n        // Reset decoder.\n        code_size = data_size + 1;\n        code_mask = (1 << code_size) - 1;\n        available = clear + 2;\n        old_code = nullCode;\n        continue;\n      }\n\n      if (old_code == nullCode) {\n        pixelStack[top++] = suffix[code];\n        old_code = code;\n        first = code;\n        continue;\n      }\n\n      in_code = code;\n\n      if (code == available) {\n        pixelStack[top++] = first;\n        code = old_code;\n      }\n\n      while (code > clear) {\n        pixelStack[top++] = suffix[code];\n        code = prefix[code];\n      }\n\n      first = suffix[code] & 0xff;\n      pixelStack[top++] = first; // add a new string to the table, but only if space is available\n      // if not, just continue with current table until a clear code is found\n      // (deferred clear code implementation as per GIF spec)\n\n      if (available < MAX_STACK_SIZE) {\n        prefix[available] = old_code;\n        suffix[available] = first;\n        available++;\n\n        if ((available & code_mask) === 0 && available < MAX_STACK_SIZE) {\n          code_size++;\n          code_mask += available;\n        }\n      }\n\n      old_code = in_code;\n    } // Pop a pixel off the pixel stack.\n\n\n    top--;\n    dstPixels[pi++] = pixelStack[top];\n    i++;\n  }\n\n  for (i = pi; i < npix; i++) {\n    dstPixels[i] = 0; // clear missing pixels\n  }\n\n  return dstPixels;\n};","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/hbar-shop/hbar-shop-dashboard/node_modules/awesome-qr/lib/gifuct-js/lzw.js"],"names":["Object","defineProperty","exports","value","lzw","minCodeSize","data","pixelCount","MAX_STACK_SIZE","nullCode","npix","available","clear","code_mask","code_size","end_of_information","in_code","old_code","bits","code","i","datum","data_size","first","top","bi","pi","dstPixels","Array","prefix","suffix","pixelStack","count"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * javascript port of java LZW decompression\n * Original java author url: https://gist.github.com/devunwired/4479231\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.lzw = void 0;\nexports.lzw = function (minCodeSize, data, pixelCount) {\n    var MAX_STACK_SIZE = 4096;\n    var nullCode = -1;\n    var npix = pixelCount;\n    var available, clear, code_mask, code_size, end_of_information, in_code, old_code, bits, code, i, datum, data_size, first, top, bi, pi;\n    var dstPixels = new Array(pixelCount);\n    var prefix = new Array(MAX_STACK_SIZE);\n    var suffix = new Array(MAX_STACK_SIZE);\n    var pixelStack = new Array(MAX_STACK_SIZE + 1);\n    // Initialize GIF data stream decoder.\n    data_size = minCodeSize;\n    clear = 1 << data_size;\n    end_of_information = clear + 1;\n    available = clear + 2;\n    old_code = nullCode;\n    code_size = data_size + 1;\n    code_mask = (1 << code_size) - 1;\n    for (code = 0; code < clear; code++) {\n        prefix[code] = 0;\n        suffix[code] = code;\n    }\n    // Decode GIF pixel stream.\n    var datum, bits, count, first, top, pi, bi;\n    datum = bits = count = first = top = pi = bi = 0;\n    for (i = 0; i < npix;) {\n        if (top === 0) {\n            if (bits < code_size) {\n                // get the next byte\n                datum += data[bi] << bits;\n                bits += 8;\n                bi++;\n                continue;\n            }\n            // Get the next code.\n            code = datum & code_mask;\n            datum >>= code_size;\n            bits -= code_size;\n            // Interpret the code\n            if (code > available || code == end_of_information) {\n                break;\n            }\n            if (code == clear) {\n                // Reset decoder.\n                code_size = data_size + 1;\n                code_mask = (1 << code_size) - 1;\n                available = clear + 2;\n                old_code = nullCode;\n                continue;\n            }\n            if (old_code == nullCode) {\n                pixelStack[top++] = suffix[code];\n                old_code = code;\n                first = code;\n                continue;\n            }\n            in_code = code;\n            if (code == available) {\n                pixelStack[top++] = first;\n                code = old_code;\n            }\n            while (code > clear) {\n                pixelStack[top++] = suffix[code];\n                code = prefix[code];\n            }\n            first = suffix[code] & 0xff;\n            pixelStack[top++] = first;\n            // add a new string to the table, but only if space is available\n            // if not, just continue with current table until a clear code is found\n            // (deferred clear code implementation as per GIF spec)\n            if (available < MAX_STACK_SIZE) {\n                prefix[available] = old_code;\n                suffix[available] = first;\n                available++;\n                if ((available & code_mask) === 0 && available < MAX_STACK_SIZE) {\n                    code_size++;\n                    code_mask += available;\n                }\n            }\n            old_code = in_code;\n        }\n        // Pop a pixel off the pixel stack.\n        top--;\n        dstPixels[pi++] = pixelStack[top];\n        i++;\n    }\n    for (i = pi; i < npix; i++) {\n        dstPixels[i] = 0; // clear missing pixels\n    }\n    return dstPixels;\n};\n"]},"metadata":{},"sourceType":"script"}