{"ast":null,"code":"/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\nimport FileCreateTransaction from \"../file/FileCreateTransaction.js\";\nimport FileAppendTransaction from \"../file/FileAppendTransaction.js\";\nimport FileDeleteTransaction from \"../file/FileDeleteTransaction.js\";\nimport ContractCreateTransaction from \"./ContractCreateTransaction.js\";\nimport * as utf8 from \"../encoding/utf8.js\";\nimport * as hex from \"../encoding/hex.js\";\n/**\n * @typedef {import(\"../account/AccountId.js\").default} AccountId\n * @typedef {import(\"../file/FileId.js\").default} FileId\n * @typedef {import(\"../Key.js\").default} Key\n * @typedef {import(\"./ContractFunctionParameters.js\").default} ContractFunctionParameters\n * @typedef {import(\"../Hbar.js\").default} Hbar\n * @typedef {import(\"../Duration.js\").default} Duration\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../transaction/TransactionId.js\").default} TransactionId\n * @typedef {import(\"../transaction/TransactionResponse.js\").default} TransactionResponse\n * @typedef {import(\"../transaction/TransactionReceipt.js\").default} TransactionReceipt\n * @typedef {import(\"../client/Client.js\").ClientOperator} ClientOperator\n * @typedef {import(\"../Signer.js\").Signer} Signer\n * @typedef {import(\"../PrivateKey.js\").default} PrivateKey\n * @typedef {import(\"../PublicKey.js\").default} PublicKey\n * @typedef {import(\"../transaction/Transaction.js\").default} Transaction\n */\n\n/**\n * @typedef {import(\"bignumber.js\").BigNumber} BigNumber\n * @typedef {import(\"long\").Long} Long\n */\n\nexport default class ContractCreateFlow {\n  constructor() {\n    /** @type {Uint8Array | null} */\n    this._bytecode = null;\n    this._contractCreate = new ContractCreateTransaction();\n    /**\n     * Read `Transaction._signerPublicKeys`\n     *\n     * @internal\n     * @type {Set<string>}\n     */\n\n    this._signerPublicKeys = new Set();\n    /**\n     * Read `Transaction._publicKeys`\n     *\n     * @private\n     * @type {PublicKey[]}\n     */\n\n    this._publicKeys = [];\n    /**\n     * Read `Transaction._transactionSigners`\n     *\n     * @private\n     * @type {((message: Uint8Array) => Promise<Uint8Array>)[]}\n     */\n\n    this._transactionSigners = [];\n    this._maxChunks = null;\n  }\n  /**\n   * @returns {number | null}\n   */\n\n\n  get maxChunks() {\n    return this._maxChunks;\n  }\n  /**\n   * @param {number} maxChunks\n   * @returns {this}\n   */\n\n\n  setMaxChunks(maxChunks) {\n    this._maxChunks = maxChunks;\n    return this;\n  }\n  /**\n   * @returns {?Uint8Array}\n   */\n\n\n  get bytecode() {\n    return this._bytecode;\n  }\n  /**\n   * @param {string | Uint8Array} bytecode\n   * @returns {this}\n   */\n\n\n  setBytecode(bytecode) {\n    this._bytecode = bytecode instanceof Uint8Array ? bytecode : utf8.encode(bytecode);\n    return this;\n  }\n  /**\n   * @returns {?Key}\n   */\n\n\n  get adminKey() {\n    return this._contractCreate.adminKey;\n  }\n  /**\n   * @param {Key} adminKey\n   * @returns {this}\n   */\n\n\n  setAdminKey(adminKey) {\n    this._contractCreate.setAdminKey(adminKey);\n\n    return this;\n  }\n  /**\n   * @returns {?Long}\n   */\n\n\n  get gas() {\n    return this._contractCreate.gas;\n  }\n  /**\n   * @param {number | Long} gas\n   * @returns {this}\n   */\n\n\n  setGas(gas) {\n    this._contractCreate.setGas(gas);\n\n    return this;\n  }\n  /**\n   * @returns {?Hbar}\n   */\n\n\n  get initialBalance() {\n    return this._contractCreate.initialBalance;\n  }\n  /**\n   * Set the initial amount to transfer into this contract.\n   *\n   * @param {number | string | Long | BigNumber | Hbar} initialBalance\n   * @returns {this}\n   */\n\n\n  setInitialBalance(initialBalance) {\n    this._contractCreate.setInitialBalance(initialBalance);\n\n    return this;\n  }\n  /**\n   * @deprecated\n   * @returns {?AccountId}\n   */\n\n\n  get proxyAccountId() {\n    // eslint-disable-next-line deprecation/deprecation\n    return this._contractCreate.proxyAccountId;\n  }\n  /**\n   * @deprecated\n   * @param {AccountId | string} proxyAccountId\n   * @returns {this}\n   */\n\n\n  setProxyAccountId(proxyAccountId) {\n    // eslint-disable-next-line deprecation/deprecation\n    this._contractCreate.setProxyAccountId(proxyAccountId);\n\n    return this;\n  }\n  /**\n   * @returns {Duration}\n   */\n\n\n  get autoRenewPeriod() {\n    return this._contractCreate.autoRenewPeriod;\n  }\n  /**\n   * @param {Duration | Long | number} autoRenewPeriod\n   * @returns {this}\n   */\n\n\n  setAutoRenewPeriod(autoRenewPeriod) {\n    this._contractCreate.setAutoRenewPeriod(autoRenewPeriod);\n\n    return this;\n  }\n  /**\n   * @returns {?Uint8Array}\n   */\n\n\n  get constructorParameters() {\n    return this._contractCreate.constructorParameters;\n  }\n  /**\n   * @param {Uint8Array | ContractFunctionParameters} constructorParameters\n   * @returns {this}\n   */\n\n\n  setConstructorParameters(constructorParameters) {\n    this._contractCreate.setConstructorParameters(constructorParameters);\n\n    return this;\n  }\n  /**\n   * @returns {?string}\n   */\n\n\n  get contractMemo() {\n    return this._contractCreate.contractMemo;\n  }\n  /**\n   * @param {string} contractMemo\n   * @returns {this}\n   */\n\n\n  setContractMemo(contractMemo) {\n    this._contractCreate.setContractMemo(contractMemo);\n\n    return this;\n  }\n  /**\n   * @returns {?number}\n   */\n\n\n  get maxAutomaticTokenAssociation() {\n    return this._contractCreate.maxAutomaticTokenAssociations;\n  }\n  /**\n   * @param {number} maxAutomaticTokenAssociation\n   * @returns {this}\n   */\n\n\n  setMaxAutomaticTokenAssociations(maxAutomaticTokenAssociation) {\n    this._contractCreate.setMaxAutomaticTokenAssociations(maxAutomaticTokenAssociation);\n\n    return this;\n  }\n  /**\n   * @returns {?AccountId}\n   */\n\n\n  get stakedAccountId() {\n    return this._contractCreate.stakedAccountId;\n  }\n  /**\n   * @param {AccountId | string} stakedAccountId\n   * @returns {this}\n   */\n\n\n  setStakedAccountId(stakedAccountId) {\n    this._contractCreate.setStakedAccountId(stakedAccountId);\n\n    return this;\n  }\n  /**\n   * @returns {?Long}\n   */\n\n\n  get stakedNodeId() {\n    return this._contractCreate.stakedNodeId;\n  }\n  /**\n   * @param {Long | number} stakedNodeId\n   * @returns {this}\n   */\n\n\n  setStakedNodeId(stakedNodeId) {\n    this._contractCreate.setStakedNodeId(stakedNodeId);\n\n    return this;\n  }\n  /**\n   * @returns {boolean}\n   */\n\n\n  get declineStakingRewards() {\n    return this._contractCreate.declineStakingRewards;\n  }\n  /**\n   * @param {boolean} declineStakingReward\n   * @returns {this}\n   */\n\n\n  setDeclineStakingReward(declineStakingReward) {\n    this._contractCreate.setDeclineStakingReward(declineStakingReward);\n\n    return this;\n  }\n  /**\n   * @returns {?AccountId}\n   */\n\n\n  get autoRenewAccountId() {\n    return this._contractCreate.autoRenewAccountId;\n  }\n  /**\n   * @param {string | AccountId} autoRenewAccountId\n   * @returns {this}\n   */\n\n\n  setAutoRenewAccountId(autoRenewAccountId) {\n    this._contractCreate.setAutoRenewAccountId(autoRenewAccountId);\n\n    return this;\n  }\n  /**\n   * Sign the transaction with the private key\n   * **NOTE**: This is a thin wrapper around `.signWith()`\n   *\n   * @param {PrivateKey} privateKey\n   * @returns {this}\n   */\n\n\n  sign(privateKey) {\n    return this.signWith(privateKey.publicKey, message => Promise.resolve(privateKey.sign(message)));\n  }\n  /**\n   * Sign the transaction with the public key and signer function\n   *\n   * If sign on demand is enabled no signing will be done immediately, instead\n   * the private key signing function and public key are saved to be used when\n   * a user calls an exit condition method (not sure what a better name for this is)\n   * such as `toBytes[Async]()`, `getTransactionHash[PerNode]()` or `execute()`.\n   *\n   * @param {PublicKey} publicKey\n   * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner\n   * @returns {this}\n   */\n\n\n  signWith(publicKey, transactionSigner) {\n    const publicKeyData = publicKey.toBytesRaw();\n    const publicKeyHex = hex.encode(publicKeyData);\n\n    if (this._signerPublicKeys.has(publicKeyHex)) {\n      // this public key has already signed this transaction\n      return this;\n    }\n\n    this._publicKeys.push(publicKey);\n\n    this._transactionSigners.push(transactionSigner);\n\n    return this;\n  }\n  /**\n   * @template {Channel} ChannelT\n   * @template MirrorChannelT\n   * @param {import(\"../client/Client.js\").default<ChannelT, MirrorChannelT>} client\n   * @param {number=} requestTimeout\n   * @returns {Promise<TransactionResponse>}\n   */\n\n\n  async execute(client, requestTimeout) {\n    if (this._bytecode == null) {\n      throw new Error(\"cannot create contract with no bytecode\");\n    }\n\n    const key = client.operatorPublicKey;\n    const fileCreateTransaction = new FileCreateTransaction().setKeys(key != null ? [key] : []).setContents(this._bytecode.subarray(0, Math.min(this._bytecode.length, 2048))).freezeWith(client);\n    await addSignersToTransaction(fileCreateTransaction, this._publicKeys, this._transactionSigners);\n    let response = await fileCreateTransaction.execute(client, requestTimeout);\n    const receipt = await response.getReceipt(client);\n    const fileId =\n    /** @type {FileId} */\n    receipt.fileId;\n\n    if (this._bytecode.length > 2048) {\n      const fileAppendTransaction = new FileAppendTransaction().setFileId(fileId).setContents(this._bytecode.subarray(2048)).freezeWith(client);\n      await addSignersToTransaction(fileAppendTransaction, this._publicKeys, this._transactionSigners);\n      await fileAppendTransaction.execute(client, requestTimeout);\n    }\n\n    this._contractCreate.setBytecodeFileId(fileId).freezeWith(client);\n\n    await addSignersToTransaction(this._contractCreate, this._publicKeys, this._transactionSigners);\n    response = await this._contractCreate.execute(client, requestTimeout);\n    await response.getReceipt(client);\n\n    if (key != null) {\n      const fileDeleteTransaction = new FileDeleteTransaction().setFileId(fileId).freezeWith(client);\n      await addSignersToTransaction(fileDeleteTransaction, this._publicKeys, this._transactionSigners);\n      await (await fileDeleteTransaction.execute(client, requestTimeout)).getReceipt(client);\n    }\n\n    return response;\n  }\n  /**\n   * @param {Signer} signer\n   * @returns {Promise<TransactionResponse>}\n   */\n\n\n  async executeWithSigner(signer) {\n    if (this._bytecode == null) {\n      throw new Error(\"cannot create contract with no bytecode\");\n    }\n\n    if (signer.getAccountKey == null) {\n      throw new Error(\"`Signer.getAccountKey()` is not implemented, but is required for `ContractCreateFlow`\");\n    }\n\n    const key = signer.getAccountKey();\n    const fileCreateTransaction = await new FileCreateTransaction().setKeys(key != null ? [key] : []).setContents(this._bytecode.subarray(0, Math.min(this._bytecode.length, 2048))).freezeWithSigner(signer);\n    await fileCreateTransaction.signWithSigner(signer);\n    await addSignersToTransaction(fileCreateTransaction, this._publicKeys, this._transactionSigners);\n    let response = await fileCreateTransaction.executeWithSigner(signer);\n    const receipt = await response.getReceiptWithSigner(signer);\n    const fileId =\n    /** @type {FileId} */\n    receipt.fileId;\n\n    if (this._bytecode.length > 2048) {\n      let fileAppendTransaction = new FileAppendTransaction().setFileId(fileId).setContents(this._bytecode.subarray(2048));\n\n      if (this._maxChunks != null) {\n        fileAppendTransaction.setMaxChunks(this._maxChunks);\n      }\n\n      fileAppendTransaction = await fileAppendTransaction.freezeWithSigner(signer);\n      await fileAppendTransaction.signWithSigner(signer);\n      await addSignersToTransaction(fileAppendTransaction, this._publicKeys, this._transactionSigners);\n      await fileAppendTransaction.executeWithSigner(signer);\n    }\n\n    this._contractCreate = await this._contractCreate.setBytecodeFileId(fileId).freezeWithSigner(signer);\n    this._contractCreate = await this._contractCreate.signWithSigner(signer);\n    await addSignersToTransaction(this._contractCreate, this._publicKeys, this._transactionSigners);\n    response = await this._contractCreate.executeWithSigner(signer);\n    await response.getReceiptWithSigner(signer);\n\n    if (key != null) {\n      const fileDeleteTransaction = await new FileDeleteTransaction().setFileId(fileId).freezeWithSigner(signer);\n      await fileDeleteTransaction.signWithSigner(signer);\n      await addSignersToTransaction(fileDeleteTransaction, this._publicKeys, this._transactionSigners);\n      await (await fileDeleteTransaction.executeWithSigner(signer)).getReceiptWithSigner(signer);\n    }\n\n    return response;\n  }\n\n}\n/**\n * @template {Transaction} T\n * @param {T} transaction\n * @param {PublicKey[]} publicKeys\n * @param {((message: Uint8Array) => Promise<Uint8Array>)[]} transactionSigners\n * @returns {Promise<void>}\n */\n\nasync function addSignersToTransaction(transaction, publicKeys, transactionSigners) {\n  for (let i = 0; i < publicKeys.length; i++) {\n    await transaction.signWith(publicKeys[i], transactionSigners[i]);\n  }\n}","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/hbar-shop/hbar-shopify-coupon-client/node_modules/@hashgraph/sdk/src/contract/ContractCreateFlow.js"],"names":["FileCreateTransaction","FileAppendTransaction","FileDeleteTransaction","ContractCreateTransaction","utf8","hex","ContractCreateFlow","constructor","_bytecode","_contractCreate","_signerPublicKeys","Set","_publicKeys","_transactionSigners","_maxChunks","maxChunks","setMaxChunks","bytecode","setBytecode","Uint8Array","encode","adminKey","setAdminKey","gas","setGas","initialBalance","setInitialBalance","proxyAccountId","setProxyAccountId","autoRenewPeriod","setAutoRenewPeriod","constructorParameters","setConstructorParameters","contractMemo","setContractMemo","maxAutomaticTokenAssociation","maxAutomaticTokenAssociations","setMaxAutomaticTokenAssociations","stakedAccountId","setStakedAccountId","stakedNodeId","setStakedNodeId","declineStakingRewards","setDeclineStakingReward","declineStakingReward","autoRenewAccountId","setAutoRenewAccountId","sign","privateKey","signWith","publicKey","message","Promise","resolve","transactionSigner","publicKeyData","toBytesRaw","publicKeyHex","has","push","execute","client","requestTimeout","Error","key","operatorPublicKey","fileCreateTransaction","setKeys","setContents","subarray","Math","min","length","freezeWith","addSignersToTransaction","response","receipt","getReceipt","fileId","fileAppendTransaction","setFileId","setBytecodeFileId","fileDeleteTransaction","executeWithSigner","signer","getAccountKey","freezeWithSigner","signWithSigner","getReceiptWithSigner","transaction","publicKeys","transactionSigners","i"],"mappings":"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","sourcesContent":["/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\n\nimport FileCreateTransaction from \"../file/FileCreateTransaction.js\";\nimport FileAppendTransaction from \"../file/FileAppendTransaction.js\";\nimport FileDeleteTransaction from \"../file/FileDeleteTransaction.js\";\nimport ContractCreateTransaction from \"./ContractCreateTransaction.js\";\nimport * as utf8 from \"../encoding/utf8.js\";\nimport * as hex from \"../encoding/hex.js\";\n\n/**\n * @typedef {import(\"../account/AccountId.js\").default} AccountId\n * @typedef {import(\"../file/FileId.js\").default} FileId\n * @typedef {import(\"../Key.js\").default} Key\n * @typedef {import(\"./ContractFunctionParameters.js\").default} ContractFunctionParameters\n * @typedef {import(\"../Hbar.js\").default} Hbar\n * @typedef {import(\"../Duration.js\").default} Duration\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../transaction/TransactionId.js\").default} TransactionId\n * @typedef {import(\"../transaction/TransactionResponse.js\").default} TransactionResponse\n * @typedef {import(\"../transaction/TransactionReceipt.js\").default} TransactionReceipt\n * @typedef {import(\"../client/Client.js\").ClientOperator} ClientOperator\n * @typedef {import(\"../Signer.js\").Signer} Signer\n * @typedef {import(\"../PrivateKey.js\").default} PrivateKey\n * @typedef {import(\"../PublicKey.js\").default} PublicKey\n * @typedef {import(\"../transaction/Transaction.js\").default} Transaction\n */\n\n/**\n * @typedef {import(\"bignumber.js\").BigNumber} BigNumber\n * @typedef {import(\"long\").Long} Long\n */\n\nexport default class ContractCreateFlow {\n    constructor() {\n        /** @type {Uint8Array | null} */\n        this._bytecode = null;\n        this._contractCreate = new ContractCreateTransaction();\n\n        /**\n         * Read `Transaction._signerPublicKeys`\n         *\n         * @internal\n         * @type {Set<string>}\n         */\n        this._signerPublicKeys = new Set();\n\n        /**\n         * Read `Transaction._publicKeys`\n         *\n         * @private\n         * @type {PublicKey[]}\n         */\n        this._publicKeys = [];\n\n        /**\n         * Read `Transaction._transactionSigners`\n         *\n         * @private\n         * @type {((message: Uint8Array) => Promise<Uint8Array>)[]}\n         */\n        this._transactionSigners = [];\n\n        this._maxChunks = null;\n    }\n\n    /**\n     * @returns {number | null}\n     */\n    get maxChunks() {\n        return this._maxChunks;\n    }\n\n    /**\n     * @param {number} maxChunks\n     * @returns {this}\n     */\n    setMaxChunks(maxChunks) {\n        this._maxChunks = maxChunks;\n        return this;\n    }\n\n    /**\n     * @returns {?Uint8Array}\n     */\n    get bytecode() {\n        return this._bytecode;\n    }\n\n    /**\n     * @param {string | Uint8Array} bytecode\n     * @returns {this}\n     */\n    setBytecode(bytecode) {\n        this._bytecode =\n            bytecode instanceof Uint8Array ? bytecode : utf8.encode(bytecode);\n\n        return this;\n    }\n\n    /**\n     * @returns {?Key}\n     */\n    get adminKey() {\n        return this._contractCreate.adminKey;\n    }\n\n    /**\n     * @param {Key} adminKey\n     * @returns {this}\n     */\n    setAdminKey(adminKey) {\n        this._contractCreate.setAdminKey(adminKey);\n        return this;\n    }\n\n    /**\n     * @returns {?Long}\n     */\n    get gas() {\n        return this._contractCreate.gas;\n    }\n\n    /**\n     * @param {number | Long} gas\n     * @returns {this}\n     */\n    setGas(gas) {\n        this._contractCreate.setGas(gas);\n        return this;\n    }\n\n    /**\n     * @returns {?Hbar}\n     */\n    get initialBalance() {\n        return this._contractCreate.initialBalance;\n    }\n\n    /**\n     * Set the initial amount to transfer into this contract.\n     *\n     * @param {number | string | Long | BigNumber | Hbar} initialBalance\n     * @returns {this}\n     */\n    setInitialBalance(initialBalance) {\n        this._contractCreate.setInitialBalance(initialBalance);\n        return this;\n    }\n\n    /**\n     * @deprecated\n     * @returns {?AccountId}\n     */\n    get proxyAccountId() {\n        // eslint-disable-next-line deprecation/deprecation\n        return this._contractCreate.proxyAccountId;\n    }\n\n    /**\n     * @deprecated\n     * @param {AccountId | string} proxyAccountId\n     * @returns {this}\n     */\n    setProxyAccountId(proxyAccountId) {\n        // eslint-disable-next-line deprecation/deprecation\n        this._contractCreate.setProxyAccountId(proxyAccountId);\n        return this;\n    }\n\n    /**\n     * @returns {Duration}\n     */\n    get autoRenewPeriod() {\n        return this._contractCreate.autoRenewPeriod;\n    }\n\n    /**\n     * @param {Duration | Long | number} autoRenewPeriod\n     * @returns {this}\n     */\n    setAutoRenewPeriod(autoRenewPeriod) {\n        this._contractCreate.setAutoRenewPeriod(autoRenewPeriod);\n        return this;\n    }\n\n    /**\n     * @returns {?Uint8Array}\n     */\n    get constructorParameters() {\n        return this._contractCreate.constructorParameters;\n    }\n\n    /**\n     * @param {Uint8Array | ContractFunctionParameters} constructorParameters\n     * @returns {this}\n     */\n    setConstructorParameters(constructorParameters) {\n        this._contractCreate.setConstructorParameters(constructorParameters);\n        return this;\n    }\n\n    /**\n     * @returns {?string}\n     */\n    get contractMemo() {\n        return this._contractCreate.contractMemo;\n    }\n\n    /**\n     * @param {string} contractMemo\n     * @returns {this}\n     */\n    setContractMemo(contractMemo) {\n        this._contractCreate.setContractMemo(contractMemo);\n        return this;\n    }\n\n    /**\n     * @returns {?number}\n     */\n    get maxAutomaticTokenAssociation() {\n        return this._contractCreate.maxAutomaticTokenAssociations;\n    }\n\n    /**\n     * @param {number} maxAutomaticTokenAssociation\n     * @returns {this}\n     */\n    setMaxAutomaticTokenAssociations(maxAutomaticTokenAssociation) {\n        this._contractCreate.setMaxAutomaticTokenAssociations(\n            maxAutomaticTokenAssociation\n        );\n\n        return this;\n    }\n\n    /**\n     * @returns {?AccountId}\n     */\n    get stakedAccountId() {\n        return this._contractCreate.stakedAccountId;\n    }\n\n    /**\n     * @param {AccountId | string} stakedAccountId\n     * @returns {this}\n     */\n    setStakedAccountId(stakedAccountId) {\n        this._contractCreate.setStakedAccountId(stakedAccountId);\n        return this;\n    }\n\n    /**\n     * @returns {?Long}\n     */\n    get stakedNodeId() {\n        return this._contractCreate.stakedNodeId;\n    }\n\n    /**\n     * @param {Long | number} stakedNodeId\n     * @returns {this}\n     */\n    setStakedNodeId(stakedNodeId) {\n        this._contractCreate.setStakedNodeId(stakedNodeId);\n        return this;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    get declineStakingRewards() {\n        return this._contractCreate.declineStakingRewards;\n    }\n\n    /**\n     * @param {boolean} declineStakingReward\n     * @returns {this}\n     */\n    setDeclineStakingReward(declineStakingReward) {\n        this._contractCreate.setDeclineStakingReward(declineStakingReward);\n        return this;\n    }\n\n    /**\n     * @returns {?AccountId}\n     */\n    get autoRenewAccountId() {\n        return this._contractCreate.autoRenewAccountId;\n    }\n\n    /**\n     * @param {string | AccountId} autoRenewAccountId\n     * @returns {this}\n     */\n    setAutoRenewAccountId(autoRenewAccountId) {\n        this._contractCreate.setAutoRenewAccountId(autoRenewAccountId);\n        return this;\n    }\n\n    /**\n     * Sign the transaction with the private key\n     * **NOTE**: This is a thin wrapper around `.signWith()`\n     *\n     * @param {PrivateKey} privateKey\n     * @returns {this}\n     */\n    sign(privateKey) {\n        return this.signWith(privateKey.publicKey, (message) =>\n            Promise.resolve(privateKey.sign(message))\n        );\n    }\n\n    /**\n     * Sign the transaction with the public key and signer function\n     *\n     * If sign on demand is enabled no signing will be done immediately, instead\n     * the private key signing function and public key are saved to be used when\n     * a user calls an exit condition method (not sure what a better name for this is)\n     * such as `toBytes[Async]()`, `getTransactionHash[PerNode]()` or `execute()`.\n     *\n     * @param {PublicKey} publicKey\n     * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner\n     * @returns {this}\n     */\n    signWith(publicKey, transactionSigner) {\n        const publicKeyData = publicKey.toBytesRaw();\n        const publicKeyHex = hex.encode(publicKeyData);\n\n        if (this._signerPublicKeys.has(publicKeyHex)) {\n            // this public key has already signed this transaction\n            return this;\n        }\n\n        this._publicKeys.push(publicKey);\n        this._transactionSigners.push(transactionSigner);\n\n        return this;\n    }\n\n    /**\n     * @template {Channel} ChannelT\n     * @template MirrorChannelT\n     * @param {import(\"../client/Client.js\").default<ChannelT, MirrorChannelT>} client\n     * @param {number=} requestTimeout\n     * @returns {Promise<TransactionResponse>}\n     */\n    async execute(client, requestTimeout) {\n        if (this._bytecode == null) {\n            throw new Error(\"cannot create contract with no bytecode\");\n        }\n\n        const key = client.operatorPublicKey;\n\n        const fileCreateTransaction = new FileCreateTransaction()\n            .setKeys(key != null ? [key] : [])\n            .setContents(\n                this._bytecode.subarray(\n                    0,\n                    Math.min(this._bytecode.length, 2048)\n                )\n            )\n            .freezeWith(client);\n        await addSignersToTransaction(\n            fileCreateTransaction,\n            this._publicKeys,\n            this._transactionSigners\n        );\n\n        let response = await fileCreateTransaction.execute(\n            client,\n            requestTimeout\n        );\n        const receipt = await response.getReceipt(client);\n\n        const fileId = /** @type {FileId} */ (receipt.fileId);\n\n        if (this._bytecode.length > 2048) {\n            const fileAppendTransaction = new FileAppendTransaction()\n                .setFileId(fileId)\n                .setContents(this._bytecode.subarray(2048))\n                .freezeWith(client);\n            await addSignersToTransaction(\n                fileAppendTransaction,\n                this._publicKeys,\n                this._transactionSigners\n            );\n            await fileAppendTransaction.execute(client, requestTimeout);\n        }\n\n        this._contractCreate.setBytecodeFileId(fileId).freezeWith(client);\n\n        await addSignersToTransaction(\n            this._contractCreate,\n            this._publicKeys,\n            this._transactionSigners\n        );\n\n        response = await this._contractCreate.execute(client, requestTimeout);\n        await response.getReceipt(client);\n\n        if (key != null) {\n            const fileDeleteTransaction = new FileDeleteTransaction()\n                .setFileId(fileId)\n                .freezeWith(client);\n            await addSignersToTransaction(\n                fileDeleteTransaction,\n                this._publicKeys,\n                this._transactionSigners\n            );\n            await (\n                await fileDeleteTransaction.execute(client, requestTimeout)\n            ).getReceipt(client);\n        }\n\n        return response;\n    }\n\n    /**\n     * @param {Signer} signer\n     * @returns {Promise<TransactionResponse>}\n     */\n    async executeWithSigner(signer) {\n        if (this._bytecode == null) {\n            throw new Error(\"cannot create contract with no bytecode\");\n        }\n\n        if (signer.getAccountKey == null) {\n            throw new Error(\n                \"`Signer.getAccountKey()` is not implemented, but is required for `ContractCreateFlow`\"\n            );\n        }\n\n        const key = signer.getAccountKey();\n\n        const fileCreateTransaction = await new FileCreateTransaction()\n            .setKeys(key != null ? [key] : [])\n            .setContents(\n                this._bytecode.subarray(\n                    0,\n                    Math.min(this._bytecode.length, 2048)\n                )\n            )\n            .freezeWithSigner(signer);\n        await fileCreateTransaction.signWithSigner(signer);\n        await addSignersToTransaction(\n            fileCreateTransaction,\n            this._publicKeys,\n            this._transactionSigners\n        );\n\n        let response = await fileCreateTransaction.executeWithSigner(signer);\n        const receipt = await response.getReceiptWithSigner(signer);\n\n        const fileId = /** @type {FileId} */ (receipt.fileId);\n\n        if (this._bytecode.length > 2048) {\n            let fileAppendTransaction = new FileAppendTransaction()\n                .setFileId(fileId)\n                .setContents(this._bytecode.subarray(2048));\n            if (this._maxChunks != null) {\n                fileAppendTransaction.setMaxChunks(this._maxChunks);\n            }\n            fileAppendTransaction =\n                await fileAppendTransaction.freezeWithSigner(signer);\n            await fileAppendTransaction.signWithSigner(signer);\n            await addSignersToTransaction(\n                fileAppendTransaction,\n                this._publicKeys,\n                this._transactionSigners\n            );\n            await fileAppendTransaction.executeWithSigner(signer);\n        }\n\n        this._contractCreate = await this._contractCreate\n            .setBytecodeFileId(fileId)\n            .freezeWithSigner(signer);\n        this._contractCreate = await this._contractCreate.signWithSigner(\n            signer\n        );\n        await addSignersToTransaction(\n            this._contractCreate,\n            this._publicKeys,\n            this._transactionSigners\n        );\n\n        response = await this._contractCreate.executeWithSigner(signer);\n\n        await response.getReceiptWithSigner(signer);\n\n        if (key != null) {\n            const fileDeleteTransaction = await new FileDeleteTransaction()\n                .setFileId(fileId)\n                .freezeWithSigner(signer);\n            await fileDeleteTransaction.signWithSigner(signer);\n            await addSignersToTransaction(\n                fileDeleteTransaction,\n                this._publicKeys,\n                this._transactionSigners\n            );\n            await (\n                await fileDeleteTransaction.executeWithSigner(signer)\n            ).getReceiptWithSigner(signer);\n        }\n\n        return response;\n    }\n}\n\n/**\n * @template {Transaction} T\n * @param {T} transaction\n * @param {PublicKey[]} publicKeys\n * @param {((message: Uint8Array) => Promise<Uint8Array>)[]} transactionSigners\n * @returns {Promise<void>}\n */\nasync function addSignersToTransaction(\n    transaction,\n    publicKeys,\n    transactionSigners\n) {\n    for (let i = 0; i < publicKeys.length; i++) {\n        await transaction.signWith(publicKeys[i], transactionSigners[i]);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}