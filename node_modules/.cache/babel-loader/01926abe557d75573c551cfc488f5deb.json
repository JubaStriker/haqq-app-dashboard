{"ast":null,"code":"var base58 = require('./crypto/base58');\n\nvar segwit = require('./crypto/segwit_addr');\n\nvar cryptoUtils = require('./crypto/utils');\n\nvar DEFAULT_NETWORK_TYPE = 'prod';\n\nfunction getDecoded(address) {\n  try {\n    return base58.decode(address);\n  } catch (e) {\n    // if decoding fails, assume invalid address\n    return null;\n  }\n}\n\nfunction getChecksum(hashFunction, payload) {\n  // Each currency may implement different hashing algorithm\n  switch (hashFunction) {\n    // blake then keccak hash chain\n    case 'blake256keccak256':\n      var blake = cryptoUtils.blake2b256(payload);\n      return cryptoUtils.keccak256Checksum(Buffer.from(blake, 'hex'));\n\n    case 'blake256':\n      return cryptoUtils.blake256Checksum(payload);\n\n    case 'keccak256':\n      return cryptoUtils.keccak256Checksum(payload);\n\n    case 'sha256':\n    default:\n      return cryptoUtils.sha256Checksum(payload);\n  }\n}\n\nfunction getAddressType(address, currency) {\n  currency = currency || {}; // should be 25 bytes per btc address spec and 26 decred\n\n  var expectedLength = currency.expectedLength || 25;\n  var hashFunction = currency.hashFunction || 'sha256';\n  var decoded = getDecoded(address);\n\n  if (decoded) {\n    var length = decoded.length;\n\n    if (length !== expectedLength) {\n      return null;\n    }\n\n    if (currency.regex) {\n      if (!currency.regex.test(address)) {\n        return false;\n      }\n    }\n\n    var checksum = cryptoUtils.toHex(decoded.slice(length - 4, length)),\n        body = cryptoUtils.toHex(decoded.slice(0, length - 4)),\n        goodChecksum = getChecksum(hashFunction, body);\n    return checksum === goodChecksum ? cryptoUtils.toHex(decoded.slice(0, expectedLength - 24)) : null;\n  }\n\n  return null;\n}\n\nfunction isValidP2PKHandP2SHAddress(address, currency, opts) {\n  const {\n    networkType = DEFAULT_NETWORK_TYPE\n  } = opts;\n  var correctAddressTypes;\n  var addressType = getAddressType(address, currency);\n\n  if (addressType) {\n    if (networkType === 'prod' || networkType === 'testnet') {\n      correctAddressTypes = currency.addressTypes[networkType];\n    } else if (currency.addressTypes) {\n      correctAddressTypes = currency.addressTypes.prod.concat(currency.addressTypes.testnet);\n    } else {\n      return false;\n    }\n\n    return correctAddressTypes.indexOf(addressType) >= 0;\n  }\n\n  return false;\n}\n\nmodule.exports = {\n  isValidAddress: function (address, currency) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return isValidP2PKHandP2SHAddress(address, currency, opts) || segwit.isValidAddress(address, currency, opts);\n  }\n};","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/meta-soft-xrp/xrp-shopify-coupon-client/node_modules/multicoin-address-validator/src/bitcoin_validator.js"],"names":["base58","require","segwit","cryptoUtils","DEFAULT_NETWORK_TYPE","getDecoded","address","decode","e","getChecksum","hashFunction","payload","blake","blake2b256","keccak256Checksum","Buffer","from","blake256Checksum","sha256Checksum","getAddressType","currency","expectedLength","decoded","length","regex","test","checksum","toHex","slice","body","goodChecksum","isValidP2PKHandP2SHAddress","opts","networkType","correctAddressTypes","addressType","addressTypes","prod","concat","testnet","indexOf","module","exports","isValidAddress"],"mappings":"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","sourcesContent":["var base58 = require('./crypto/base58');\nvar segwit = require('./crypto/segwit_addr');\nvar cryptoUtils = require('./crypto/utils');\n\nvar DEFAULT_NETWORK_TYPE = 'prod';\n\nfunction getDecoded(address) {\n    try {\n        return base58.decode(address);\n    } catch (e) {\n        // if decoding fails, assume invalid address\n        return null;\n    }\n}\n\nfunction getChecksum(hashFunction, payload) {\n    // Each currency may implement different hashing algorithm\n    switch (hashFunction) {\n        // blake then keccak hash chain\n        case 'blake256keccak256':\n            var blake = cryptoUtils.blake2b256(payload);\n            return cryptoUtils.keccak256Checksum(Buffer.from(blake, 'hex'));\n        case 'blake256':\n            return cryptoUtils.blake256Checksum(payload);\n        case 'keccak256':\n            return cryptoUtils.keccak256Checksum(payload);\n        case 'sha256':\n        default:\n            return cryptoUtils.sha256Checksum(payload);\n    }\n}\n\nfunction getAddressType(address, currency) {\n    currency = currency || {};\n    // should be 25 bytes per btc address spec and 26 decred\n    var expectedLength = currency.expectedLength || 25;\n    var hashFunction = currency.hashFunction || 'sha256';\n    var decoded = getDecoded(address);\n\n    if (decoded) {\n        var length = decoded.length;\n\n        if (length !== expectedLength) {\n            return null;\n        }\n\n        if(currency.regex) {\n            if(!currency.regex.test(address)) {\n                return false;\n            }\n        }\n\n        var checksum = cryptoUtils.toHex(decoded.slice(length - 4, length)),\n            body = cryptoUtils.toHex(decoded.slice(0, length - 4)),\n            goodChecksum = getChecksum(hashFunction, body);\n\n        return checksum === goodChecksum ? cryptoUtils.toHex(decoded.slice(0, expectedLength - 24)) : null;\n    }\n\n    return null;\n}\n\nfunction isValidP2PKHandP2SHAddress(address, currency, opts) {\n    const { networkType = DEFAULT_NETWORK_TYPE} = opts;\n\n    var correctAddressTypes;\n    var addressType = getAddressType(address, currency);\n\n    if (addressType) {\n        if (networkType === 'prod' || networkType === 'testnet') {\n            correctAddressTypes = currency.addressTypes[networkType]\n        } else if (currency.addressTypes) {\n            correctAddressTypes = currency.addressTypes.prod.concat(currency.addressTypes.testnet);\n        } else {\n            return false;\n        }\n\n        return correctAddressTypes.indexOf(addressType) >= 0;\n    }\n\n    return false;\n}\n\nmodule.exports = {\n    isValidAddress: function (address, currency, opts = {}) {\n        return isValidP2PKHandP2SHAddress(address, currency, opts) || segwit.isValidAddress(address, currency, opts);\n    }\n};\n"]},"metadata":{},"sourceType":"script"}