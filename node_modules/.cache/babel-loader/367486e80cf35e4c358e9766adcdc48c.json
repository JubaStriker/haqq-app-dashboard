{"ast":null,"code":"/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\nimport Long from \"long\";\nimport * as hex from \"./encoding/hex.js\";\nimport BadEntityIdError from \"./BadEntityIdError.js\";\nimport * as util from \"./util.js\";\n/**\n * @typedef {import(\"./client/Client.js\").default<*, *>} Client\n */\n\n/**\n * @typedef {object} IEntityId\n * @property {number | Long} num\n * @property {(number | Long)=} shard\n * @property {(number | Long)=} realm\n */\n\n/**\n * @typedef {object} IEntityIdResult\n * @property {Long} shard\n * @property {Long} realm\n * @property {Long} num\n */\n\n/**\n * @typedef {object} IEntityIdParts\n * @property {string?} shard\n * @property {string?} realm\n * @property {string} numOrHex\n * @property {string?} checksum\n */\n\n/**\n * @typedef {object} IEntityIdResultWithChecksum\n * @property {Long} shard\n * @property {Long} realm\n * @property {Long} num\n * @property {string | null} checksum\n */\n\nconst regex = /\"^(0|(?:[1-9]\\\\d*))\\\\.(0|(?:[1-9]\\\\d*))\\\\.(0|(?:[1-9]\\\\d*))(?:-([a-z]{5}))?$/;\n/**\n * This regex supports entity IDs\n *  - as stand alone nubmers\n *  - as shard.realm.num\n *  - as shard.realm.hex\n *  - can optionally provide checksum for any of the above\n */\n\nconst ENTITY_ID_REGEX = /^(\\d+)(?:\\.(\\d+)\\.([a-fA-F0-9]+))?(?:-([a-z]{5}))?$/;\n/**\n * This method is called by most entity ID constructors. It's purpose is to\n * deduplicate the constuctors.\n *\n * @param {number | Long | IEntityId} props\n * @param {(number | null | Long)=} realmOrNull\n * @param {(number | null | Long)=} numOrNull\n * @returns {IEntityIdResult}\n */\n\nexport function constructor(props, realmOrNull, numOrNull) {\n  // Make sure either both the second and third parameter are\n  // set or not set; we shouldn't have one set, but the other not set.\n  //\n  //NOSONAR\n  if (realmOrNull == null && numOrNull != null || realmOrNull != null && numOrNull == null) {\n    throw new Error(\"invalid entity ID\");\n  } // If the first parameter is a nubmer then we need to conver the\n  // first, second, and third parameters into numbers. Otherwise,\n  // we should look at the fields `shard`, `realm`, and `num` on\n  // `props`\n\n\n  const [shard, realm, num] = typeof props === \"number\" || Long.isLong(props) ? [numOrNull != null ? Long.fromValue(\n  /** @type {Long | number} */\n  props) : Long.ZERO, realmOrNull != null ? Long.fromValue(realmOrNull) : Long.ZERO, numOrNull != null ? Long.fromValue(numOrNull) : Long.fromValue(\n  /** @type {Long | number} */\n  props)] : [props.shard != null ? Long.fromValue(props.shard) : Long.ZERO, props.realm != null ? Long.fromValue(props.realm) : Long.ZERO, Long.fromValue(props.num)]; // Make sure none of the numbers are negative\n\n  if (shard.isNegative() || realm.isNegative() || num.isNegative()) {\n    throw new Error(\"negative numbers are not allowed in IDs\");\n  }\n\n  return {\n    shard,\n    realm,\n    num\n  };\n}\n/**\n * A simple comparison function for comparing entity IDs\n *\n * @param {[Long, Long, Long]} a\n * @param {[Long, Long, Long]} b\n * @returns {number}\n */\n\nexport function compare(a, b) {\n  let comparison = a[0].compare(b[0]);\n\n  if (comparison != 0) {\n    return comparison;\n  }\n\n  comparison = a[1].compare(b[1]);\n\n  if (comparison != 0) {\n    return comparison;\n  }\n\n  return a[2].compare(b[2]);\n}\n/**\n * This type is part of the entity ID checksums feature which\n * is responsible for checking if an entity ID was created on\n * the same ledger ID as the client is currently using.\n *\n * @typedef {object} ParseAddressResult\n * @property {number} status\n * @property {Long} [num1]\n * @property {Long} [num2]\n * @property {Long} [num3]\n * @property {string} [correctChecksum]\n * @property {string} [givenChecksum]\n * @property {string} [noChecksumFormat]\n * @property {string} [withChecksumFormat]\n */\n\n/**\n * @param {string} text\n * @returns {IEntityIdParts}\n */\n\nexport function fromStringSplitter(text) {\n  const match = ENTITY_ID_REGEX.exec(text);\n\n  if (match == null) {\n    throw new Error(`failed to parse entity id: ${text}`);\n  }\n\n  if (match[2] == null && match[3] == null) {\n    return {\n      shard: \"0\",\n      realm: \"0\",\n      numOrHex: match[1],\n      checksum: match[4]\n    };\n  } else {\n    return {\n      shard: match[1],\n      realm: match[2],\n      numOrHex: match[3],\n      checksum: match[4]\n    };\n  }\n}\n/**\n * @param {string} text\n * @returns {IEntityIdResultWithChecksum}\n */\n\nexport function fromString(text) {\n  const result = fromStringSplitter(text);\n\n  if (Number.isNaN(result.shard) || Number.isNaN(result.realm) || Number.isNaN(result.numOrHex)) {\n    throw new Error(\"invalid format for entity ID\");\n  }\n\n  return {\n    shard: result.shard != null ? Long.fromString(result.shard) : Long.ZERO,\n    realm: result.realm != null ? Long.fromString(result.realm) : Long.ZERO,\n    num: Long.fromString(result.numOrHex),\n    checksum: result.checksum\n  };\n}\n/**\n * Return the shard, realm, and num from a solidity address.\n *\n * Solidity addresses are 20 bytes long and hex encoded, where the first 4\n * bytes represent the shard, the next 8 bytes represent the realm, and\n * the last 8 bytes represent the num. All in Big Endian format\n *\n * @param {string} address\n * @returns {[Long, Long, Long]}\n */\n\nexport function fromSolidityAddress(address) {\n  const addr = address.startsWith(\"0x\") ? hex.decode(address.slice(2)) : hex.decode(address);\n\n  if (addr.length !== 20) {\n    throw new Error(`Invalid hex encoded solidity address length:\n                expected length 40, got length ${address.length}`);\n  }\n\n  const shard = Long.fromBytesBE([0, 0, 0, 0, ...addr.slice(0, 4)]);\n  const realm = Long.fromBytesBE(Array.from(addr.slice(4, 12)));\n  const num = Long.fromBytesBE(Array.from(addr.slice(12, 20)));\n  return [shard, realm, num];\n}\n/**\n * Convert shard, realm, and num into a solidity address.\n *\n * See `fromSolidityAddress()` for more documentation.\n *\n * @param {[Long,Long,Long] | [number,number,number]} address\n * @returns {string}\n */\n\nexport function toSolidityAddress(address) {\n  const buffer = new Uint8Array(20);\n  const view = util.safeView(buffer);\n  const [shard, realm, num] = address;\n  view.setUint32(0, util.convertToNumber(shard));\n  view.setUint32(8, util.convertToNumber(realm));\n  view.setUint32(16, util.convertToNumber(num));\n  return hex.encode(buffer);\n}\n/**\n * Parse the address string addr and return an object with the results (8 fields).\n * The first four fields are numbers, which could be implemented as signed 32 bit\n * integers, and the last four are strings.\n *\n *   status;  //the status of the parsed address\n *            //   0 = syntax error\n *            //   1 = an invalid with-checksum address (bad checksum)\n *            //   2 = a valid no-checksum address\n *            //   3 = a valid with-checksum address\n *   num1;    //the 3 numbers in the address, such as 1.2.3, with leading zeros removed\n *   num2;\n *   num3;\n *   correctchecksum;    //the correct checksum\n *   givenChecksum;      //the checksum in the address that was parsed\n *   noChecksumFormat;   //the address in no-checksum format\n *   withChecksumFormat; //the address in with-checksum format\n *\n * @param {Uint8Array} ledgerId\n * @param {string} addr\n * @returns {ParseAddressResult}\n */\n\nexport function _parseAddress(ledgerId, addr) {\n  let match = regex.exec(addr);\n\n  if (match === null) {\n    let result = {\n      status: 0\n    }; // When status == 0, the rest of the fields should be ignored\n\n    return result;\n  }\n\n  let a = [Long.fromString(match[1]), Long.fromString(match[2]), Long.fromString(match[3])];\n  let ad = `${a[0].toString()}.${a[1].toString()}.${a[2].toString()}`;\n\n  let c = _checksum(ledgerId, ad);\n\n  let s = match[4] === undefined ? 2 : c == match[4] ? 3 : 1; //NOSONAR\n\n  return {\n    status: s,\n    num1: a[0],\n    num2: a[1],\n    num3: a[2],\n    givenChecksum: match[4],\n    correctChecksum: c,\n    noChecksumFormat: ad,\n    withChecksumFormat: `${ad}-${c}`\n  };\n}\n/**\n * Given an address like \"0.0.123\", return a checksum like \"laujm\"\n *\n * @param {Uint8Array} ledgerId\n * @param {string} addr\n * @returns {string}\n */\n\nexport function _checksum(ledgerId, addr) {\n  let answer = \"\";\n  let d = []; // Digits with 10 for \".\", so if addr == \"0.0.123\" then d == [0, 10, 0, 10, 1, 2, 3]\n\n  let s0 = 0; // Sum of even positions (mod 11)\n\n  let s1 = 0; // Sum of odd positions (mod 11)\n\n  let s = 0; // Weighted sum of all positions (mod p3)\n\n  let sh = 0; // Hash of the ledger ID\n\n  let c = 0; // The checksum, as a single number\n\n  const p3 = 26 * 26 * 26; // 3 digits in base 26\n\n  const p5 = 26 * 26 * 26 * 26 * 26; // 5 digits in base 26\n\n  const ascii_a = \"a\".charCodeAt(0); // 97\n\n  const m = 1000003; // Min prime greater than a million. Used for the final permutation.\n\n  const w = 31; // Sum s of digit values weights them by powers of w. Should be coprime to p5.\n\n  let h = new Uint8Array(ledgerId.length + 6);\n  h.set(ledgerId, 0);\n  h.set([0, 0, 0, 0, 0, 0], ledgerId.length);\n\n  for (let i = 0; i < addr.length; i++) {\n    //NOSONAR\n    d.push(addr[i] === \".\" ? 10 : parseInt(addr[i], 10));\n  }\n\n  for (let i = 0; i < d.length; i++) {\n    s = (w * s + d[i]) % p3;\n\n    if (i % 2 === 0) {\n      s0 = (s0 + d[i]) % 11;\n    } else {\n      s1 = (s1 + d[i]) % 11;\n    }\n  }\n\n  for (let i = 0; i < h.length; i++) {\n    sh = (w * sh + h[i]) % p5;\n  }\n\n  c = (((addr.length % 5 * 11 + s0) * 11 + s1) * p3 + s + sh) % p5;\n  c = c * m % p5;\n\n  for (let i = 0; i < 5; i++) {\n    answer = String.fromCharCode(ascii_a + c % 26) + answer;\n    c /= 26;\n  }\n\n  return answer;\n}\n/**\n * Validate an entity ID checksum against a client\n *\n * @param {Long} shard\n * @param {Long} realm\n * @param {Long} num\n * @param {string | null} checksum\n * @param {Client} client\n */\n\nexport function validateChecksum(shard, realm, num, checksum, client) {\n  if (client._network._ledgerId == null || checksum == null) {\n    return;\n  }\n\n  const expectedChecksum = _checksum(client._network._ledgerId._ledgerId, `${shard.toString()}.${realm.toString()}.${num.toString()}`);\n\n  if (checksum != expectedChecksum) {\n    throw new BadEntityIdError(shard, realm, num, checksum, expectedChecksum);\n  }\n}\n/**\n * Stringify the entity ID with a checksum.\n *\n * @param {string} string\n * @param {Client} client\n * @returns {string}\n */\n\nexport function toStringWithChecksum(string, client) {\n  if (client._network._ledgerId == null) {\n    throw new Error(\"cannot calculate checksum with a client that does not contain a recognzied ledger ID\");\n  }\n\n  const checksum = _checksum(client._network._ledgerId._ledgerId, string);\n\n  return `${string}-${checksum}`;\n}","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/hbar-shop/hbar-shopify-coupon-client/node_modules/@hashgraph/sdk/src/EntityIdHelper.js"],"names":["Long","hex","BadEntityIdError","util","regex","ENTITY_ID_REGEX","constructor","props","realmOrNull","numOrNull","Error","shard","realm","num","isLong","fromValue","ZERO","isNegative","compare","a","b","comparison","fromStringSplitter","text","match","exec","numOrHex","checksum","fromString","result","Number","isNaN","fromSolidityAddress","address","addr","startsWith","decode","slice","length","fromBytesBE","Array","from","toSolidityAddress","buffer","Uint8Array","view","safeView","setUint32","convertToNumber","encode","_parseAddress","ledgerId","status","ad","toString","c","_checksum","s","undefined","num1","num2","num3","givenChecksum","correctChecksum","noChecksumFormat","withChecksumFormat","answer","d","s0","s1","sh","p3","p5","ascii_a","charCodeAt","m","w","h","set","i","push","parseInt","String","fromCharCode","validateChecksum","client","_network","_ledgerId","expectedChecksum","toStringWithChecksum","string"],"mappings":"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","sourcesContent":["/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\n\nimport Long from \"long\";\nimport * as hex from \"./encoding/hex.js\";\nimport BadEntityIdError from \"./BadEntityIdError.js\";\nimport * as util from \"./util.js\";\n\n/**\n * @typedef {import(\"./client/Client.js\").default<*, *>} Client\n */\n\n/**\n * @typedef {object} IEntityId\n * @property {number | Long} num\n * @property {(number | Long)=} shard\n * @property {(number | Long)=} realm\n */\n\n/**\n * @typedef {object} IEntityIdResult\n * @property {Long} shard\n * @property {Long} realm\n * @property {Long} num\n */\n\n/**\n * @typedef {object} IEntityIdParts\n * @property {string?} shard\n * @property {string?} realm\n * @property {string} numOrHex\n * @property {string?} checksum\n */\n\n/**\n * @typedef {object} IEntityIdResultWithChecksum\n * @property {Long} shard\n * @property {Long} realm\n * @property {Long} num\n * @property {string | null} checksum\n */\n\nconst regex =\n    /\"^(0|(?:[1-9]\\\\d*))\\\\.(0|(?:[1-9]\\\\d*))\\\\.(0|(?:[1-9]\\\\d*))(?:-([a-z]{5}))?$/;\n\n/**\n * This regex supports entity IDs\n *  - as stand alone nubmers\n *  - as shard.realm.num\n *  - as shard.realm.hex\n *  - can optionally provide checksum for any of the above\n */\nconst ENTITY_ID_REGEX = /^(\\d+)(?:\\.(\\d+)\\.([a-fA-F0-9]+))?(?:-([a-z]{5}))?$/;\n\n/**\n * This method is called by most entity ID constructors. It's purpose is to\n * deduplicate the constuctors.\n *\n * @param {number | Long | IEntityId} props\n * @param {(number | null | Long)=} realmOrNull\n * @param {(number | null | Long)=} numOrNull\n * @returns {IEntityIdResult}\n */\nexport function constructor(props, realmOrNull, numOrNull) {\n    // Make sure either both the second and third parameter are\n    // set or not set; we shouldn't have one set, but the other not set.\n    //\n    //NOSONAR\n    if (\n        (realmOrNull == null && numOrNull != null) ||\n        (realmOrNull != null && numOrNull == null)\n    ) {\n        throw new Error(\"invalid entity ID\");\n    }\n\n    // If the first parameter is a nubmer then we need to conver the\n    // first, second, and third parameters into numbers. Otherwise,\n    // we should look at the fields `shard`, `realm`, and `num` on\n    // `props`\n    const [shard, realm, num] =\n        typeof props === \"number\" || Long.isLong(props)\n            ? [\n                  numOrNull != null\n                      ? Long.fromValue(/** @type {Long | number} */ (props))\n                      : Long.ZERO,\n                  realmOrNull != null ? Long.fromValue(realmOrNull) : Long.ZERO,\n                  numOrNull != null\n                      ? Long.fromValue(numOrNull)\n                      : Long.fromValue(/** @type {Long | number} */ (props)),\n              ]\n            : [\n                  props.shard != null ? Long.fromValue(props.shard) : Long.ZERO,\n                  props.realm != null ? Long.fromValue(props.realm) : Long.ZERO,\n                  Long.fromValue(props.num),\n              ];\n\n    // Make sure none of the numbers are negative\n    if (shard.isNegative() || realm.isNegative() || num.isNegative()) {\n        throw new Error(\"negative numbers are not allowed in IDs\");\n    }\n\n    return {\n        shard,\n        realm,\n        num,\n    };\n}\n\n/**\n * A simple comparison function for comparing entity IDs\n *\n * @param {[Long, Long, Long]} a\n * @param {[Long, Long, Long]} b\n * @returns {number}\n */\nexport function compare(a, b) {\n    let comparison = a[0].compare(b[0]);\n    if (comparison != 0) {\n        return comparison;\n    }\n\n    comparison = a[1].compare(b[1]);\n    if (comparison != 0) {\n        return comparison;\n    }\n\n    return a[2].compare(b[2]);\n}\n\n/**\n * This type is part of the entity ID checksums feature which\n * is responsible for checking if an entity ID was created on\n * the same ledger ID as the client is currently using.\n *\n * @typedef {object} ParseAddressResult\n * @property {number} status\n * @property {Long} [num1]\n * @property {Long} [num2]\n * @property {Long} [num3]\n * @property {string} [correctChecksum]\n * @property {string} [givenChecksum]\n * @property {string} [noChecksumFormat]\n * @property {string} [withChecksumFormat]\n */\n\n/**\n * @param {string} text\n * @returns {IEntityIdParts}\n */\nexport function fromStringSplitter(text) {\n    const match = ENTITY_ID_REGEX.exec(text);\n\n    if (match == null) {\n        throw new Error(`failed to parse entity id: ${text}`);\n    }\n\n    if (match[2] == null && match[3] == null) {\n        return {\n            shard: \"0\",\n            realm: \"0\",\n            numOrHex: match[1],\n            checksum: match[4],\n        };\n    } else {\n        return {\n            shard: match[1],\n            realm: match[2],\n            numOrHex: match[3],\n            checksum: match[4],\n        };\n    }\n}\n\n/**\n * @param {string} text\n * @returns {IEntityIdResultWithChecksum}\n */\nexport function fromString(text) {\n    const result = fromStringSplitter(text);\n\n    if (\n        Number.isNaN(result.shard) ||\n        Number.isNaN(result.realm) ||\n        Number.isNaN(result.numOrHex)\n    ) {\n        throw new Error(\"invalid format for entity ID\");\n    }\n\n    return {\n        shard: result.shard != null ? Long.fromString(result.shard) : Long.ZERO,\n        realm: result.realm != null ? Long.fromString(result.realm) : Long.ZERO,\n        num: Long.fromString(result.numOrHex),\n        checksum: result.checksum,\n    };\n}\n\n/**\n * Return the shard, realm, and num from a solidity address.\n *\n * Solidity addresses are 20 bytes long and hex encoded, where the first 4\n * bytes represent the shard, the next 8 bytes represent the realm, and\n * the last 8 bytes represent the num. All in Big Endian format\n *\n * @param {string} address\n * @returns {[Long, Long, Long]}\n */\nexport function fromSolidityAddress(address) {\n    const addr = address.startsWith(\"0x\")\n        ? hex.decode(address.slice(2))\n        : hex.decode(address);\n\n    if (addr.length !== 20) {\n        throw new Error(`Invalid hex encoded solidity address length:\n                expected length 40, got length ${address.length}`);\n    }\n\n    const shard = Long.fromBytesBE([0, 0, 0, 0, ...addr.slice(0, 4)]);\n    const realm = Long.fromBytesBE(Array.from(addr.slice(4, 12)));\n    const num = Long.fromBytesBE(Array.from(addr.slice(12, 20)));\n\n    return [shard, realm, num];\n}\n\n/**\n * Convert shard, realm, and num into a solidity address.\n *\n * See `fromSolidityAddress()` for more documentation.\n *\n * @param {[Long,Long,Long] | [number,number,number]} address\n * @returns {string}\n */\nexport function toSolidityAddress(address) {\n    const buffer = new Uint8Array(20);\n    const view = util.safeView(buffer);\n    const [shard, realm, num] = address;\n\n    view.setUint32(0, util.convertToNumber(shard));\n    view.setUint32(8, util.convertToNumber(realm));\n    view.setUint32(16, util.convertToNumber(num));\n\n    return hex.encode(buffer);\n}\n\n/**\n * Parse the address string addr and return an object with the results (8 fields).\n * The first four fields are numbers, which could be implemented as signed 32 bit\n * integers, and the last four are strings.\n *\n *   status;  //the status of the parsed address\n *            //   0 = syntax error\n *            //   1 = an invalid with-checksum address (bad checksum)\n *            //   2 = a valid no-checksum address\n *            //   3 = a valid with-checksum address\n *   num1;    //the 3 numbers in the address, such as 1.2.3, with leading zeros removed\n *   num2;\n *   num3;\n *   correctchecksum;    //the correct checksum\n *   givenChecksum;      //the checksum in the address that was parsed\n *   noChecksumFormat;   //the address in no-checksum format\n *   withChecksumFormat; //the address in with-checksum format\n *\n * @param {Uint8Array} ledgerId\n * @param {string} addr\n * @returns {ParseAddressResult}\n */\nexport function _parseAddress(ledgerId, addr) {\n    let match = regex.exec(addr);\n    if (match === null) {\n        let result = { status: 0 }; // When status == 0, the rest of the fields should be ignored\n        return result;\n    }\n    let a = [\n        Long.fromString(match[1]),\n        Long.fromString(match[2]),\n        Long.fromString(match[3]),\n    ];\n    let ad = `${a[0].toString()}.${a[1].toString()}.${a[2].toString()}`;\n    let c = _checksum(ledgerId, ad);\n    let s = match[4] === undefined ? 2 : c == match[4] ? 3 : 1; //NOSONAR\n    return {\n        status: s,\n        num1: a[0],\n        num2: a[1],\n        num3: a[2],\n        givenChecksum: match[4],\n        correctChecksum: c,\n        noChecksumFormat: ad,\n        withChecksumFormat: `${ad}-${c}`,\n    };\n}\n\n/**\n * Given an address like \"0.0.123\", return a checksum like \"laujm\"\n *\n * @param {Uint8Array} ledgerId\n * @param {string} addr\n * @returns {string}\n */\nexport function _checksum(ledgerId, addr) {\n    let answer = \"\";\n    let d = []; // Digits with 10 for \".\", so if addr == \"0.0.123\" then d == [0, 10, 0, 10, 1, 2, 3]\n    let s0 = 0; // Sum of even positions (mod 11)\n    let s1 = 0; // Sum of odd positions (mod 11)\n    let s = 0; // Weighted sum of all positions (mod p3)\n    let sh = 0; // Hash of the ledger ID\n    let c = 0; // The checksum, as a single number\n    const p3 = 26 * 26 * 26; // 3 digits in base 26\n    const p5 = 26 * 26 * 26 * 26 * 26; // 5 digits in base 26\n    const ascii_a = \"a\".charCodeAt(0); // 97\n    const m = 1000003; // Min prime greater than a million. Used for the final permutation.\n    const w = 31; // Sum s of digit values weights them by powers of w. Should be coprime to p5.\n\n    let h = new Uint8Array(ledgerId.length + 6);\n    h.set(ledgerId, 0);\n    h.set([0, 0, 0, 0, 0, 0], ledgerId.length);\n    for (let i = 0; i < addr.length; i++) {\n        //NOSONAR\n        d.push(addr[i] === \".\" ? 10 : parseInt(addr[i], 10));\n    }\n    for (let i = 0; i < d.length; i++) {\n        s = (w * s + d[i]) % p3;\n        if (i % 2 === 0) {\n            s0 = (s0 + d[i]) % 11;\n        } else {\n            s1 = (s1 + d[i]) % 11;\n        }\n    }\n    for (let i = 0; i < h.length; i++) {\n        sh = (w * sh + h[i]) % p5;\n    }\n    c = ((((addr.length % 5) * 11 + s0) * 11 + s1) * p3 + s + sh) % p5;\n    c = (c * m) % p5;\n\n    for (let i = 0; i < 5; i++) {\n        answer = String.fromCharCode(ascii_a + (c % 26)) + answer;\n        c /= 26;\n    }\n\n    return answer;\n}\n\n/**\n * Validate an entity ID checksum against a client\n *\n * @param {Long} shard\n * @param {Long} realm\n * @param {Long} num\n * @param {string | null} checksum\n * @param {Client} client\n */\nexport function validateChecksum(shard, realm, num, checksum, client) {\n    if (client._network._ledgerId == null || checksum == null) {\n        return;\n    }\n\n    const expectedChecksum = _checksum(\n        client._network._ledgerId._ledgerId,\n        `${shard.toString()}.${realm.toString()}.${num.toString()}`\n    );\n\n    if (checksum != expectedChecksum) {\n        throw new BadEntityIdError(\n            shard,\n            realm,\n            num,\n            checksum,\n            expectedChecksum\n        );\n    }\n}\n\n/**\n * Stringify the entity ID with a checksum.\n *\n * @param {string} string\n * @param {Client} client\n * @returns {string}\n */\nexport function toStringWithChecksum(string, client) {\n    if (client._network._ledgerId == null) {\n        throw new Error(\n            \"cannot calculate checksum with a client that does not contain a recognzied ledger ID\"\n        );\n    }\n\n    const checksum = _checksum(client._network._ledgerId._ledgerId, string);\n\n    return `${string}-${checksum}`;\n}\n"]},"metadata":{},"sourceType":"module"}