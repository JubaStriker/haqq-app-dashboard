{"ast":null,"code":"/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\nimport Long from \"long\";\nimport * as entity_id from \"../EntityIdHelper.js\";\nimport * as HashgraphProto from \"@hashgraph/proto\";\nimport Key from \"../Key.js\";\nimport PublicKey from \"../PublicKey.js\";\nimport CACHE from \"../Cache.js\";\nimport EvmAddress from \"../EvmAddress.js\";\n/**\n * @typedef {import(\"../client/Client.js\").default<*, *>} Client\n */\n\n/**\n * The ID for a crypto-currency account on Hedera.\n */\n\nexport default class AccountId {\n  /**\n   * @param {number | Long | import(\"../EntityIdHelper\").IEntityId} props\n   * @param {(number | Long)=} realm\n   * @param {(number | Long)=} num\n   * @param {(PublicKey)=} aliasKey\n   * @param {(EvmAddress)=} aliasEvmAddress\n   */\n  constructor(props, realm, num, aliasKey, aliasEvmAddress) {\n    const result = entity_id.constructor(props, realm, num);\n    this.shard = result.shard;\n    this.realm = result.realm;\n    this.num = result.num;\n    this.aliasKey = aliasKey != null ? aliasKey : null;\n    this.aliasEvmAddress = aliasEvmAddress != null ? aliasEvmAddress : null;\n    /**\n     * @type {string | null}\n     */\n\n    this._checksum = null;\n  }\n  /**\n   * @param {string} text\n   * @returns {AccountId}\n   */\n\n\n  static fromString(text) {\n    const result = entity_id.fromStringSplitter(text);\n\n    if (Number.isNaN(result.shard) || Number.isNaN(result.realm)) {\n      throw new Error(\"invalid format for entity ID\");\n    }\n\n    const shard = result.shard != null ? Long.fromString(result.shard) : Long.ZERO;\n    const realm = result.realm != null ? Long.fromString(result.realm) : Long.ZERO;\n    let num = Long.ZERO;\n    let aliasKey = undefined;\n    let aliasEvmAddress = undefined;\n\n    if (result.numOrHex.length < 20) {\n      num = Long.fromString(result.numOrHex);\n    } else if (result.numOrHex.length == 40) {\n      aliasEvmAddress = EvmAddress.fromString(result.numOrHex);\n    } else {\n      aliasKey = PublicKey.fromString(result.numOrHex);\n    }\n\n    return new AccountId(shard, realm, num, aliasKey, aliasEvmAddress);\n  }\n  /**\n   * @param {Long | number} shard\n   * @param {Long | number} realm\n   * @param {EvmAddress | string} evmAddress\n   * @returns {AccountId}\n   */\n\n\n  static fromEvmAddress(shard, realm, evmAddress) {\n    return new AccountId(shard, realm, 0, undefined, typeof evmAddress === \"string\" ? EvmAddress.fromString(evmAddress) : evmAddress);\n  }\n  /**\n   * @internal\n   * @param {HashgraphProto.proto.IAccountID} id\n   * @returns {AccountId}\n   */\n\n\n  static _fromProtobuf(id) {\n    let aliasKey = undefined;\n    let aliasEvmAddress = undefined;\n\n    if (id.alias != null) {\n      if (id.alias.length === 20) {\n        aliasEvmAddress = EvmAddress.fromBytes(id.alias);\n      } else {\n        aliasKey = Key._fromProtobufKey(HashgraphProto.proto.Key.decode(id.alias));\n      }\n    }\n\n    if (!(aliasKey instanceof PublicKey)) {\n      aliasKey = undefined;\n    }\n\n    return new AccountId(id.shardNum != null ? id.shardNum : 0, id.realmNum != null ? id.realmNum : 0, id.accountNum != null ? id.accountNum : 0, aliasKey, aliasEvmAddress);\n  }\n  /**\n   * @returns {string | null}\n   */\n\n\n  get checksum() {\n    return this._checksum;\n  }\n  /**\n   * @deprecated - Use `validateChecksum` instead\n   * @param {Client} client\n   */\n\n\n  validate(client) {\n    console.warn(\"Deprecated: Use `validateChecksum` instead\");\n    this.validateChecksum(client);\n  }\n  /**\n   * @param {Client} client\n   */\n\n\n  validateChecksum(client) {\n    if (this.aliasKey != null) {\n      throw new Error(\"cannot calculate checksum with an account ID that has a aliasKey\");\n    }\n\n    entity_id.validateChecksum(this.shard, this.realm, this.num, this._checksum, client);\n  }\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {AccountId}\n   */\n\n\n  static fromBytes(bytes) {\n    return AccountId._fromProtobuf(HashgraphProto.proto.AccountID.decode(bytes));\n  }\n  /**\n   * @param {string} address\n   * @returns {AccountId}\n   */\n\n\n  static fromSolidityAddress(address) {\n    return new AccountId(...entity_id.fromSolidityAddress(address));\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  toSolidityAddress() {\n    return entity_id.toSolidityAddress([this.shard, this.realm, this.num]);\n  }\n  /**\n   * @internal\n   * @returns {HashgraphProto.proto.IAccountID}\n   */\n\n\n  _toProtobuf() {\n    let alias = null;\n\n    if (this.aliasKey != null) {\n      alias = HashgraphProto.proto.Key.encode(this.aliasKey._toProtobufKey()).finish();\n    } else if (this.aliasEvmAddress != null) {\n      alias = this.aliasEvmAddress._bytes;\n    }\n\n    return {\n      alias,\n      accountNum: this.aliasKey != null || this.aliasEvmAddress != null ? null : this.num,\n      shardNum: this.shard,\n      realmNum: this.realm\n    };\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n\n\n  toBytes() {\n    return HashgraphProto.proto.AccountID.encode(this._toProtobuf()).finish();\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  toString() {\n    let account = this.num.toString();\n\n    if (this.aliasKey != null) {\n      account = this.aliasKey.toString();\n    } else if (this.aliasEvmAddress != null) {\n      account = this.aliasEvmAddress.toString();\n    }\n\n    return `${this.shard.toString()}.${this.realm.toString()}.${account}`;\n  }\n  /**\n   * @param {Client} client\n   * @returns {string}\n   */\n\n\n  toStringWithChecksum(client) {\n    if (this.aliasKey != null) {\n      throw new Error(\"cannot calculate checksum with an account ID that has a aliasKey\");\n    }\n\n    return entity_id.toStringWithChecksum(this.toString(), client);\n  }\n  /**\n   * @param {this} other\n   * @returns {boolean}\n   */\n\n\n  equals(other) {\n    let account = false;\n\n    if (this.aliasKey != null && other.aliasKey != null) {\n      account = this.aliasKey.equals(other.aliasKey);\n    } else if (this.aliasKey == null && other.aliasKey == null) {\n      account = this.num.eq(other.num);\n    }\n\n    return this.shard.eq(other.shard) && this.realm.eq(other.realm) && account;\n  }\n  /**\n   * @returns {AccountId}\n   */\n\n\n  clone() {\n    const id = new AccountId(this);\n    id._checksum = this._checksum;\n    id.aliasKey = this.aliasKey;\n    id.aliasEvmAddress = this.aliasEvmAddress;\n    return id;\n  }\n  /**\n   * @param {AccountId} other\n   * @returns {number}\n   */\n\n\n  compare(other) {\n    let comparison = this.shard.compare(other.shard);\n\n    if (comparison != 0) {\n      return comparison;\n    }\n\n    comparison = this.realm.compare(other.realm);\n\n    if (comparison != 0) {\n      return comparison;\n    }\n\n    if (this.aliasKey != null && other.aliasKey != null) {\n      const t = this.aliasKey.toString();\n      const o = other.aliasKey.toString();\n\n      if (t > o) {\n        return 1;\n      } else if (t < o) {\n        return -1;\n      } else {\n        return 0;\n      }\n    } else if (this.aliasKey == null && other.aliasKey == null) {\n      return this.num.compare(other.num);\n    } else {\n      return 1;\n    }\n  }\n\n}\nCACHE.setAccountIdConstructor((shard, realm, key) => new AccountId(shard, realm, Long.ZERO, key));","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/hbar-shop/hbar-shopify-coupon-client/node_modules/@hashgraph/sdk/src/account/AccountId.js"],"names":["Long","entity_id","HashgraphProto","Key","PublicKey","CACHE","EvmAddress","AccountId","constructor","props","realm","num","aliasKey","aliasEvmAddress","result","shard","_checksum","fromString","text","fromStringSplitter","Number","isNaN","Error","ZERO","undefined","numOrHex","length","fromEvmAddress","evmAddress","_fromProtobuf","id","alias","fromBytes","_fromProtobufKey","proto","decode","shardNum","realmNum","accountNum","checksum","validate","client","console","warn","validateChecksum","bytes","AccountID","fromSolidityAddress","address","toSolidityAddress","_toProtobuf","encode","_toProtobufKey","finish","_bytes","toBytes","toString","account","toStringWithChecksum","equals","other","eq","clone","compare","comparison","t","o","setAccountIdConstructor","key"],"mappings":"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","sourcesContent":["/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\n\nimport Long from \"long\";\nimport * as entity_id from \"../EntityIdHelper.js\";\nimport * as HashgraphProto from \"@hashgraph/proto\";\nimport Key from \"../Key.js\";\nimport PublicKey from \"../PublicKey.js\";\nimport CACHE from \"../Cache.js\";\nimport EvmAddress from \"../EvmAddress.js\";\n\n/**\n * @typedef {import(\"../client/Client.js\").default<*, *>} Client\n */\n\n/**\n * The ID for a crypto-currency account on Hedera.\n */\nexport default class AccountId {\n    /**\n     * @param {number | Long | import(\"../EntityIdHelper\").IEntityId} props\n     * @param {(number | Long)=} realm\n     * @param {(number | Long)=} num\n     * @param {(PublicKey)=} aliasKey\n     * @param {(EvmAddress)=} aliasEvmAddress\n     */\n    constructor(props, realm, num, aliasKey, aliasEvmAddress) {\n        const result = entity_id.constructor(props, realm, num);\n\n        this.shard = result.shard;\n        this.realm = result.realm;\n        this.num = result.num;\n        this.aliasKey = aliasKey != null ? aliasKey : null;\n        this.aliasEvmAddress = aliasEvmAddress != null ? aliasEvmAddress : null;\n\n        /**\n         * @type {string | null}\n         */\n        this._checksum = null;\n    }\n\n    /**\n     * @param {string} text\n     * @returns {AccountId}\n     */\n    static fromString(text) {\n        const result = entity_id.fromStringSplitter(text);\n\n        if (Number.isNaN(result.shard) || Number.isNaN(result.realm)) {\n            throw new Error(\"invalid format for entity ID\");\n        }\n\n        const shard =\n            result.shard != null ? Long.fromString(result.shard) : Long.ZERO;\n        const realm =\n            result.realm != null ? Long.fromString(result.realm) : Long.ZERO;\n\n        let num = Long.ZERO;\n        let aliasKey = undefined;\n        let aliasEvmAddress = undefined;\n\n        if (result.numOrHex.length < 20) {\n            num = Long.fromString(result.numOrHex);\n        } else if (result.numOrHex.length == 40) {\n            aliasEvmAddress = EvmAddress.fromString(result.numOrHex);\n        } else {\n            aliasKey = PublicKey.fromString(result.numOrHex);\n        }\n\n        return new AccountId(shard, realm, num, aliasKey, aliasEvmAddress);\n    }\n\n    /**\n     * @param {Long | number} shard\n     * @param {Long | number} realm\n     * @param {EvmAddress | string} evmAddress\n     * @returns {AccountId}\n     */\n    static fromEvmAddress(shard, realm, evmAddress) {\n        return new AccountId(\n            shard,\n            realm,\n            0,\n            undefined,\n            typeof evmAddress === \"string\"\n                ? EvmAddress.fromString(evmAddress)\n                : evmAddress\n        );\n    }\n\n    /**\n     * @internal\n     * @param {HashgraphProto.proto.IAccountID} id\n     * @returns {AccountId}\n     */\n    static _fromProtobuf(id) {\n        let aliasKey = undefined;\n        let aliasEvmAddress = undefined;\n        if (id.alias != null) {\n            if (id.alias.length === 20) {\n                aliasEvmAddress = EvmAddress.fromBytes(id.alias);\n            } else {\n                aliasKey = Key._fromProtobufKey(\n                    HashgraphProto.proto.Key.decode(id.alias)\n                );\n            }\n        }\n\n        if (!(aliasKey instanceof PublicKey)) {\n            aliasKey = undefined;\n        }\n\n        return new AccountId(\n            id.shardNum != null ? id.shardNum : 0,\n            id.realmNum != null ? id.realmNum : 0,\n            id.accountNum != null ? id.accountNum : 0,\n            aliasKey,\n            aliasEvmAddress\n        );\n    }\n\n    /**\n     * @returns {string | null}\n     */\n    get checksum() {\n        return this._checksum;\n    }\n\n    /**\n     * @deprecated - Use `validateChecksum` instead\n     * @param {Client} client\n     */\n    validate(client) {\n        console.warn(\"Deprecated: Use `validateChecksum` instead\");\n        this.validateChecksum(client);\n    }\n\n    /**\n     * @param {Client} client\n     */\n    validateChecksum(client) {\n        if (this.aliasKey != null) {\n            throw new Error(\n                \"cannot calculate checksum with an account ID that has a aliasKey\"\n            );\n        }\n\n        entity_id.validateChecksum(\n            this.shard,\n            this.realm,\n            this.num,\n            this._checksum,\n            client\n        );\n    }\n\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {AccountId}\n     */\n    static fromBytes(bytes) {\n        return AccountId._fromProtobuf(\n            HashgraphProto.proto.AccountID.decode(bytes)\n        );\n    }\n\n    /**\n     * @param {string} address\n     * @returns {AccountId}\n     */\n    static fromSolidityAddress(address) {\n        return new AccountId(...entity_id.fromSolidityAddress(address));\n    }\n\n    /**\n     * @returns {string}\n     */\n    toSolidityAddress() {\n        return entity_id.toSolidityAddress([this.shard, this.realm, this.num]);\n    }\n\n    /**\n     * @internal\n     * @returns {HashgraphProto.proto.IAccountID}\n     */\n    _toProtobuf() {\n        let alias = null;\n        if (this.aliasKey != null) {\n            alias = HashgraphProto.proto.Key.encode(\n                this.aliasKey._toProtobufKey()\n            ).finish();\n        } else if (this.aliasEvmAddress != null) {\n            alias = this.aliasEvmAddress._bytes;\n        }\n\n        return {\n            alias,\n            accountNum:\n                this.aliasKey != null || this.aliasEvmAddress != null\n                    ? null\n                    : this.num,\n            shardNum: this.shard,\n            realmNum: this.realm,\n        };\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        return HashgraphProto.proto.AccountID.encode(\n            this._toProtobuf()\n        ).finish();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        let account = this.num.toString();\n\n        if (this.aliasKey != null) {\n            account = this.aliasKey.toString();\n        } else if (this.aliasEvmAddress != null) {\n            account = this.aliasEvmAddress.toString();\n        }\n\n        return `${this.shard.toString()}.${this.realm.toString()}.${account}`;\n    }\n\n    /**\n     * @param {Client} client\n     * @returns {string}\n     */\n    toStringWithChecksum(client) {\n        if (this.aliasKey != null) {\n            throw new Error(\n                \"cannot calculate checksum with an account ID that has a aliasKey\"\n            );\n        }\n\n        return entity_id.toStringWithChecksum(this.toString(), client);\n    }\n\n    /**\n     * @param {this} other\n     * @returns {boolean}\n     */\n    equals(other) {\n        let account = false;\n\n        if (this.aliasKey != null && other.aliasKey != null) {\n            account = this.aliasKey.equals(other.aliasKey);\n        } else if (this.aliasKey == null && other.aliasKey == null) {\n            account = this.num.eq(other.num);\n        }\n\n        return (\n            this.shard.eq(other.shard) && this.realm.eq(other.realm) && account\n        );\n    }\n\n    /**\n     * @returns {AccountId}\n     */\n    clone() {\n        const id = new AccountId(this);\n        id._checksum = this._checksum;\n        id.aliasKey = this.aliasKey;\n        id.aliasEvmAddress = this.aliasEvmAddress;\n        return id;\n    }\n\n    /**\n     * @param {AccountId} other\n     * @returns {number}\n     */\n    compare(other) {\n        let comparison = this.shard.compare(other.shard);\n        if (comparison != 0) {\n            return comparison;\n        }\n\n        comparison = this.realm.compare(other.realm);\n        if (comparison != 0) {\n            return comparison;\n        }\n\n        if (this.aliasKey != null && other.aliasKey != null) {\n            const t = this.aliasKey.toString();\n            const o = other.aliasKey.toString();\n\n            if (t > o) {\n                return 1;\n            } else if (t < o) {\n                return -1;\n            } else {\n                return 0;\n            }\n        } else if (this.aliasKey == null && other.aliasKey == null) {\n            return this.num.compare(other.num);\n        } else {\n            return 1;\n        }\n    }\n}\n\nCACHE.setAccountIdConstructor(\n    (shard, realm, key) => new AccountId(shard, realm, Long.ZERO, key)\n);\n"]},"metadata":{},"sourceType":"module"}