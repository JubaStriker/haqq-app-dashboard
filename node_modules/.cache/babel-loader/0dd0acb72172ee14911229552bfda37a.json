{"ast":null,"code":"/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\nimport PrivateKey from \"./PrivateKey.js\";\nimport AccountId from \"./account/AccountId.js\";\nimport SignerSignature from \"./SignerSignature.js\";\nimport AccountBalanceQuery from \"./account/AccountBalanceQuery.js\";\nimport AccountInfoQuery from \"./account/AccountInfoQuery.js\";\nimport AccountRecordsQuery from \"./account/AccountRecordsQuery.js\";\nimport TransactionId from \"./transaction/TransactionId.js\";\nimport * as util from \"./util.js\";\n/**\n * @template RequestT\n * @template ResponseT\n * @template OutputT\n * @typedef {import(\"./Executable.js\").default<RequestT, ResponseT, OutputT>} Executable<RequestT, ResponseT, OutputT>\n */\n\n/**\n * @typedef {import(\"./Signer.js\").Signer} Signer\n * @typedef {import(\"./Provider.js\").Provider} Provider\n * @typedef {import(\"./LedgerId.js\").default} LedgerId\n * @typedef {import(\"./Key.js\").default} Key\n * @typedef {import(\"./transaction/Transaction.js\").default} Transaction\n * @typedef {import(\"./transaction/TransactionResponse.js\").default} TransactionResponse\n * @typedef {import(\"./transaction/TransactionReceipt.js\").default} TransactionReceipt\n * @typedef {import(\"./transaction/TransactionRecord.js\").default} TransactionRecord\n * @typedef {import(\"./account/AccountBalance.js\").default} AccountBalance\n * @typedef {import(\"./account/AccountInfo.js\").default} AccountInfo\n */\n\n/**\n * @template {any} O\n * @typedef {import(\"./query/Query.js\").default<O>} Query<O>\n */\n\n/**\n * @implements {Signer}\n */\n\nexport default class Wallet {\n  /**\n   * @param {AccountId | string} accountId\n   * @param {PrivateKey | string} privateKey\n   * @param {Provider=} provider\n   */\n  constructor(accountId, privateKey, provider) {\n    const key = typeof privateKey === \"string\" ? PrivateKey.fromString(privateKey) : privateKey;\n    this.publicKey = key.publicKey;\n    /**\n     * @type {(message: Uint8Array) => Promise<Uint8Array>}\n     */\n\n    this.signer = message => Promise.resolve(key.sign(message));\n\n    this.provider = provider;\n    this.accountId = typeof accountId === \"string\" ? AccountId.fromString(accountId) : accountId;\n  }\n  /**\n   * @returns {Promise<Wallet>}\n   */\n\n\n  static createRandomED25519() {\n    const privateKey = PrivateKey.generateED25519();\n    const publicKey = privateKey.publicKey;\n    const accountId = publicKey.toAccountId(0, 0);\n    return Promise.resolve(new Wallet(accountId, privateKey));\n  }\n  /**\n   * @returns {Promise<Wallet>}\n   */\n\n\n  static createRandomECDSA() {\n    const privateKey = PrivateKey.generateECDSA();\n    const publicKey = privateKey.publicKey;\n    const accountId = publicKey.toAccountId(0, 0);\n    return Promise.resolve(new Wallet(accountId, privateKey));\n  }\n  /**\n   * @returns {Provider=}\n   */\n\n\n  getProvider() {\n    return this.provider;\n  }\n  /**\n   * @abstract\n   * @returns {AccountId}\n   */\n\n\n  getAccountId() {\n    return this.accountId;\n  }\n  /**\n   * @returns {Key}\n   */\n\n\n  getAccountKey() {\n    return this.publicKey;\n  }\n  /**\n   * @returns {LedgerId?}\n   */\n\n\n  getLedgerId() {\n    return this.provider == null ? null : this.provider.getLedgerId();\n  }\n  /**\n   * @abstract\n   * @returns {{[key: string]: (string | AccountId)}}\n   */\n\n\n  getNetwork() {\n    return this.provider == null ? {} : this.provider.getNetwork();\n  }\n  /**\n   * @abstract\n   * @returns {string[]}\n   */\n\n\n  getMirrorNetwork() {\n    return this.provider == null ? [] : this.provider.getMirrorNetwork();\n  }\n  /**\n   * @param {Uint8Array[]} messages\n   * @returns {Promise<SignerSignature[]>}\n   */\n\n\n  async sign(messages) {\n    const sigantures = [];\n\n    for (const message of messages) {\n      sigantures.push(new SignerSignature({\n        publicKey: this.publicKey,\n        signature: await this.signer(message),\n        accountId: this.accountId\n      }));\n    }\n\n    return sigantures;\n  }\n  /**\n   * @returns {Promise<AccountBalance>}\n   */\n\n\n  getAccountBalance() {\n    return this.call(new AccountBalanceQuery().setAccountId(this.accountId));\n  }\n  /**\n   * @abstract\n   * @returns {Promise<AccountInfo>}\n   */\n\n\n  getAccountInfo() {\n    return this.call(new AccountInfoQuery().setAccountId(this.accountId));\n  }\n  /**\n   * @abstract\n   * @returns {Promise<TransactionRecord[]>}\n   */\n\n\n  getAccountRecords() {\n    return this.call(new AccountRecordsQuery().setAccountId(this.accountId));\n  }\n  /**\n   * @template {Transaction} T\n   * @param {T} transaction\n   * @returns {Promise<T>}\n   */\n\n\n  signTransaction(transaction) {\n    return transaction.signWith(this.publicKey, this.signer);\n  }\n  /**\n   * @template {Transaction} T\n   * @param {T} transaction\n   * @returns {Promise<T>}\n   */\n\n\n  checkTransaction(transaction) {\n    const transactionId = transaction.transactionId;\n\n    if (transactionId != null && transactionId.accountId != null && transactionId.accountId.compare(this.accountId) != 0) {\n      throw new Error(\"transaction's ID constructed with a different account ID\");\n    }\n\n    if (this.provider == null) {\n      return Promise.resolve(transaction);\n    }\n\n    const nodeAccountIds = (transaction.nodeAccountIds != null ? transaction.nodeAccountIds : []).map(nodeAccountId => nodeAccountId.toString());\n    const network = Object.values(this.provider.getNetwork()).map(nodeAccountId => nodeAccountId.toString());\n\n    if (!nodeAccountIds.reduce((previous, current) => previous && network.includes(current), true)) {\n      throw new Error(\"Transaction already set node account IDs to values not within the current network\");\n    }\n\n    return Promise.resolve(transaction);\n  }\n  /**\n   * @template {Transaction} T\n   * @param {T} transaction\n   * @returns {Promise<T>}\n   */\n\n\n  populateTransaction(transaction) {\n    transaction._freezeWithAccountId(this.accountId);\n\n    if (transaction.transactionId == null) {\n      transaction.setTransactionId(TransactionId.generate(this.accountId));\n    }\n\n    if (transaction.nodeAccountIds != null && transaction.nodeAccountIds.length != 0) {\n      return Promise.resolve(transaction.freeze());\n    }\n\n    if (this.provider == null) {\n      return Promise.resolve(transaction);\n    }\n\n    const nodeAccountIds = Object.values(this.provider.getNetwork()).map(id => typeof id === \"string\" ? AccountId.fromString(id) : id);\n    util.shuffle(nodeAccountIds);\n    transaction.setNodeAccountIds(nodeAccountIds.slice(0, (nodeAccountIds.length + 3 - 1) / 3));\n    return Promise.resolve(transaction.freeze());\n  }\n  /**\n   * @template RequestT\n   * @template ResponseT\n   * @template OutputT\n   * @param {Executable<RequestT, ResponseT, OutputT>} request\n   * @returns {Promise<OutputT>}\n   */\n\n\n  call(request) {\n    if (this.provider == null) {\n      throw new Error(\"cannot send request with an wallet that doesn't contain a provider\");\n    }\n\n    return this.provider.call(request._setOperatorWith(this.accountId, this.publicKey, this.signer));\n  }\n\n}","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/hbar-shop/hbar-shopify-coupon-client/node_modules/@hashgraph/sdk/src/Wallet.js"],"names":["PrivateKey","AccountId","SignerSignature","AccountBalanceQuery","AccountInfoQuery","AccountRecordsQuery","TransactionId","util","Wallet","constructor","accountId","privateKey","provider","key","fromString","publicKey","signer","message","Promise","resolve","sign","createRandomED25519","generateED25519","toAccountId","createRandomECDSA","generateECDSA","getProvider","getAccountId","getAccountKey","getLedgerId","getNetwork","getMirrorNetwork","messages","sigantures","push","signature","getAccountBalance","call","setAccountId","getAccountInfo","getAccountRecords","signTransaction","transaction","signWith","checkTransaction","transactionId","compare","Error","nodeAccountIds","map","nodeAccountId","toString","network","Object","values","reduce","previous","current","includes","populateTransaction","_freezeWithAccountId","setTransactionId","generate","length","freeze","id","shuffle","setNodeAccountIds","slice","request","_setOperatorWith"],"mappings":"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","sourcesContent":["/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\n\nimport PrivateKey from \"./PrivateKey.js\";\nimport AccountId from \"./account/AccountId.js\";\nimport SignerSignature from \"./SignerSignature.js\";\nimport AccountBalanceQuery from \"./account/AccountBalanceQuery.js\";\nimport AccountInfoQuery from \"./account/AccountInfoQuery.js\";\nimport AccountRecordsQuery from \"./account/AccountRecordsQuery.js\";\nimport TransactionId from \"./transaction/TransactionId.js\";\nimport * as util from \"./util.js\";\n\n/**\n * @template RequestT\n * @template ResponseT\n * @template OutputT\n * @typedef {import(\"./Executable.js\").default<RequestT, ResponseT, OutputT>} Executable<RequestT, ResponseT, OutputT>\n */\n\n/**\n * @typedef {import(\"./Signer.js\").Signer} Signer\n * @typedef {import(\"./Provider.js\").Provider} Provider\n * @typedef {import(\"./LedgerId.js\").default} LedgerId\n * @typedef {import(\"./Key.js\").default} Key\n * @typedef {import(\"./transaction/Transaction.js\").default} Transaction\n * @typedef {import(\"./transaction/TransactionResponse.js\").default} TransactionResponse\n * @typedef {import(\"./transaction/TransactionReceipt.js\").default} TransactionReceipt\n * @typedef {import(\"./transaction/TransactionRecord.js\").default} TransactionRecord\n * @typedef {import(\"./account/AccountBalance.js\").default} AccountBalance\n * @typedef {import(\"./account/AccountInfo.js\").default} AccountInfo\n */\n\n/**\n * @template {any} O\n * @typedef {import(\"./query/Query.js\").default<O>} Query<O>\n */\n\n/**\n * @implements {Signer}\n */\nexport default class Wallet {\n    /**\n     * @param {AccountId | string} accountId\n     * @param {PrivateKey | string} privateKey\n     * @param {Provider=} provider\n     */\n    constructor(accountId, privateKey, provider) {\n        const key =\n            typeof privateKey === \"string\"\n                ? PrivateKey.fromString(privateKey)\n                : privateKey;\n\n        this.publicKey = key.publicKey;\n        /**\n         * @type {(message: Uint8Array) => Promise<Uint8Array>}\n         */\n        this.signer = (message) => Promise.resolve(key.sign(message));\n        this.provider = provider;\n        this.accountId =\n            typeof accountId === \"string\"\n                ? AccountId.fromString(accountId)\n                : accountId;\n    }\n\n    /**\n     * @returns {Promise<Wallet>}\n     */\n    static createRandomED25519() {\n        const privateKey = PrivateKey.generateED25519();\n        const publicKey = privateKey.publicKey;\n        const accountId = publicKey.toAccountId(0, 0);\n        return Promise.resolve(new Wallet(accountId, privateKey));\n    }\n\n    /**\n     * @returns {Promise<Wallet>}\n     */\n    static createRandomECDSA() {\n        const privateKey = PrivateKey.generateECDSA();\n        const publicKey = privateKey.publicKey;\n        const accountId = publicKey.toAccountId(0, 0);\n        return Promise.resolve(new Wallet(accountId, privateKey));\n    }\n\n    /**\n     * @returns {Provider=}\n     */\n    getProvider() {\n        return this.provider;\n    }\n\n    /**\n     * @abstract\n     * @returns {AccountId}\n     */\n    getAccountId() {\n        return this.accountId;\n    }\n\n    /**\n     * @returns {Key}\n     */\n    getAccountKey() {\n        return this.publicKey;\n    }\n\n    /**\n     * @returns {LedgerId?}\n     */\n    getLedgerId() {\n        return this.provider == null ? null : this.provider.getLedgerId();\n    }\n\n    /**\n     * @abstract\n     * @returns {{[key: string]: (string | AccountId)}}\n     */\n    getNetwork() {\n        return this.provider == null ? {} : this.provider.getNetwork();\n    }\n\n    /**\n     * @abstract\n     * @returns {string[]}\n     */\n    getMirrorNetwork() {\n        return this.provider == null ? [] : this.provider.getMirrorNetwork();\n    }\n\n    /**\n     * @param {Uint8Array[]} messages\n     * @returns {Promise<SignerSignature[]>}\n     */\n    async sign(messages) {\n        const sigantures = [];\n\n        for (const message of messages) {\n            sigantures.push(\n                new SignerSignature({\n                    publicKey: this.publicKey,\n                    signature: await this.signer(message),\n                    accountId: this.accountId,\n                })\n            );\n        }\n\n        return sigantures;\n    }\n\n    /**\n     * @returns {Promise<AccountBalance>}\n     */\n    getAccountBalance() {\n        return this.call(\n            new AccountBalanceQuery().setAccountId(this.accountId)\n        );\n    }\n\n    /**\n     * @abstract\n     * @returns {Promise<AccountInfo>}\n     */\n    getAccountInfo() {\n        return this.call(new AccountInfoQuery().setAccountId(this.accountId));\n    }\n\n    /**\n     * @abstract\n     * @returns {Promise<TransactionRecord[]>}\n     */\n    getAccountRecords() {\n        return this.call(\n            new AccountRecordsQuery().setAccountId(this.accountId)\n        );\n    }\n\n    /**\n     * @template {Transaction} T\n     * @param {T} transaction\n     * @returns {Promise<T>}\n     */\n    signTransaction(transaction) {\n        return transaction.signWith(this.publicKey, this.signer);\n    }\n\n    /**\n     * @template {Transaction} T\n     * @param {T} transaction\n     * @returns {Promise<T>}\n     */\n    checkTransaction(transaction) {\n        const transactionId = transaction.transactionId;\n        if (\n            transactionId != null &&\n            transactionId.accountId != null &&\n            transactionId.accountId.compare(this.accountId) != 0\n        ) {\n            throw new Error(\n                \"transaction's ID constructed with a different account ID\"\n            );\n        }\n\n        if (this.provider == null) {\n            return Promise.resolve(transaction);\n        }\n\n        const nodeAccountIds = (\n            transaction.nodeAccountIds != null ? transaction.nodeAccountIds : []\n        ).map((nodeAccountId) => nodeAccountId.toString());\n        const network = Object.values(this.provider.getNetwork()).map(\n            (nodeAccountId) => nodeAccountId.toString()\n        );\n\n        if (\n            !nodeAccountIds.reduce(\n                (previous, current) => previous && network.includes(current),\n                true\n            )\n        ) {\n            throw new Error(\n                \"Transaction already set node account IDs to values not within the current network\"\n            );\n        }\n\n        return Promise.resolve(transaction);\n    }\n\n    /**\n     * @template {Transaction} T\n     * @param {T} transaction\n     * @returns {Promise<T>}\n     */\n    populateTransaction(transaction) {\n        transaction._freezeWithAccountId(this.accountId);\n\n        if (transaction.transactionId == null) {\n            transaction.setTransactionId(\n                TransactionId.generate(this.accountId)\n            );\n        }\n\n        if (\n            transaction.nodeAccountIds != null &&\n            transaction.nodeAccountIds.length != 0\n        ) {\n            return Promise.resolve(transaction.freeze());\n        }\n\n        if (this.provider == null) {\n            return Promise.resolve(transaction);\n        }\n\n        const nodeAccountIds = Object.values(this.provider.getNetwork()).map(\n            (id) => (typeof id === \"string\" ? AccountId.fromString(id) : id)\n        );\n        util.shuffle(nodeAccountIds);\n        transaction.setNodeAccountIds(\n            nodeAccountIds.slice(0, (nodeAccountIds.length + 3 - 1) / 3)\n        );\n\n        return Promise.resolve(transaction.freeze());\n    }\n\n    /**\n     * @template RequestT\n     * @template ResponseT\n     * @template OutputT\n     * @param {Executable<RequestT, ResponseT, OutputT>} request\n     * @returns {Promise<OutputT>}\n     */\n    call(request) {\n        if (this.provider == null) {\n            throw new Error(\n                \"cannot send request with an wallet that doesn't contain a provider\"\n            );\n        }\n\n        return this.provider.call(\n            request._setOperatorWith(\n                this.accountId,\n                this.publicKey,\n                this.signer\n            )\n        );\n    }\n}\n"]},"metadata":{},"sourceType":"module"}