{"ast":null,"code":"/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\nimport Hbar from \"../Hbar.js\";\nimport TransactionResponse from \"./TransactionResponse.js\";\nimport TransactionId from \"./TransactionId.js\";\nimport TransactionHashMap from \"./TransactionHashMap.js\";\nimport SignatureMap from \"./SignatureMap.js\";\nimport Executable, { ExecutionState } from \"../Executable.js\";\nimport Status from \"../Status.js\";\nimport Long from \"long\";\nimport * as sha384 from \"../cryptography/sha384.js\";\nimport * as hex from \"../encoding/hex.js\";\nimport * as HashgraphProto from \"@hashgraph/proto\";\nimport PrecheckStatusError from \"../PrecheckStatusError.js\";\nimport AccountId from \"../account/AccountId.js\";\nimport PublicKey from \"../PublicKey.js\";\nimport List from \"./List.js\";\nimport Timestamp from \"../Timestamp.js\";\nimport Logger from \"js-logger\";\nimport * as util from \"../util.js\";\n/**\n * @typedef {import(\"bignumber.js\").default} BigNumber\n */\n\n/**\n * @typedef {import(\"../schedule/ScheduleCreateTransaction.js\").default} ScheduleCreateTransaction\n * @typedef {import(\"../PrivateKey.js\").default} PrivateKey\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../client/Client.js\").default<*, *>} Client\n * @typedef {import(\"../Signer.js\").Signer} Signer\n */\n// 90 days (in seconds)\n\nexport const DEFAULT_AUTO_RENEW_PERIOD = Long.fromValue(7776000); // maximum value of i64 (so there is never a record generated)\n\nexport const DEFAULT_RECORD_THRESHOLD = Hbar.fromTinybars(Long.fromString(\"9223372036854775807\")); // 120 seconds\n\nconst DEFAULT_TRANSACTION_VALID_DURATION = 120;\nexport const CHUNK_SIZE = 1024;\n/**\n * @type {Map<NonNullable<HashgraphProto.proto.TransactionBody[\"data\"]>, (transactions: HashgraphProto.proto.ITransaction[], signedTransactions: HashgraphProto.proto.ISignedTransaction[], transactionIds: TransactionId[], nodeIds: AccountId[], bodies: HashgraphProto.proto.TransactionBody[]) => Transaction>}\n */\n\nexport const TRANSACTION_REGISTRY = new Map();\n/**\n * Base class for all transactions that may be submitted to Hedera.\n *\n * @abstract\n * @augments {Executable<HashgraphProto.proto.ITransaction, HashgraphProto.proto.ITransactionResponse, TransactionResponse>}\n */\n\nexport default class Transaction extends Executable {\n  // A SDK transaction is composed of multiple, raw protobuf transactions.\n  // These should be functionally identical, with the exception of pointing to\n  // different nodes.\n  // When retrying a transaction after a network error or retry-able\n  // status response, we try a different transaction and thus a different node.\n  constructor() {\n    super();\n    /**\n     * List of proto transactions that have been built from this SDK\n     * transaction.\n     *\n     * This is a 2-D array built into one, meaning to\n     * get to the next row you'd index into this array `row * rowLength + column`\n     * where `rowLength` is `nodeAccountIds.length`\n     *\n     * @internal\n     * @type {List<HashgraphProto.proto.ITransaction | null>}\n     */\n\n    this._transactions = new List();\n    /**\n     * List of proto transactions that have been built from this SDK\n     * transaction.\n     *\n     * This is a 2-D array built into one, meaning to\n     * get to the next row you'd index into this array `row * rowLength + column`\n     * where `rowLength` is `nodeAccountIds.length`\n     *\n     * @internal\n     * @type {List<HashgraphProto.proto.ISignedTransaction>}\n     */\n\n    this._signedTransactions = new List();\n    /**\n     * Set of public keys (as string) who have signed this transaction so\n     * we do not allow them to sign it again.\n     *\n     * @internal\n     * @type {Set<string>}\n     */\n\n    this._signerPublicKeys = new Set();\n    /**\n     * The transaction valid duration\n     *\n     * @private\n     * @type {number}\n     */\n\n    this._transactionValidDuration = DEFAULT_TRANSACTION_VALID_DURATION;\n    /**\n     * The default max transaction fee for this particular transaction type.\n     * Most transactions use the default of 2 Hbars, but some requests such\n     * as `TokenCreateTransaction` need to use a different default value.\n     *\n     * @protected\n     * @type {Hbar}\n     */\n\n    this._defaultMaxTransactionFee = new Hbar(2);\n    /**\n     * The max transaction fee on the request. This field is what users are able\n     * to set, not the `defaultMaxTransactionFee`. The purpose of this field is\n     * to allow us to determine if the user set the field explicitly, or if we're\n     * using the default max transation fee for the request.\n     *\n     * @private\n     * @type {Hbar | null}\n     */\n\n    this._maxTransactionFee = null;\n    /**\n     * The transaction's memo\n     *\n     * @private\n     * @type {string}\n     */\n\n    this._transactionMemo = \"\";\n    /**\n     * The list of transaction IDs. This list will almost always be of length 1.\n     * The only time this list will be a different length is for chunked transactions.\n     * The only two chunked transactions supported right now are `FileAppendTransaction`\n     * and `TopicMessageSubmitTransaction`\n     *\n     * @protected\n     * @type {List<TransactionId>}\n     */\n\n    this._transactionIds = new List();\n    /**\n     * A list of public keys that will be added to the requests signatures\n     *\n     * @private\n     * @type {PublicKey[]}\n     */\n\n    this._publicKeys = [];\n    /**\n     * The list of signing function 1-1 with `_publicKeys` which sign the request.\n     * The reason this list allows `null` is because if we go from bytes into\n     * a transaction, then we know the public key, but we don't have the signing function.\n     *\n     * @private\n     * @type {(((message: Uint8Array) => Promise<Uint8Array>) | null)[]}\n     */\n\n    this._transactionSigners = [];\n    /**\n     * Determine if we should regenerate transaction IDs when we receive `TRANSACITON_EXPIRED`\n     *\n     * @private\n     * @type {?boolean}\n     */\n\n    this._regenerateTransactionId = null;\n  }\n  /**\n   * Deserialize a transaction from bytes. The bytes can either be a `proto.Transaction` or\n   * `proto.TransactionList`.\n   *\n   * @param {Uint8Array} bytes\n   * @returns {Transaction}\n   */\n\n\n  static fromBytes(bytes) {\n    const signedTransactions = [];\n    const transactionIds = [];\n    const nodeIds = [];\n    /** @type {string[]} */\n\n    const transactionIdStrings = [];\n    /** @type {string[]} */\n\n    const nodeIdStrings = [];\n    const bodies = [];\n    const list = HashgraphProto.proto.TransactionList.decode(bytes).transactionList; // If the list is of length 0, then teh bytes provided were not a\n    // `proto.TransactionList`\n    //\n    // FIXME: We should also check to make sure the bytes length is greater than\n    // 0 otherwise this check is wrong?\n\n    if (list.length === 0) {\n      const transaction = HashgraphProto.proto.Transaction.decode(bytes); // We support `Transaction.signedTransactionBytes` and\n      // `Transaction.bodyBytes` + `Transaction.sigMap`. If the bytes represent the\n      // latter, convert them into `signedTransactionBytes`\n\n      if (transaction.signedTransactionBytes.length !== 0) {\n        list.push(transaction);\n      } else {\n        list.push({\n          signedTransactionBytes: HashgraphProto.proto.SignedTransaction.encode({\n            bodyBytes: transaction.bodyBytes,\n            sigMap: transaction.sigMap\n          }).finish()\n        });\n      }\n    } // This loop is responsible for fill out the `signedTransactions`, `transactionIds`,\n    // `nodeIds`, and `bodies` variables.\n\n\n    for (const transaction of list) {\n      // The `signedTransactionBytes` should not be null\n      if (transaction.signedTransactionBytes == null) {\n        throw new Error(\"Transaction.signedTransactionBytes are null\");\n      } // Decode a signed transaction\n\n\n      const signedTransaction = HashgraphProto.proto.SignedTransaction.decode(transaction.signedTransactionBytes);\n      signedTransactions.push(signedTransaction); // Decode a transaction body\n\n      const body = HashgraphProto.proto.TransactionBody.decode(signedTransaction.bodyBytes); // Make sure the body is set\n\n      if (body.data == null) {\n        throw new Error(\"(BUG) body.data was not set in the protobuf\");\n      }\n\n      bodies.push(body); // Make sure the transaction ID within the body is set\n\n      if (body.transactionID != null) {\n        const transactionId = TransactionId._fromProtobuf(\n        /** @type {HashgraphProto.proto.ITransactionID} */\n        body.transactionID); // If we haven't already seen this transaction ID in the list, add it\n\n\n        if (!transactionIdStrings.includes(transactionId.toString())) {\n          transactionIds.push(transactionId);\n          transactionIdStrings.push(transactionId.toString());\n        }\n      } // Make sure the node account ID within the body is set\n\n\n      if (body.nodeAccountID != null) {\n        const nodeAccountId = AccountId._fromProtobuf(\n        /** @type {HashgraphProto.proto.IAccountID} */\n        body.nodeAccountID); // If we haven't already seen this node account ID in the list, add it\n\n\n        if (!nodeIdStrings.includes(nodeAccountId.toString())) {\n          nodeIds.push(nodeAccountId);\n          nodeIdStrings.push(nodeAccountId.toString());\n        }\n      }\n    } // FIXME: We should have a length check before we access `0` since that would error\n\n\n    const body = bodies[0]; // We should have at least more than one body\n\n    if (body == null || body.data == null) {\n      throw new Error(\"No transaction found in bytes or failed to decode TransactionBody\");\n    } // Use the registry to call the right transaction's `fromProtobuf` method based\n    // on the `body.data` string\n\n\n    const fromProtobuf = TRANSACTION_REGISTRY.get(body.data); //NOSONAR\n    // If we forgot to update the registry we should error\n\n    if (fromProtobuf == null) {\n      throw new Error(`(BUG) Transaction.fromBytes() not implemented for type ${body.data}`);\n    } // That the specific transaction type from protobuf implementation and pass in all the\n    // information we've gathered.\n\n\n    return fromProtobuf(list, signedTransactions, transactionIds, nodeIds, bodies);\n  }\n  /**\n   * Convert this transaction a `ScheduleCreateTransaction`\n   *\n   * @returns {ScheduleCreateTransaction}\n   */\n\n\n  schedule() {\n    this._requireNotFrozen();\n\n    if (SCHEDULE_CREATE_TRANSACTION.length != 1) {\n      throw new Error(\"ScheduleCreateTransaction has not been loaded yet\");\n    }\n\n    return SCHEDULE_CREATE_TRANSACTION[0]()._setScheduledTransaction(this);\n  }\n  /**\n   * This method is called by each `*Transaction._fromProtobuf()` method. It does\n   * all the finalization before the user gets hold of a complete `Transaction`\n   *\n   * @template {Transaction} TransactionT\n   * @param {TransactionT} transaction\n   * @param {HashgraphProto.proto.ITransaction[]} transactions\n   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions\n   * @param {TransactionId[]} transactionIds\n   * @param {AccountId[]} nodeIds\n   * @param {HashgraphProto.proto.ITransactionBody[]} bodies\n   * @returns {TransactionT}\n   */\n\n\n  static _fromProtobufTransactions(transaction, transactions, signedTransactions, transactionIds, nodeIds, bodies) {\n    const body = bodies[0]; // \"row\" of the 2-D `bodies` array has all the same contents except for `nodeAccountID`\n\n    for (let i = 0; i < transactionIds.length; i++) {\n      for (let j = 0; j < nodeIds.length - 1; j++) {\n        if (!util.compare(bodies[i * nodeIds.length + j], bodies[i * nodeIds.length + j + 1], // eslint-disable-next-line ie11/no-collection-args\n        new Set([\"nodeAccountID\"]))) {\n          throw new Error(\"failed to validate transaction bodies\");\n        }\n      }\n    } // Remove node account IDs of 0\n    // _IIRC_ this was initial due to some funny behavior with `ScheduleCreateTransaction`\n    // We may be able to remove this.\n\n\n    const zero = new AccountId(0);\n\n    for (let i = 0; i < nodeIds.length; i++) {\n      if (nodeIds[i].equals(zero)) {\n        nodeIds.splice(i--, 1);\n      }\n    } // Set the transactions accordingly, but don't lock the list because transactions can\n    // be regenerated if more signatures are added\n\n\n    transaction._transactions.setList(transactions); // Set the signed transactions accordingly, and lock the list since signed transaction\n    // will not be regenerated. Although, they can be manipulated if for instance more\n    // signatures are added\n\n\n    transaction._signedTransactions.setList(signedTransactions).setLocked(); // Set the transaction IDs accordingly, and lock the list. Transaction IDs should not\n    // be regenerated if we're deserializing a request from bytes\n\n\n    transaction._transactionIds.setList(transactionIds).setLocked(); // Set the node account IDs accordingly, and lock the list. Node account IDs should\n    // never be changed if we're deserializing a request from bytes\n\n\n    transaction._nodeAccountIds.setList(nodeIds).setLocked(); // Make sure to update the rest of the fields\n\n\n    transaction._transactionValidDuration = body.transactionValidDuration != null && body.transactionValidDuration.seconds != null ? Long.fromValue(body.transactionValidDuration.seconds).toInt() : DEFAULT_TRANSACTION_VALID_DURATION;\n    transaction._maxTransactionFee = body.transactionFee != null ? Hbar.fromTinybars(body.transactionFee) : new Hbar(0);\n    transaction._transactionMemo = body.memo != null ? body.memo : \"\"; // Loop over a single row of `signedTransactions` and add all the public\n    // keys to the `signerPublicKeys` set, and `publicKeys` list with\n    // `null` in the `transactionSigners` at the same index.\n\n    for (let i = 0; i < nodeIds.length; i++) {\n      const signedTransaction = signedTransactions[i];\n\n      if (signedTransaction.sigMap != null && signedTransaction.sigMap.sigPair != null) {\n        for (const sigPair of signedTransaction.sigMap.sigPair) {\n          transaction._signerPublicKeys.add(hex.encode(\n          /** @type {Uint8Array} */\n          sigPair.pubKeyPrefix));\n\n          transaction._publicKeys.push(PublicKey.fromBytes(\n          /** @type {Uint8Array} */\n          sigPair.pubKeyPrefix));\n\n          transaction._transactionSigners.push(null);\n        }\n      }\n    }\n\n    return transaction;\n  }\n  /**\n   * Set the node account IDs\n   *\n   * @override\n   * @param {AccountId[]} nodeIds\n   * @returns {this}\n   */\n\n\n  setNodeAccountIds(nodeIds) {\n    // The reason we overwrite this method is simply because we need to call `requireNotFrozen()`\n    // Now that I think of it, we could just add an abstract method `setterPrerequiest()` which\n    // by default does nothing, and `Executable` can call. Then we'd only need to overwrite that\n    // method once.\n    this._requireNotFrozen();\n\n    super.setNodeAccountIds(nodeIds);\n    return this;\n  }\n  /**\n   * Get the transaction valid duration\n   *\n   * @returns {number}\n   */\n\n\n  get transactionValidDuration() {\n    return this._transactionValidDuration;\n  }\n  /**\n   * Sets the duration (in seconds) that this transaction is valid for.\n   *\n   * This is defaulted to 120 seconds (from the time its executed).\n   *\n   * @param {number} validDuration\n   * @returns {this}\n   */\n\n\n  setTransactionValidDuration(validDuration) {\n    this._requireNotFrozen();\n\n    this._transactionValidDuration = validDuration;\n    return this;\n  }\n  /**\n   * Get the max transaction fee\n   *\n   * @returns {?Hbar}\n   */\n\n\n  get maxTransactionFee() {\n    return this._maxTransactionFee;\n  }\n  /**\n   * Set the maximum transaction fee the operator (paying account)\n   * is willing to pay.\n   *\n   * @param {number | string | Long | BigNumber | Hbar} maxTransactionFee\n   * @returns {this}\n   */\n\n\n  setMaxTransactionFee(maxTransactionFee) {\n    this._requireNotFrozen();\n\n    this._maxTransactionFee = maxTransactionFee instanceof Hbar ? maxTransactionFee : new Hbar(maxTransactionFee);\n    return this;\n  }\n  /**\n   * Is transaction ID regeneration enabled\n   *\n   * @returns {?boolean}\n   */\n\n\n  get regenerateTransactionId() {\n    return this._regenerateTransactionId;\n  }\n  /**\n   * Set the maximum transaction fee the operator (paying account)\n   * is willing to pay.\n   *\n   * @param {boolean} regenerateTransactionId\n   * @returns {this}\n   */\n\n\n  setRegenerateTransactionId(regenerateTransactionId) {\n    this._requireNotFrozen();\n\n    this._regenerateTransactionId = regenerateTransactionId;\n    return this;\n  }\n  /**\n   * Get the transaction memo\n   *\n   * @returns {string}\n   */\n\n\n  get transactionMemo() {\n    return this._transactionMemo;\n  }\n  /**\n   * Set a note or description to be recorded in the transaction\n   * record (maximum length of 100 bytes).\n   *\n   * @param {string} transactionMemo\n   * @returns {this}\n   */\n\n\n  setTransactionMemo(transactionMemo) {\n    this._requireNotFrozen();\n\n    this._transactionMemo = transactionMemo;\n    return this;\n  }\n  /**\n   * Get the curent transaction ID\n   *\n   * @returns {?TransactionId}\n   */\n\n\n  get transactionId() {\n    if (this._transactionIds.isEmpty) {\n      return null;\n    } // If a user calls `.transactionId` that means we need to use that transaction ID\n    // and **not** regenerate it. To do this, we simply lock the transaction ID list.\n    //\n    // This may be a little conffusing since a user can enable transaction ID regenration\n    // explicity, but if they call `.transactionId` then we will not regenerate transaction\n    // IDs.\n\n\n    this._transactionIds.setLocked();\n\n    return this._transactionIds.current;\n  }\n  /**\n   * Set the ID for this transaction.\n   *\n   * The transaction ID includes the operator's account ( the account paying the transaction\n   * fee). If two transactions have the same transaction ID, they won't both have an effect. One\n   * will complete normally and the other will fail with a duplicate transaction status.\n   *\n   * Normally, you should not use this method. Just before a transaction is executed, a\n   * transaction ID will be generated from the operator on the client.\n   *\n   * @param {TransactionId} transactionId\n   * @returns {this}\n   */\n\n\n  setTransactionId(transactionId) {\n    this._requireNotFrozen();\n\n    this._transactionIds.setList([transactionId]).setLocked();\n\n    return this;\n  }\n  /**\n   * Sign the transaction with the private key\n   * **NOTE**: This is a thin wrapper around `.signWith()`\n   *\n   * @param {PrivateKey} privateKey\n   * @returns {Promise<this>}\n   */\n\n\n  sign(privateKey) {\n    return this.signWith(privateKey.publicKey, message => Promise.resolve(privateKey.sign(message)));\n  }\n  /**\n   * Sign the transaction with the public key and signer function\n   *\n   * If sign on demand is enabled no signing will be done immediately, instead\n   * the private key signing function and public key are saved to be used when\n   * a user calls an exit condition method (not sure what a better name for this is)\n   * such as `toBytes[Async]()`, `getTransactionHash[PerNode]()` or `execute()`.\n   *\n   * @param {PublicKey} publicKey\n   * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner\n   * @returns {Promise<this>}\n   */\n\n\n  async signWith(publicKey, transactionSigner) {\n    // If signing on demand is disabled, we need to make sure\n    // the request is frozen\n    if (!this._signOnDemand) {\n      this._requireFrozen();\n    }\n\n    const publicKeyData = publicKey.toBytesRaw(); // note: this omits the DER prefix on purpose because Hedera doesn't\n    // support that in the protobuf. this means that we would fail\n    // to re-inflate [this._signerPublicKeys] during [fromBytes] if we used DER\n    // prefixes here\n\n    const publicKeyHex = hex.encode(publicKeyData);\n\n    if (this._signerPublicKeys.has(publicKeyHex)) {\n      // this public key has already signed this transaction\n      return this;\n    } // If we add a new signer, then we need to re-create all transactions\n\n\n    this._transactions.clear(); // Save the current public key so we don't attempt to sign twice\n\n\n    this._signerPublicKeys.add(publicKeyHex); // If signing on demand is enabled we will save the public key and signer and return\n\n\n    if (this._signOnDemand) {\n      this._publicKeys.push(publicKey);\n\n      this._transactionSigners.push(transactionSigner);\n\n      return this;\n    } // If we get here, signing on demand is disabled, this means the transaction\n    // is frozen and we need to sign all the transactions immediately. If we're\n    // signing all the transactions immediately, we need to lock the node account IDs\n    // and transaction IDs.\n    // Now that I think of it, this code should likely exist in `freezeWith()`?\n\n\n    this._transactionIds.setLocked();\n\n    this._nodeAccountIds.setLocked(); // Sign each signed transatcion\n\n\n    for (const signedTransaction of this._signedTransactions.list) {\n      const bodyBytes =\n      /** @type {Uint8Array} */\n      signedTransaction.bodyBytes;\n      const signature = await transactionSigner(bodyBytes);\n\n      if (signedTransaction.sigMap == null) {\n        signedTransaction.sigMap = {};\n      }\n\n      if (signedTransaction.sigMap.sigPair == null) {\n        signedTransaction.sigMap.sigPair = [];\n      }\n\n      signedTransaction.sigMap.sigPair.push(publicKey._toProtobufSignature(signature));\n    }\n\n    return this;\n  }\n  /**\n   * Sign the transaction with the client operator. This is a thin wrapper\n   * around `.signWith()`\n   *\n   * **NOTE**: If client does not have an operator set, this method will throw\n   *\n   * @param {import(\"../client/Client.js\").default<Channel, *>} client\n   * @returns {Promise<this>}\n   */\n\n\n  signWithOperator(client) {\n    const operator = client._operator;\n\n    if (operator == null) {\n      throw new Error(\"`client` must have an operator to sign with the operator\");\n    }\n\n    if (!this._isFrozen()) {\n      this.freezeWith(client);\n    }\n\n    return this.signWith(operator.publicKey, operator.transactionSigner);\n  }\n  /**\n   * Add a signature explicitly\n   *\n   * This method requires the transaction to have exactly 1 node account ID set\n   * since different node account IDs have different byte representations and\n   * hence the same signature would not work for all transactions that are the same\n   * except for node account ID being different.\n   *\n   * @param {PublicKey} publicKey\n   * @param {Uint8Array} signature\n   * @returns {this}\n   */\n\n\n  addSignature(publicKey, signature) {\n    // Require that only one node is set on this transaction\n    // FIXME: This doesn't consider if we have one node account ID set, but we're\n    // also a chunked transaction. We should also check transaction IDs is of length 1\n    this._requireOneNodeAccountId(); // If the transaction isn't frozen, freeze it.\n\n\n    if (!this.isFrozen()) {\n      this.freeze();\n    }\n\n    const publicKeyData = publicKey.toBytesRaw();\n    const publicKeyHex = hex.encode(publicKeyData);\n\n    if (this._signerPublicKeys.has(publicKeyHex)) {\n      // this public key has already signed this transaction\n      return this;\n    } // Transactions will have to be regenerated\n\n\n    this._transactions.clear(); // Locking the transaction IDs and node account IDs is necessary for consistency\n    // between before and after execution\n\n\n    this._transactionIds.setLocked();\n\n    this._nodeAccountIds.setLocked();\n\n    this._signedTransactions.setLocked(); // Add the signature to the signed transaction list. This is a copy paste\n    // of `.signWith()`, but it really shouldn't be if `_signedTransactions.list`\n    // must be a length of one.\n    // FIXME: Remove unnecessary for loop.\n\n\n    for (const transaction of this._signedTransactions.list) {\n      if (transaction.sigMap == null) {\n        transaction.sigMap = {};\n      }\n\n      if (transaction.sigMap.sigPair == null) {\n        transaction.sigMap.sigPair = [];\n      }\n\n      transaction.sigMap.sigPair.push(publicKey._toProtobufSignature(signature));\n    }\n\n    this._signerPublicKeys.add(publicKeyHex);\n\n    this._publicKeys.push(publicKey);\n\n    this._transactionSigners.push(null);\n\n    return this;\n  }\n  /**\n   * Get the current signatures on the request\n   *\n   * **NOTE**: Does NOT support sign on demand\n   *\n   * @returns {SignatureMap}\n   */\n\n\n  getSignatures() {\n    // If a user is attempting to get signatures for a transaction, then the\n    // transaction must be frozen.\n    this._requireFrozen(); // Sign on demand must be disabled because this is the non-async version and\n    // signing requires awaiting callbacks.\n\n\n    this._requireNotSignOnDemand(); // Build all the transactions\n\n\n    this._buildAllTransactions(); // Lock transaction IDs, and node account IDs\n\n\n    this._transactionIds.setLocked();\n\n    this._nodeAccountIds.setLocked(); // Construct a signature map from this transaction\n\n\n    return SignatureMap._fromTransaction(this);\n  }\n  /**\n   * Get the current signatures on the request\n   *\n   * **NOTE**: Supports sign on demand\n   *\n   * @returns {Promise<SignatureMap>}\n   */\n\n\n  async getSignaturesAsync() {\n    // If sign on demand is enabled, we don't need to care about being frozen\n    // since we can just regenerate and resign later if some field of the transaction\n    // changes.\n    // Locking the transaction IDs and node account IDs is necessary for consistency\n    // between before and after execution\n    this._transactionIds.setLocked();\n\n    this._nodeAccountIds.setLocked(); // Build all transactions, and sign them\n\n\n    await this._buildAllTransactionsAsync(); // Lock transaction IDs, and node account IDs\n\n    this._transactions.setLocked();\n\n    this._signedTransactions.setLocked(); // Construct a signature map from this transaction\n\n\n    return SignatureMap._fromTransaction(this);\n  }\n  /**\n   * Not sure why this is called `setTransactionId()` when it doesn't set anything...\n   * FIXME: Remove this?\n   */\n\n\n  _setTransactionId() {\n    if (this._operatorAccountId == null && this._transactionIds.isEmpty) {\n      throw new Error(\"`transactionId` must be set or `client` must be provided with `freezeWith`\");\n    }\n  }\n  /**\n   * Set the node account IDs using the client\n   *\n   * @param {?import(\"../client/Client.js\").default<Channel, *>} client\n   */\n\n\n  _setNodeAccountIds(client) {\n    if (!this._nodeAccountIds.isEmpty) {\n      return;\n    }\n\n    if (client == null) {\n      throw new Error(\"`nodeAccountId` must be set or `client` must be provided with `freezeWith`\");\n    }\n\n    this._nodeAccountIds.setList(client._network.getNodeAccountIdsForExecute());\n  }\n  /**\n   * Build all the signed transactions from the node account IDs\n   *\n   * @private\n   */\n\n\n  _buildSignedTransactions() {\n    if (this._signedTransactions.locked) {\n      return;\n    }\n\n    this._signedTransactions.setList(this._nodeAccountIds.list.map(nodeId => this._makeSignedTransaction(nodeId)));\n  }\n  /**\n   * Freeze this transaction from future modification to prepare for\n   * signing or serialization.\n   *\n   * @returns {this}\n   */\n\n\n  freeze() {\n    return this.freezeWith(null);\n  }\n  /**\n   * @param {?AccountId} accountId\n   */\n\n\n  _freezeWithAccountId(accountId) {\n    if (this._operatorAccountId == null) {\n      this._operatorAccountId = accountId;\n    }\n  }\n  /**\n   * Freeze this transaction from further modification to prepare for\n   * signing or serialization.\n   *\n   * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3\n   * nodes to prepare this transaction for.\n   *\n   * @param {?import(\"../client/Client.js\").default<Channel, *>} client\n   * @returns {this}\n   */\n\n\n  freezeWith(client) {\n    // Set sign on demand based on client\n    this._signOnDemand = client != null ? client.signOnDemand : false; // Save the operator\n\n    this._operator = client != null ? client._operator : null;\n\n    this._freezeWithAccountId(client != null ? client.operatorAccountId : null); // Set max transaction fee to either `this._maxTransactionFee`,\n    // `client._defaultMaxTransactionFee`, or `this._defaultMaxTransactionFee`\n    // in that priority order depending on if `this._maxTransactionFee` has\n    // been set or if `client._defaultMaxTransactionFee` has been set.\n\n\n    this._maxTransactionFee = this._maxTransactionFee == null ? client != null && client.defaultMaxTransactionFee != null ? client.defaultMaxTransactionFee : this._defaultMaxTransactionFee : this._maxTransactionFee; // Determine if transaction ID generation should be enabled.\n\n    this._regenerateTransactionId = client != null && this._regenerateTransactionId == null ? client.defaultRegenerateTransactionId : this._regenerateTransactionId; // Set the node account IDs via client\n\n    this._setNodeAccountIds(client); // Make sure a transaction ID or operator is set.\n\n\n    this._setTransactionId(); // If a client was not provided, we need to make sure the transaction ID already set\n    // validates aginst the client.\n\n\n    if (client != null) {\n      for (const transactionId of this._transactionIds.list) {\n        if (transactionId.accountId != null) {\n          transactionId.accountId.validateChecksum(client);\n        }\n      }\n    } // Build a list of transaction IDs so that if a user calls `.transactionId` they'll\n    // get a value, but if they dont' we'll just regenerate transaction IDs during execution\n\n\n    this._buildNewTransactionIdList(); // If sign on demand is disabled we need to build out all the signed transactions\n\n\n    if (!this._signOnDemand) {\n      this._buildSignedTransactions();\n    }\n\n    return this;\n  }\n  /**\n   * Sign the transaction using a signer\n   *\n   * This is part of the signature provider feature\n   *\n   * @param {Signer} signer\n   * @returns {Promise<this>}\n   */\n\n\n  async signWithSigner(signer) {\n    await signer.signTransaction(this);\n    return this;\n  }\n  /**\n   * Freeze the transaction using a signer\n   *\n   * This is part of the signature provider feature.\n   *\n   * @param {Signer} signer\n   * @returns {Promise<this>}\n   */\n\n\n  async freezeWithSigner(signer) {\n    await signer.populateTransaction(this);\n    this.freeze();\n    return this;\n  }\n  /**\n   * Serialize the request into bytes. This will encode all the transactions\n   * into a `proto.TransactionList` and return the encoded protobuf.\n   *\n   * **NOTE**: Does not support sign on demand\n   *\n   * @returns {Uint8Array}\n   */\n\n\n  toBytes() {\n    // If a user is attempting to serialize a transaction into bytes, then the\n    // transaction must be frozen.\n    this._requireFrozen(); // Sign on demand must be disabled because this is the non-async version and\n    // signing requires awaiting callbacks.\n\n\n    this._requireNotSignOnDemand(); // Locking the transaction IDs and node account IDs is necessary for consistency\n    // between before and after execution\n\n\n    this._transactionIds.setLocked();\n\n    this._nodeAccountIds.setLocked(); // Build all the transactions withot signing\n\n\n    this._buildAllTransactions(); // Construct and encode the transaction list\n\n\n    return HashgraphProto.proto.TransactionList.encode({\n      transactionList:\n      /** @type {HashgraphProto.proto.ITransaction[]} */\n      this._transactions.list\n    }).finish();\n  }\n  /**\n   * Serialize the transaction into bytes\n   *\n   * **NOTE**: Supports sign on demand\n   *\n   * @returns {Promise<Uint8Array>}\n   */\n\n\n  async toBytesAsync() {\n    // If sign on demand is enabled, we don't need to care about being frozen\n    // since we can just regenerate and resign later if some field of the transaction\n    // changes.\n    // Locking the transaction IDs and node account IDs is necessary for consistency\n    // between before and after execution\n    this._transactionIds.setLocked();\n\n    this._nodeAccountIds.setLocked(); // Build all transactions, and sign them\n\n\n    await this._buildAllTransactionsAsync(); // Lock transaction IDs, and node account IDs\n\n    this._transactions.setLocked();\n\n    this._signedTransactions.setLocked(); // Construct and encode the transaction list\n\n\n    return HashgraphProto.proto.TransactionList.encode({\n      transactionList:\n      /** @type {HashgraphProto.proto.ITransaction[]} */\n      this._transactions.list\n    }).finish();\n  }\n  /**\n   * Get the transaction hash\n   *\n   * @returns {Promise<Uint8Array>}\n   */\n\n\n  async getTransactionHash() {\n    this._requireFrozen(); // Locking the transaction IDs and node account IDs is necessary for consistency\n    // between before and after execution\n\n\n    this._transactionIds.setLocked();\n\n    this._nodeAccountIds.setLocked();\n\n    await this._buildAllTransactionsAsync();\n\n    this._transactions.setLocked();\n\n    this._signedTransactions.setLocked();\n\n    return sha384.digest(\n    /** @type {Uint8Array} */\n\n    /** @type {HashgraphProto.proto.ITransaction} */\n    this._transactions.get(0).signedTransactionBytes);\n  }\n  /**\n   * Get all the transaction hashes\n   *\n   * @returns {Promise<TransactionHashMap>}\n   */\n\n\n  async getTransactionHashPerNode() {\n    this._requireFrozen(); // Locking the transaction IDs and node account IDs is necessary for consistency\n    // between before and after execution\n\n\n    this._transactionIds.setLocked();\n\n    this._nodeAccountIds.setLocked();\n\n    await this._buildAllTransactionsAsync();\n    return await TransactionHashMap._fromTransaction(this);\n  }\n  /**\n   * Is transaction frozen\n   *\n   * @returns {boolean}\n   */\n\n\n  isFrozen() {\n    return this._signedTransactions.length > 0;\n  }\n  /**\n   * Get the current transaction ID, and make sure it's not null\n   *\n   * @protected\n   * @returns {TransactionId}\n   */\n\n\n  _getTransactionId() {\n    const transactionId = this.transactionId;\n\n    if (transactionId == null) {\n      throw new Error(\"transaction must have been frozen before getting the transaction ID, try calling `freeze`\");\n    }\n\n    return transactionId;\n  }\n  /**\n   * @param {Client} client\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/no-empty-function\n\n\n  _validateChecksums(client) {// Do nothing\n  }\n  /**\n   * Before we proceed exeuction, we need to do a couple checks\n   *\n   * @override\n   * @protected\n   * @param {import(\"../client/Client.js\").default<Channel, *>} client\n   * @returns {Promise<void>}\n   */\n\n\n  async _beforeExecute(client) {\n    // Makes ure we're frozen\n    if (!this._isFrozen()) {\n      this.freezeWith(client);\n    } // Valid checksums if the option is enabled\n\n\n    if (client.isAutoValidateChecksumsEnabled()) {\n      this._validateChecksums(client);\n    } // Set the operator if the client has one\n\n\n    this._operator = client != null ? client._operator : null;\n    this._operatorAccountId = client != null && client._operator != null ? client._operator.accountId : null; // If the client has an operaator, sign this request with the operator\n\n    if (this._operator != null) {\n      await this.signWith(this._operator.publicKey, this._operator.transactionSigner);\n    }\n  }\n  /**\n   * Construct a protobuf transaction\n   *\n   * @override\n   * @internal\n   * @returns {Promise<HashgraphProto.proto.ITransaction>}\n   */\n\n\n  async _makeRequestAsync() {\n    // The index for the transaction\n    const index = this._transactionIds.index * this._nodeAccountIds.length + this._nodeAccountIds.index; // If sign on demand is disabled we need to simply build that transaction\n    // and return the result, without signing\n\n    if (!this._signOnDemand) {\n      this._buildTransaction(index);\n\n      return (\n        /** @type {HashgraphProto.proto.ITransaction} */\n        this._transactions.get(index)\n      );\n    } // Build and sign a transaction\n\n\n    return await this._buildTransactionAsync();\n  }\n  /**\n   * Sign a `proto.SignedTransaction` with all the keys\n   *\n   * @private\n   * @returns {Promise<HashgraphProto.proto.ISignedTransaction>}\n   */\n\n\n  async _signTransaction() {\n    const signedTransaction = this._makeSignedTransaction(this._nodeAccountIds.next);\n\n    const bodyBytes =\n    /** @type {Uint8Array} */\n    signedTransaction.bodyBytes;\n\n    for (let j = 0; j < this._publicKeys.length; j++) {\n      const publicKey = this._publicKeys[j];\n      const transactionSigner = this._transactionSigners[j];\n\n      if (transactionSigner == null) {\n        continue;\n      }\n\n      const signature = await transactionSigner(bodyBytes);\n\n      if (signedTransaction.sigMap == null) {\n        signedTransaction.sigMap = {};\n      }\n\n      if (signedTransaction.sigMap.sigPair == null) {\n        signedTransaction.sigMap.sigPair = [];\n      }\n\n      signedTransaction.sigMap.sigPair.push(publicKey._toProtobufSignature(signature));\n    }\n\n    return signedTransaction;\n  }\n  /**\n   * Construct a new transaction ID at the current index\n   *\n   * @private\n   */\n\n\n  _buildNewTransactionIdList() {\n    if (this._transactionIds.locked || this._operatorAccountId == null) {\n      return;\n    }\n\n    const transactionId = TransactionId.withValidStart(this._operatorAccountId, Timestamp.generate());\n\n    this._transactionIds.set(this._transactionIds.index, transactionId);\n  }\n  /**\n   * Build each transaction in a loop\n   *\n   * @private\n   */\n\n\n  _buildAllTransactions() {\n    for (let i = 0; i < this._signedTransactions.length; i++) {\n      this._buildTransaction(i);\n    }\n  }\n  /**\n   * Build and and sign each transaction in a loop\n   *\n   * This method is primary used in the exist condition methods\n   * which are not `execute()`, e.g. `toBytesAsync()` and `getSignaturesAsync()`\n   *\n   * @private\n   */\n\n\n  async _buildAllTransactionsAsync() {\n    if (!this._signOnDemand) {\n      this._buildAllTransactions();\n\n      return;\n    }\n\n    this._buildSignedTransactions();\n\n    if (this._transactions.locked) {\n      return;\n    }\n\n    for (let i = 0; i < this._signedTransactions.length; i++) {\n      this._transactions.push(await this._buildTransactionAsync());\n    }\n  }\n  /**\n   * Build a transaction at a particular index\n   *\n   * @private\n   * @param {number} index\n   */\n\n\n  _buildTransaction(index) {\n    if (this._transactions.length < index) {\n      for (let i = this._transactions.length; i < index; i++) {\n        this._transactions.push(null);\n      }\n    }\n\n    this._transactions.setIfAbsent(index, () => {\n      return {\n        signedTransactionBytes: HashgraphProto.proto.SignedTransaction.encode(this._signedTransactions.get(index)).finish()\n      };\n    });\n  }\n  /**\n   * Build a trransaction using the current index, where the current\n   * index is determined by `this._nodeAccountIds.index` and\n   * `this._transactionIds.index`\n   *\n   * @private\n   * @returns {Promise<HashgraphProto.proto.ITransaction>}\n   */\n\n\n  async _buildTransactionAsync() {\n    return {\n      signedTransactionBytes: HashgraphProto.proto.SignedTransaction.encode(await this._signTransaction()).finish()\n    };\n  }\n  /**\n   * Determine what execution state we're in.\n   *\n   * @override\n   * @internal\n   * @param {HashgraphProto.proto.ITransaction} request\n   * @param {HashgraphProto.proto.ITransactionResponse} response\n   * @returns {[Status, ExecutionState]}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _shouldRetry(request, response) {\n    const {\n      nodeTransactionPrecheckCode\n    } = response; // Get the node precheck code, and convert it into an SDK `Status`\n\n    const status = Status._fromCode(nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : HashgraphProto.proto.ResponseCodeEnum.OK);\n\n    Logger.debug(`[${this._getLogId()}] received status ${status.toString()}`); // Based on the status what execution state are we in\n\n    switch (status) {\n      case Status.Busy:\n      case Status.Unknown:\n      case Status.PlatformTransactionNotCreated:\n      case Status.PlatformNotActive:\n        return [status, ExecutionState.Retry];\n\n      case Status.Ok:\n        return [status, ExecutionState.Finished];\n\n      case Status.TransactionExpired:\n        if (this._regenerateTransactionId == null || this._regenerateTransactionId) {\n          this._buildNewTransactionIdList();\n\n          return [status, ExecutionState.Retry];\n        } else {\n          return [status, ExecutionState.Error];\n        }\n\n      default:\n        return [status, ExecutionState.Error];\n    }\n  }\n  /**\n   * Map the request and response into a precheck status error\n   *\n   * @override\n   * @internal\n   * @param {HashgraphProto.proto.ITransaction} request\n   * @param {HashgraphProto.proto.ITransactionResponse} response\n   * @returns {Error}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _mapStatusError(request, response) {\n    const {\n      nodeTransactionPrecheckCode\n    } = response;\n\n    const status = Status._fromCode(nodeTransactionPrecheckCode != null ? nodeTransactionPrecheckCode : HashgraphProto.proto.ResponseCodeEnum.OK);\n\n    return new PrecheckStatusError({\n      status,\n      transactionId: this._getTransactionId()\n    });\n  }\n  /**\n   * Map the request, response, and node account ID into a `TransactionResponse`\n   *\n   * @override\n   * @protected\n   * @param {HashgraphProto.proto.ITransactionResponse} response\n   * @param {AccountId} nodeId\n   * @param {HashgraphProto.proto.ITransaction} request\n   * @returns {Promise<TransactionResponse>}\n   */\n\n\n  async _mapResponse(response, nodeId, request) {\n    const transactionHash = await sha384.digest(\n    /** @type {Uint8Array} */\n    request.signedTransactionBytes);\n\n    const transactionId = this._getTransactionId();\n\n    this._transactionIds.advance();\n\n    return new TransactionResponse({\n      nodeId,\n      transactionHash,\n      transactionId\n    });\n  }\n  /**\n   * Make a signed tranaction given a node account ID\n   *\n   * @internal\n   * @param {?AccountId} nodeId\n   * @returns {HashgraphProto.proto.ISignedTransaction}\n   */\n\n\n  _makeSignedTransaction(nodeId) {\n    const body = this._makeTransactionBody(nodeId);\n\n    const bodyBytes = HashgraphProto.proto.TransactionBody.encode(body).finish();\n    return {\n      bodyBytes,\n      sigMap: {\n        sigPair: []\n      }\n    };\n  }\n  /**\n   * Make a protobuf transaction body\n   *\n   * @private\n   * @param {?AccountId} nodeId\n   * @returns {HashgraphProto.proto.ITransactionBody}\n   */\n\n\n  _makeTransactionBody(nodeId) {\n    return {\n      [this._getTransactionDataCase()]: this._makeTransactionData(),\n      transactionFee: this._maxTransactionFee != null ? this._maxTransactionFee.toTinybars() : null,\n      memo: this._transactionMemo,\n      transactionID: this._transactionIds.current._toProtobuf(),\n      nodeAccountID: nodeId != null ? nodeId._toProtobuf() : null,\n      transactionValidDuration: {\n        seconds: Long.fromNumber(this._transactionValidDuration)\n      }\n    };\n  }\n  /**\n   * This method returns a key for the `data` field in a transaction body.\n   * Each transaction overwrite this to make sure when we build the transaction body\n   * we set the right data field.\n   *\n   * @abstract\n   * @protected\n   * @returns {NonNullable<HashgraphProto.proto.TransactionBody[\"data\"]>}\n   */\n\n\n  _getTransactionDataCase() {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * Make a scheduled transaction body\n   * FIXME: Should really call this `makeScheduledTransactionBody` to be consistent\n   *\n   * @internal\n   * @returns {HashgraphProto.proto.ISchedulableTransactionBody}\n   */\n\n\n  _getScheduledTransactionBody() {\n    return {\n      memo: this.transactionMemo,\n      transactionFee: this._maxTransactionFee == null ? this._defaultMaxTransactionFee.toTinybars() : this._maxTransactionFee.toTinybars(),\n      [this._getTransactionDataCase()]: this._makeTransactionData()\n    };\n  }\n  /**\n   * Make the transaction body data.\n   *\n   * @abstract\n   * @protected\n   * @returns {object}\n   */\n\n\n  _makeTransactionData() {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * FIXME: Why do we have `isFrozen` and `_isFrozen()`?\n   *\n   * @protected\n   * @returns {boolean}\n   */\n\n\n  _isFrozen() {\n    return this._signOnDemand || this._signedTransactions.length > 0 || this._transactions.length > 0;\n  }\n  /**\n   * Require the transaction to NOT be frozen\n   *\n   * @internal\n   */\n\n\n  _requireNotFrozen() {\n    if (this._isFrozen()) {\n      throw new Error(\"transaction is immutable; it has at least one signature or has been explicitly frozen\");\n    }\n  }\n  /**\n   * Require the transaction to have sign on demand disabled\n   *\n   * @internal\n   */\n\n\n  _requireNotSignOnDemand() {\n    if (this._signOnDemand) {\n      throw new Error(\"Please use `toBytesAsync()` if `signOnDemand` is enabled\");\n    }\n  }\n  /**\n   * Require the transaction to be frozen\n   *\n   * @internal\n   */\n\n\n  _requireFrozen() {\n    if (!this._isFrozen()) {\n      throw new Error(\"transaction must have been frozen before calculating the hash will be stable, try calling `freeze`\");\n    }\n  }\n  /**\n   * Require the transaction to have a single node account ID set\n   *\n   * @internal\n   * @protected\n   */\n\n\n  _requireOneNodeAccountId() {\n    if (this._nodeAccountIds.length != 1) {\n      throw \"transaction did not have exactly one node ID set\";\n    }\n  }\n  /**\n   * @param {HashgraphProto.proto.Transaction} request\n   * @returns {Uint8Array}\n   */\n\n\n  _requestToBytes(request) {\n    return HashgraphProto.proto.Transaction.encode(request).finish();\n  }\n  /**\n   * @param {HashgraphProto.proto.TransactionResponse} response\n   * @returns {Uint8Array}\n   */\n\n\n  _responseToBytes(response) {\n    return HashgraphProto.proto.TransactionResponse.encode(response).finish();\n  }\n\n}\n/**\n * This is essentially a registry/cache for a callback that creates a `ScheduleCreateTransaction`\n *\n * @type {(() => ScheduleCreateTransaction)[]}\n */\n\nexport const SCHEDULE_CREATE_TRANSACTION = [];","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/hbar-shop/hbar-shop-dashboard/node_modules/@hashgraph/sdk/src/transaction/Transaction.js"],"names":["Hbar","TransactionResponse","TransactionId","TransactionHashMap","SignatureMap","Executable","ExecutionState","Status","Long","sha384","hex","HashgraphProto","PrecheckStatusError","AccountId","PublicKey","List","Timestamp","Logger","util","DEFAULT_AUTO_RENEW_PERIOD","fromValue","DEFAULT_RECORD_THRESHOLD","fromTinybars","fromString","DEFAULT_TRANSACTION_VALID_DURATION","CHUNK_SIZE","TRANSACTION_REGISTRY","Map","Transaction","constructor","_transactions","_signedTransactions","_signerPublicKeys","Set","_transactionValidDuration","_defaultMaxTransactionFee","_maxTransactionFee","_transactionMemo","_transactionIds","_publicKeys","_transactionSigners","_regenerateTransactionId","fromBytes","bytes","signedTransactions","transactionIds","nodeIds","transactionIdStrings","nodeIdStrings","bodies","list","proto","TransactionList","decode","transactionList","length","transaction","signedTransactionBytes","push","SignedTransaction","encode","bodyBytes","sigMap","finish","Error","signedTransaction","body","TransactionBody","data","transactionID","transactionId","_fromProtobuf","includes","toString","nodeAccountID","nodeAccountId","fromProtobuf","get","schedule","_requireNotFrozen","SCHEDULE_CREATE_TRANSACTION","_setScheduledTransaction","_fromProtobufTransactions","transactions","i","j","compare","zero","equals","splice","setList","setLocked","_nodeAccountIds","transactionValidDuration","seconds","toInt","transactionFee","memo","sigPair","add","pubKeyPrefix","setNodeAccountIds","setTransactionValidDuration","validDuration","maxTransactionFee","setMaxTransactionFee","regenerateTransactionId","setRegenerateTransactionId","transactionMemo","setTransactionMemo","isEmpty","current","setTransactionId","sign","privateKey","signWith","publicKey","message","Promise","resolve","transactionSigner","_signOnDemand","_requireFrozen","publicKeyData","toBytesRaw","publicKeyHex","has","clear","signature","_toProtobufSignature","signWithOperator","client","operator","_operator","_isFrozen","freezeWith","addSignature","_requireOneNodeAccountId","isFrozen","freeze","getSignatures","_requireNotSignOnDemand","_buildAllTransactions","_fromTransaction","getSignaturesAsync","_buildAllTransactionsAsync","_setTransactionId","_operatorAccountId","_setNodeAccountIds","_network","getNodeAccountIdsForExecute","_buildSignedTransactions","locked","map","nodeId","_makeSignedTransaction","_freezeWithAccountId","accountId","signOnDemand","operatorAccountId","defaultMaxTransactionFee","defaultRegenerateTransactionId","validateChecksum","_buildNewTransactionIdList","signWithSigner","signer","signTransaction","freezeWithSigner","populateTransaction","toBytes","toBytesAsync","getTransactionHash","digest","getTransactionHashPerNode","_getTransactionId","_validateChecksums","_beforeExecute","isAutoValidateChecksumsEnabled","_makeRequestAsync","index","_buildTransaction","_buildTransactionAsync","_signTransaction","next","withValidStart","generate","set","setIfAbsent","_shouldRetry","request","response","nodeTransactionPrecheckCode","status","_fromCode","ResponseCodeEnum","OK","debug","_getLogId","Busy","Unknown","PlatformTransactionNotCreated","PlatformNotActive","Retry","Ok","Finished","TransactionExpired","_mapStatusError","_mapResponse","transactionHash","advance","_makeTransactionBody","_getTransactionDataCase","_makeTransactionData","toTinybars","_toProtobuf","fromNumber","_getScheduledTransactionBody","_requestToBytes","_responseToBytes"],"mappings":"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","sourcesContent":["/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\n\nimport Hbar from \"../Hbar.js\";\nimport TransactionResponse from \"./TransactionResponse.js\";\nimport TransactionId from \"./TransactionId.js\";\nimport TransactionHashMap from \"./TransactionHashMap.js\";\nimport SignatureMap from \"./SignatureMap.js\";\nimport Executable, { ExecutionState } from \"../Executable.js\";\nimport Status from \"../Status.js\";\nimport Long from \"long\";\nimport * as sha384 from \"../cryptography/sha384.js\";\nimport * as hex from \"../encoding/hex.js\";\nimport * as HashgraphProto from \"@hashgraph/proto\";\nimport PrecheckStatusError from \"../PrecheckStatusError.js\";\nimport AccountId from \"../account/AccountId.js\";\nimport PublicKey from \"../PublicKey.js\";\nimport List from \"./List.js\";\nimport Timestamp from \"../Timestamp.js\";\nimport Logger from \"js-logger\";\nimport * as util from \"../util.js\";\n\n/**\n * @typedef {import(\"bignumber.js\").default} BigNumber\n */\n\n/**\n * @typedef {import(\"../schedule/ScheduleCreateTransaction.js\").default} ScheduleCreateTransaction\n * @typedef {import(\"../PrivateKey.js\").default} PrivateKey\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../client/Client.js\").default<*, *>} Client\n * @typedef {import(\"../Signer.js\").Signer} Signer\n */\n\n// 90 days (in seconds)\nexport const DEFAULT_AUTO_RENEW_PERIOD = Long.fromValue(7776000);\n\n// maximum value of i64 (so there is never a record generated)\nexport const DEFAULT_RECORD_THRESHOLD = Hbar.fromTinybars(\n    Long.fromString(\"9223372036854775807\")\n);\n\n// 120 seconds\nconst DEFAULT_TRANSACTION_VALID_DURATION = 120;\n\nexport const CHUNK_SIZE = 1024;\n\n/**\n * @type {Map<NonNullable<HashgraphProto.proto.TransactionBody[\"data\"]>, (transactions: HashgraphProto.proto.ITransaction[], signedTransactions: HashgraphProto.proto.ISignedTransaction[], transactionIds: TransactionId[], nodeIds: AccountId[], bodies: HashgraphProto.proto.TransactionBody[]) => Transaction>}\n */\nexport const TRANSACTION_REGISTRY = new Map();\n\n/**\n * Base class for all transactions that may be submitted to Hedera.\n *\n * @abstract\n * @augments {Executable<HashgraphProto.proto.ITransaction, HashgraphProto.proto.ITransactionResponse, TransactionResponse>}\n */\nexport default class Transaction extends Executable {\n    // A SDK transaction is composed of multiple, raw protobuf transactions.\n    // These should be functionally identical, with the exception of pointing to\n    // different nodes.\n\n    // When retrying a transaction after a network error or retry-able\n    // status response, we try a different transaction and thus a different node.\n\n    constructor() {\n        super();\n\n        /**\n         * List of proto transactions that have been built from this SDK\n         * transaction.\n         *\n         * This is a 2-D array built into one, meaning to\n         * get to the next row you'd index into this array `row * rowLength + column`\n         * where `rowLength` is `nodeAccountIds.length`\n         *\n         * @internal\n         * @type {List<HashgraphProto.proto.ITransaction | null>}\n         */\n        this._transactions = new List();\n\n        /**\n         * List of proto transactions that have been built from this SDK\n         * transaction.\n         *\n         * This is a 2-D array built into one, meaning to\n         * get to the next row you'd index into this array `row * rowLength + column`\n         * where `rowLength` is `nodeAccountIds.length`\n         *\n         * @internal\n         * @type {List<HashgraphProto.proto.ISignedTransaction>}\n         */\n        this._signedTransactions = new List();\n\n        /**\n         * Set of public keys (as string) who have signed this transaction so\n         * we do not allow them to sign it again.\n         *\n         * @internal\n         * @type {Set<string>}\n         */\n        this._signerPublicKeys = new Set();\n\n        /**\n         * The transaction valid duration\n         *\n         * @private\n         * @type {number}\n         */\n        this._transactionValidDuration = DEFAULT_TRANSACTION_VALID_DURATION;\n\n        /**\n         * The default max transaction fee for this particular transaction type.\n         * Most transactions use the default of 2 Hbars, but some requests such\n         * as `TokenCreateTransaction` need to use a different default value.\n         *\n         * @protected\n         * @type {Hbar}\n         */\n        this._defaultMaxTransactionFee = new Hbar(2);\n\n        /**\n         * The max transaction fee on the request. This field is what users are able\n         * to set, not the `defaultMaxTransactionFee`. The purpose of this field is\n         * to allow us to determine if the user set the field explicitly, or if we're\n         * using the default max transation fee for the request.\n         *\n         * @private\n         * @type {Hbar | null}\n         */\n        this._maxTransactionFee = null;\n\n        /**\n         * The transaction's memo\n         *\n         * @private\n         * @type {string}\n         */\n        this._transactionMemo = \"\";\n\n        /**\n         * The list of transaction IDs. This list will almost always be of length 1.\n         * The only time this list will be a different length is for chunked transactions.\n         * The only two chunked transactions supported right now are `FileAppendTransaction`\n         * and `TopicMessageSubmitTransaction`\n         *\n         * @protected\n         * @type {List<TransactionId>}\n         */\n        this._transactionIds = new List();\n\n        /**\n         * A list of public keys that will be added to the requests signatures\n         *\n         * @private\n         * @type {PublicKey[]}\n         */\n        this._publicKeys = [];\n\n        /**\n         * The list of signing function 1-1 with `_publicKeys` which sign the request.\n         * The reason this list allows `null` is because if we go from bytes into\n         * a transaction, then we know the public key, but we don't have the signing function.\n         *\n         * @private\n         * @type {(((message: Uint8Array) => Promise<Uint8Array>) | null)[]}\n         */\n        this._transactionSigners = [];\n\n        /**\n         * Determine if we should regenerate transaction IDs when we receive `TRANSACITON_EXPIRED`\n         *\n         * @private\n         * @type {?boolean}\n         */\n        this._regenerateTransactionId = null;\n    }\n\n    /**\n     * Deserialize a transaction from bytes. The bytes can either be a `proto.Transaction` or\n     * `proto.TransactionList`.\n     *\n     * @param {Uint8Array} bytes\n     * @returns {Transaction}\n     */\n    static fromBytes(bytes) {\n        const signedTransactions = [];\n        const transactionIds = [];\n        const nodeIds = [];\n\n        /** @type {string[]} */\n        const transactionIdStrings = [];\n\n        /** @type {string[]} */\n        const nodeIdStrings = [];\n\n        const bodies = [];\n\n        const list =\n            HashgraphProto.proto.TransactionList.decode(bytes).transactionList;\n\n        // If the list is of length 0, then teh bytes provided were not a\n        // `proto.TransactionList`\n        //\n        // FIXME: We should also check to make sure the bytes length is greater than\n        // 0 otherwise this check is wrong?\n        if (list.length === 0) {\n            const transaction = HashgraphProto.proto.Transaction.decode(bytes);\n\n            // We support `Transaction.signedTransactionBytes` and\n            // `Transaction.bodyBytes` + `Transaction.sigMap`. If the bytes represent the\n            // latter, convert them into `signedTransactionBytes`\n            if (transaction.signedTransactionBytes.length !== 0) {\n                list.push(transaction);\n            } else {\n                list.push({\n                    signedTransactionBytes:\n                        HashgraphProto.proto.SignedTransaction.encode({\n                            bodyBytes: transaction.bodyBytes,\n                            sigMap: transaction.sigMap,\n                        }).finish(),\n                });\n            }\n        }\n\n        // This loop is responsible for fill out the `signedTransactions`, `transactionIds`,\n        // `nodeIds`, and `bodies` variables.\n        for (const transaction of list) {\n            // The `signedTransactionBytes` should not be null\n            if (transaction.signedTransactionBytes == null) {\n                throw new Error(\"Transaction.signedTransactionBytes are null\");\n            }\n\n            // Decode a signed transaction\n            const signedTransaction =\n                HashgraphProto.proto.SignedTransaction.decode(\n                    transaction.signedTransactionBytes\n                );\n            signedTransactions.push(signedTransaction);\n\n            // Decode a transaction body\n            const body = HashgraphProto.proto.TransactionBody.decode(\n                signedTransaction.bodyBytes\n            );\n\n            // Make sure the body is set\n            if (body.data == null) {\n                throw new Error(\"(BUG) body.data was not set in the protobuf\");\n            }\n\n            bodies.push(body);\n\n            // Make sure the transaction ID within the body is set\n            if (body.transactionID != null) {\n                const transactionId = TransactionId._fromProtobuf(\n                    /** @type {HashgraphProto.proto.ITransactionID} */ (\n                        body.transactionID\n                    )\n                );\n\n                // If we haven't already seen this transaction ID in the list, add it\n                if (!transactionIdStrings.includes(transactionId.toString())) {\n                    transactionIds.push(transactionId);\n                    transactionIdStrings.push(transactionId.toString());\n                }\n            }\n\n            // Make sure the node account ID within the body is set\n            if (body.nodeAccountID != null) {\n                const nodeAccountId = AccountId._fromProtobuf(\n                    /** @type {HashgraphProto.proto.IAccountID} */ (\n                        body.nodeAccountID\n                    )\n                );\n\n                // If we haven't already seen this node account ID in the list, add it\n                if (!nodeIdStrings.includes(nodeAccountId.toString())) {\n                    nodeIds.push(nodeAccountId);\n                    nodeIdStrings.push(nodeAccountId.toString());\n                }\n            }\n        }\n\n        // FIXME: We should have a length check before we access `0` since that would error\n        const body = bodies[0];\n\n        // We should have at least more than one body\n        if (body == null || body.data == null) {\n            throw new Error(\n                \"No transaction found in bytes or failed to decode TransactionBody\"\n            );\n        }\n\n        // Use the registry to call the right transaction's `fromProtobuf` method based\n        // on the `body.data` string\n        const fromProtobuf = TRANSACTION_REGISTRY.get(body.data); //NOSONAR\n\n        // If we forgot to update the registry we should error\n        if (fromProtobuf == null) {\n            throw new Error(\n                `(BUG) Transaction.fromBytes() not implemented for type ${body.data}`\n            );\n        }\n\n        // That the specific transaction type from protobuf implementation and pass in all the\n        // information we've gathered.\n        return fromProtobuf(\n            list,\n            signedTransactions,\n            transactionIds,\n            nodeIds,\n            bodies\n        );\n    }\n\n    /**\n     * Convert this transaction a `ScheduleCreateTransaction`\n     *\n     * @returns {ScheduleCreateTransaction}\n     */\n    schedule() {\n        this._requireNotFrozen();\n\n        if (SCHEDULE_CREATE_TRANSACTION.length != 1) {\n            throw new Error(\n                \"ScheduleCreateTransaction has not been loaded yet\"\n            );\n        }\n\n        return SCHEDULE_CREATE_TRANSACTION[0]()._setScheduledTransaction(this);\n    }\n\n    /**\n     * This method is called by each `*Transaction._fromProtobuf()` method. It does\n     * all the finalization before the user gets hold of a complete `Transaction`\n     *\n     * @template {Transaction} TransactionT\n     * @param {TransactionT} transaction\n     * @param {HashgraphProto.proto.ITransaction[]} transactions\n     * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions\n     * @param {TransactionId[]} transactionIds\n     * @param {AccountId[]} nodeIds\n     * @param {HashgraphProto.proto.ITransactionBody[]} bodies\n     * @returns {TransactionT}\n     */\n    static _fromProtobufTransactions(\n        transaction,\n        transactions,\n        signedTransactions,\n        transactionIds,\n        nodeIds,\n        bodies\n    ) {\n        const body = bodies[0];\n\n        // \"row\" of the 2-D `bodies` array has all the same contents except for `nodeAccountID`\n        for (let i = 0; i < transactionIds.length; i++) {\n            for (let j = 0; j < nodeIds.length - 1; j++) {\n                if (\n                    !util.compare(\n                        bodies[i * nodeIds.length + j],\n                        bodies[i * nodeIds.length + j + 1],\n                        // eslint-disable-next-line ie11/no-collection-args\n                        new Set([\"nodeAccountID\"])\n                    )\n                ) {\n                    throw new Error(\"failed to validate transaction bodies\");\n                }\n            }\n        }\n\n        // Remove node account IDs of 0\n        // _IIRC_ this was initial due to some funny behavior with `ScheduleCreateTransaction`\n        // We may be able to remove this.\n        const zero = new AccountId(0);\n        for (let i = 0; i < nodeIds.length; i++) {\n            if (nodeIds[i].equals(zero)) {\n                nodeIds.splice(i--, 1);\n            }\n        }\n\n        // Set the transactions accordingly, but don't lock the list because transactions can\n        // be regenerated if more signatures are added\n        transaction._transactions.setList(transactions);\n\n        // Set the signed transactions accordingly, and lock the list since signed transaction\n        // will not be regenerated. Although, they can be manipulated if for instance more\n        // signatures are added\n        transaction._signedTransactions.setList(signedTransactions).setLocked();\n\n        // Set the transaction IDs accordingly, and lock the list. Transaction IDs should not\n        // be regenerated if we're deserializing a request from bytes\n        transaction._transactionIds.setList(transactionIds).setLocked();\n\n        // Set the node account IDs accordingly, and lock the list. Node account IDs should\n        // never be changed if we're deserializing a request from bytes\n        transaction._nodeAccountIds.setList(nodeIds).setLocked();\n\n        // Make sure to update the rest of the fields\n        transaction._transactionValidDuration =\n            body.transactionValidDuration != null &&\n            body.transactionValidDuration.seconds != null\n                ? Long.fromValue(body.transactionValidDuration.seconds).toInt()\n                : DEFAULT_TRANSACTION_VALID_DURATION;\n        transaction._maxTransactionFee =\n            body.transactionFee != null\n                ? Hbar.fromTinybars(body.transactionFee)\n                : new Hbar(0);\n        transaction._transactionMemo = body.memo != null ? body.memo : \"\";\n\n        // Loop over a single row of `signedTransactions` and add all the public\n        // keys to the `signerPublicKeys` set, and `publicKeys` list with\n        // `null` in the `transactionSigners` at the same index.\n        for (let i = 0; i < nodeIds.length; i++) {\n            const signedTransaction = signedTransactions[i];\n            if (\n                signedTransaction.sigMap != null &&\n                signedTransaction.sigMap.sigPair != null\n            ) {\n                for (const sigPair of signedTransaction.sigMap.sigPair) {\n                    transaction._signerPublicKeys.add(\n                        hex.encode(\n                            /** @type {Uint8Array} */ (sigPair.pubKeyPrefix)\n                        )\n                    );\n\n                    transaction._publicKeys.push(\n                        PublicKey.fromBytes(\n                            /** @type {Uint8Array} */ (sigPair.pubKeyPrefix)\n                        )\n                    );\n                    transaction._transactionSigners.push(null);\n                }\n            }\n        }\n\n        return transaction;\n    }\n\n    /**\n     * Set the node account IDs\n     *\n     * @override\n     * @param {AccountId[]} nodeIds\n     * @returns {this}\n     */\n    setNodeAccountIds(nodeIds) {\n        // The reason we overwrite this method is simply because we need to call `requireNotFrozen()`\n        // Now that I think of it, we could just add an abstract method `setterPrerequiest()` which\n        // by default does nothing, and `Executable` can call. Then we'd only need to overwrite that\n        // method once.\n        this._requireNotFrozen();\n        super.setNodeAccountIds(nodeIds);\n        return this;\n    }\n\n    /**\n     * Get the transaction valid duration\n     *\n     * @returns {number}\n     */\n    get transactionValidDuration() {\n        return this._transactionValidDuration;\n    }\n\n    /**\n     * Sets the duration (in seconds) that this transaction is valid for.\n     *\n     * This is defaulted to 120 seconds (from the time its executed).\n     *\n     * @param {number} validDuration\n     * @returns {this}\n     */\n    setTransactionValidDuration(validDuration) {\n        this._requireNotFrozen();\n        this._transactionValidDuration = validDuration;\n\n        return this;\n    }\n\n    /**\n     * Get the max transaction fee\n     *\n     * @returns {?Hbar}\n     */\n    get maxTransactionFee() {\n        return this._maxTransactionFee;\n    }\n\n    /**\n     * Set the maximum transaction fee the operator (paying account)\n     * is willing to pay.\n     *\n     * @param {number | string | Long | BigNumber | Hbar} maxTransactionFee\n     * @returns {this}\n     */\n    setMaxTransactionFee(maxTransactionFee) {\n        this._requireNotFrozen();\n        this._maxTransactionFee =\n            maxTransactionFee instanceof Hbar\n                ? maxTransactionFee\n                : new Hbar(maxTransactionFee);\n\n        return this;\n    }\n\n    /**\n     * Is transaction ID regeneration enabled\n     *\n     * @returns {?boolean}\n     */\n    get regenerateTransactionId() {\n        return this._regenerateTransactionId;\n    }\n\n    /**\n     * Set the maximum transaction fee the operator (paying account)\n     * is willing to pay.\n     *\n     * @param {boolean} regenerateTransactionId\n     * @returns {this}\n     */\n    setRegenerateTransactionId(regenerateTransactionId) {\n        this._requireNotFrozen();\n        this._regenerateTransactionId = regenerateTransactionId;\n\n        return this;\n    }\n\n    /**\n     * Get the transaction memo\n     *\n     * @returns {string}\n     */\n    get transactionMemo() {\n        return this._transactionMemo;\n    }\n\n    /**\n     * Set a note or description to be recorded in the transaction\n     * record (maximum length of 100 bytes).\n     *\n     * @param {string} transactionMemo\n     * @returns {this}\n     */\n    setTransactionMemo(transactionMemo) {\n        this._requireNotFrozen();\n        this._transactionMemo = transactionMemo;\n\n        return this;\n    }\n\n    /**\n     * Get the curent transaction ID\n     *\n     * @returns {?TransactionId}\n     */\n    get transactionId() {\n        if (this._transactionIds.isEmpty) {\n            return null;\n        }\n\n        // If a user calls `.transactionId` that means we need to use that transaction ID\n        // and **not** regenerate it. To do this, we simply lock the transaction ID list.\n        //\n        // This may be a little conffusing since a user can enable transaction ID regenration\n        // explicity, but if they call `.transactionId` then we will not regenerate transaction\n        // IDs.\n        this._transactionIds.setLocked();\n\n        return this._transactionIds.current;\n    }\n\n    /**\n     * Set the ID for this transaction.\n     *\n     * The transaction ID includes the operator's account ( the account paying the transaction\n     * fee). If two transactions have the same transaction ID, they won't both have an effect. One\n     * will complete normally and the other will fail with a duplicate transaction status.\n     *\n     * Normally, you should not use this method. Just before a transaction is executed, a\n     * transaction ID will be generated from the operator on the client.\n     *\n     * @param {TransactionId} transactionId\n     * @returns {this}\n     */\n    setTransactionId(transactionId) {\n        this._requireNotFrozen();\n        this._transactionIds.setList([transactionId]).setLocked();\n\n        return this;\n    }\n\n    /**\n     * Sign the transaction with the private key\n     * **NOTE**: This is a thin wrapper around `.signWith()`\n     *\n     * @param {PrivateKey} privateKey\n     * @returns {Promise<this>}\n     */\n    sign(privateKey) {\n        return this.signWith(privateKey.publicKey, (message) =>\n            Promise.resolve(privateKey.sign(message))\n        );\n    }\n\n    /**\n     * Sign the transaction with the public key and signer function\n     *\n     * If sign on demand is enabled no signing will be done immediately, instead\n     * the private key signing function and public key are saved to be used when\n     * a user calls an exit condition method (not sure what a better name for this is)\n     * such as `toBytes[Async]()`, `getTransactionHash[PerNode]()` or `execute()`.\n     *\n     * @param {PublicKey} publicKey\n     * @param {(message: Uint8Array) => Promise<Uint8Array>} transactionSigner\n     * @returns {Promise<this>}\n     */\n    async signWith(publicKey, transactionSigner) {\n        // If signing on demand is disabled, we need to make sure\n        // the request is frozen\n        if (!this._signOnDemand) {\n            this._requireFrozen();\n        }\n\n        const publicKeyData = publicKey.toBytesRaw();\n\n        // note: this omits the DER prefix on purpose because Hedera doesn't\n        // support that in the protobuf. this means that we would fail\n        // to re-inflate [this._signerPublicKeys] during [fromBytes] if we used DER\n        // prefixes here\n        const publicKeyHex = hex.encode(publicKeyData);\n\n        if (this._signerPublicKeys.has(publicKeyHex)) {\n            // this public key has already signed this transaction\n            return this;\n        }\n\n        // If we add a new signer, then we need to re-create all transactions\n        this._transactions.clear();\n\n        // Save the current public key so we don't attempt to sign twice\n        this._signerPublicKeys.add(publicKeyHex);\n\n        // If signing on demand is enabled we will save the public key and signer and return\n        if (this._signOnDemand) {\n            this._publicKeys.push(publicKey);\n            this._transactionSigners.push(transactionSigner);\n\n            return this;\n        }\n\n        // If we get here, signing on demand is disabled, this means the transaction\n        // is frozen and we need to sign all the transactions immediately. If we're\n        // signing all the transactions immediately, we need to lock the node account IDs\n        // and transaction IDs.\n        // Now that I think of it, this code should likely exist in `freezeWith()`?\n        this._transactionIds.setLocked();\n        this._nodeAccountIds.setLocked();\n\n        // Sign each signed transatcion\n        for (const signedTransaction of this._signedTransactions.list) {\n            const bodyBytes = /** @type {Uint8Array} */ (\n                signedTransaction.bodyBytes\n            );\n            const signature = await transactionSigner(bodyBytes);\n\n            if (signedTransaction.sigMap == null) {\n                signedTransaction.sigMap = {};\n            }\n\n            if (signedTransaction.sigMap.sigPair == null) {\n                signedTransaction.sigMap.sigPair = [];\n            }\n\n            signedTransaction.sigMap.sigPair.push(\n                publicKey._toProtobufSignature(signature)\n            );\n        }\n\n        return this;\n    }\n\n    /**\n     * Sign the transaction with the client operator. This is a thin wrapper\n     * around `.signWith()`\n     *\n     * **NOTE**: If client does not have an operator set, this method will throw\n     *\n     * @param {import(\"../client/Client.js\").default<Channel, *>} client\n     * @returns {Promise<this>}\n     */\n    signWithOperator(client) {\n        const operator = client._operator;\n\n        if (operator == null) {\n            throw new Error(\n                \"`client` must have an operator to sign with the operator\"\n            );\n        }\n\n        if (!this._isFrozen()) {\n            this.freezeWith(client);\n        }\n\n        return this.signWith(operator.publicKey, operator.transactionSigner);\n    }\n\n    /**\n     * Add a signature explicitly\n     *\n     * This method requires the transaction to have exactly 1 node account ID set\n     * since different node account IDs have different byte representations and\n     * hence the same signature would not work for all transactions that are the same\n     * except for node account ID being different.\n     *\n     * @param {PublicKey} publicKey\n     * @param {Uint8Array} signature\n     * @returns {this}\n     */\n    addSignature(publicKey, signature) {\n        // Require that only one node is set on this transaction\n        // FIXME: This doesn't consider if we have one node account ID set, but we're\n        // also a chunked transaction. We should also check transaction IDs is of length 1\n        this._requireOneNodeAccountId();\n\n        // If the transaction isn't frozen, freeze it.\n        if (!this.isFrozen()) {\n            this.freeze();\n        }\n\n        const publicKeyData = publicKey.toBytesRaw();\n        const publicKeyHex = hex.encode(publicKeyData);\n\n        if (this._signerPublicKeys.has(publicKeyHex)) {\n            // this public key has already signed this transaction\n            return this;\n        }\n\n        // Transactions will have to be regenerated\n        this._transactions.clear();\n\n        // Locking the transaction IDs and node account IDs is necessary for consistency\n        // between before and after execution\n        this._transactionIds.setLocked();\n        this._nodeAccountIds.setLocked();\n        this._signedTransactions.setLocked();\n\n        // Add the signature to the signed transaction list. This is a copy paste\n        // of `.signWith()`, but it really shouldn't be if `_signedTransactions.list`\n        // must be a length of one.\n        // FIXME: Remove unnecessary for loop.\n        for (const transaction of this._signedTransactions.list) {\n            if (transaction.sigMap == null) {\n                transaction.sigMap = {};\n            }\n\n            if (transaction.sigMap.sigPair == null) {\n                transaction.sigMap.sigPair = [];\n            }\n\n            transaction.sigMap.sigPair.push(\n                publicKey._toProtobufSignature(signature)\n            );\n        }\n\n        this._signerPublicKeys.add(publicKeyHex);\n        this._publicKeys.push(publicKey);\n        this._transactionSigners.push(null);\n\n        return this;\n    }\n\n    /**\n     * Get the current signatures on the request\n     *\n     * **NOTE**: Does NOT support sign on demand\n     *\n     * @returns {SignatureMap}\n     */\n    getSignatures() {\n        // If a user is attempting to get signatures for a transaction, then the\n        // transaction must be frozen.\n        this._requireFrozen();\n\n        // Sign on demand must be disabled because this is the non-async version and\n        // signing requires awaiting callbacks.\n        this._requireNotSignOnDemand();\n\n        // Build all the transactions\n        this._buildAllTransactions();\n\n        // Lock transaction IDs, and node account IDs\n        this._transactionIds.setLocked();\n        this._nodeAccountIds.setLocked();\n\n        // Construct a signature map from this transaction\n        return SignatureMap._fromTransaction(this);\n    }\n\n    /**\n     * Get the current signatures on the request\n     *\n     * **NOTE**: Supports sign on demand\n     *\n     * @returns {Promise<SignatureMap>}\n     */\n    async getSignaturesAsync() {\n        // If sign on demand is enabled, we don't need to care about being frozen\n        // since we can just regenerate and resign later if some field of the transaction\n        // changes.\n\n        // Locking the transaction IDs and node account IDs is necessary for consistency\n        // between before and after execution\n        this._transactionIds.setLocked();\n        this._nodeAccountIds.setLocked();\n\n        // Build all transactions, and sign them\n        await this._buildAllTransactionsAsync();\n\n        // Lock transaction IDs, and node account IDs\n        this._transactions.setLocked();\n        this._signedTransactions.setLocked();\n\n        // Construct a signature map from this transaction\n        return SignatureMap._fromTransaction(this);\n    }\n\n    /**\n     * Not sure why this is called `setTransactionId()` when it doesn't set anything...\n     * FIXME: Remove this?\n     */\n    _setTransactionId() {\n        if (this._operatorAccountId == null && this._transactionIds.isEmpty) {\n            throw new Error(\n                \"`transactionId` must be set or `client` must be provided with `freezeWith`\"\n            );\n        }\n    }\n\n    /**\n     * Set the node account IDs using the client\n     *\n     * @param {?import(\"../client/Client.js\").default<Channel, *>} client\n     */\n    _setNodeAccountIds(client) {\n        if (!this._nodeAccountIds.isEmpty) {\n            return;\n        }\n\n        if (client == null) {\n            throw new Error(\n                \"`nodeAccountId` must be set or `client` must be provided with `freezeWith`\"\n            );\n        }\n\n        this._nodeAccountIds.setList(\n            client._network.getNodeAccountIdsForExecute()\n        );\n    }\n\n    /**\n     * Build all the signed transactions from the node account IDs\n     *\n     * @private\n     */\n    _buildSignedTransactions() {\n        if (this._signedTransactions.locked) {\n            return;\n        }\n\n        this._signedTransactions.setList(\n            this._nodeAccountIds.list.map((nodeId) =>\n                this._makeSignedTransaction(nodeId)\n            )\n        );\n    }\n\n    /**\n     * Freeze this transaction from future modification to prepare for\n     * signing or serialization.\n     *\n     * @returns {this}\n     */\n    freeze() {\n        return this.freezeWith(null);\n    }\n\n    /**\n     * @param {?AccountId} accountId\n     */\n    _freezeWithAccountId(accountId) {\n        if (this._operatorAccountId == null) {\n            this._operatorAccountId = accountId;\n        }\n    }\n\n    /**\n     * Freeze this transaction from further modification to prepare for\n     * signing or serialization.\n     *\n     * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3\n     * nodes to prepare this transaction for.\n     *\n     * @param {?import(\"../client/Client.js\").default<Channel, *>} client\n     * @returns {this}\n     */\n    freezeWith(client) {\n        // Set sign on demand based on client\n        this._signOnDemand = client != null ? client.signOnDemand : false;\n\n        // Save the operator\n        this._operator = client != null ? client._operator : null;\n        this._freezeWithAccountId(\n            client != null ? client.operatorAccountId : null\n        );\n\n        // Set max transaction fee to either `this._maxTransactionFee`,\n        // `client._defaultMaxTransactionFee`, or `this._defaultMaxTransactionFee`\n        // in that priority order depending on if `this._maxTransactionFee` has\n        // been set or if `client._defaultMaxTransactionFee` has been set.\n        this._maxTransactionFee =\n            this._maxTransactionFee == null\n                ? client != null && client.defaultMaxTransactionFee != null\n                    ? client.defaultMaxTransactionFee\n                    : this._defaultMaxTransactionFee\n                : this._maxTransactionFee;\n\n        // Determine if transaction ID generation should be enabled.\n        this._regenerateTransactionId =\n            client != null && this._regenerateTransactionId == null\n                ? client.defaultRegenerateTransactionId\n                : this._regenerateTransactionId;\n\n        // Set the node account IDs via client\n        this._setNodeAccountIds(client);\n\n        // Make sure a transaction ID or operator is set.\n        this._setTransactionId();\n\n        // If a client was not provided, we need to make sure the transaction ID already set\n        // validates aginst the client.\n        if (client != null) {\n            for (const transactionId of this._transactionIds.list) {\n                if (transactionId.accountId != null) {\n                    transactionId.accountId.validateChecksum(client);\n                }\n            }\n        }\n\n        // Build a list of transaction IDs so that if a user calls `.transactionId` they'll\n        // get a value, but if they dont' we'll just regenerate transaction IDs during execution\n        this._buildNewTransactionIdList();\n\n        // If sign on demand is disabled we need to build out all the signed transactions\n        if (!this._signOnDemand) {\n            this._buildSignedTransactions();\n        }\n\n        return this;\n    }\n\n    /**\n     * Sign the transaction using a signer\n     *\n     * This is part of the signature provider feature\n     *\n     * @param {Signer} signer\n     * @returns {Promise<this>}\n     */\n    async signWithSigner(signer) {\n        await signer.signTransaction(this);\n        return this;\n    }\n\n    /**\n     * Freeze the transaction using a signer\n     *\n     * This is part of the signature provider feature.\n     *\n     * @param {Signer} signer\n     * @returns {Promise<this>}\n     */\n    async freezeWithSigner(signer) {\n        await signer.populateTransaction(this);\n        this.freeze();\n        return this;\n    }\n\n    /**\n     * Serialize the request into bytes. This will encode all the transactions\n     * into a `proto.TransactionList` and return the encoded protobuf.\n     *\n     * **NOTE**: Does not support sign on demand\n     *\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        // If a user is attempting to serialize a transaction into bytes, then the\n        // transaction must be frozen.\n        this._requireFrozen();\n\n        // Sign on demand must be disabled because this is the non-async version and\n        // signing requires awaiting callbacks.\n        this._requireNotSignOnDemand();\n\n        // Locking the transaction IDs and node account IDs is necessary for consistency\n        // between before and after execution\n        this._transactionIds.setLocked();\n        this._nodeAccountIds.setLocked();\n\n        // Build all the transactions withot signing\n        this._buildAllTransactions();\n\n        // Construct and encode the transaction list\n        return HashgraphProto.proto.TransactionList.encode({\n            transactionList:\n                /** @type {HashgraphProto.proto.ITransaction[]} */ (\n                    this._transactions.list\n                ),\n        }).finish();\n    }\n\n    /**\n     * Serialize the transaction into bytes\n     *\n     * **NOTE**: Supports sign on demand\n     *\n     * @returns {Promise<Uint8Array>}\n     */\n    async toBytesAsync() {\n        // If sign on demand is enabled, we don't need to care about being frozen\n        // since we can just regenerate and resign later if some field of the transaction\n        // changes.\n\n        // Locking the transaction IDs and node account IDs is necessary for consistency\n        // between before and after execution\n        this._transactionIds.setLocked();\n        this._nodeAccountIds.setLocked();\n\n        // Build all transactions, and sign them\n        await this._buildAllTransactionsAsync();\n\n        // Lock transaction IDs, and node account IDs\n        this._transactions.setLocked();\n        this._signedTransactions.setLocked();\n\n        // Construct and encode the transaction list\n        return HashgraphProto.proto.TransactionList.encode({\n            transactionList:\n                /** @type {HashgraphProto.proto.ITransaction[]} */ (\n                    this._transactions.list\n                ),\n        }).finish();\n    }\n\n    /**\n     * Get the transaction hash\n     *\n     * @returns {Promise<Uint8Array>}\n     */\n    async getTransactionHash() {\n        this._requireFrozen();\n\n        // Locking the transaction IDs and node account IDs is necessary for consistency\n        // between before and after execution\n        this._transactionIds.setLocked();\n        this._nodeAccountIds.setLocked();\n\n        await this._buildAllTransactionsAsync();\n\n        this._transactions.setLocked();\n        this._signedTransactions.setLocked();\n\n        return sha384.digest(\n            /** @type {Uint8Array} */ (\n                /** @type {HashgraphProto.proto.ITransaction} */ (\n                    this._transactions.get(0)\n                ).signedTransactionBytes\n            )\n        );\n    }\n\n    /**\n     * Get all the transaction hashes\n     *\n     * @returns {Promise<TransactionHashMap>}\n     */\n    async getTransactionHashPerNode() {\n        this._requireFrozen();\n\n        // Locking the transaction IDs and node account IDs is necessary for consistency\n        // between before and after execution\n        this._transactionIds.setLocked();\n        this._nodeAccountIds.setLocked();\n\n        await this._buildAllTransactionsAsync();\n\n        return await TransactionHashMap._fromTransaction(this);\n    }\n\n    /**\n     * Is transaction frozen\n     *\n     * @returns {boolean}\n     */\n    isFrozen() {\n        return this._signedTransactions.length > 0;\n    }\n\n    /**\n     * Get the current transaction ID, and make sure it's not null\n     *\n     * @protected\n     * @returns {TransactionId}\n     */\n    _getTransactionId() {\n        const transactionId = this.transactionId;\n        if (transactionId == null) {\n            throw new Error(\n                \"transaction must have been frozen before getting the transaction ID, try calling `freeze`\"\n            );\n        }\n        return transactionId;\n    }\n\n    /**\n     * @param {Client} client\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars,@typescript-eslint/no-empty-function\n    _validateChecksums(client) {\n        // Do nothing\n    }\n\n    /**\n     * Before we proceed exeuction, we need to do a couple checks\n     *\n     * @override\n     * @protected\n     * @param {import(\"../client/Client.js\").default<Channel, *>} client\n     * @returns {Promise<void>}\n     */\n    async _beforeExecute(client) {\n        // Makes ure we're frozen\n        if (!this._isFrozen()) {\n            this.freezeWith(client);\n        }\n\n        // Valid checksums if the option is enabled\n        if (client.isAutoValidateChecksumsEnabled()) {\n            this._validateChecksums(client);\n        }\n\n        // Set the operator if the client has one\n        this._operator = client != null ? client._operator : null;\n        this._operatorAccountId =\n            client != null && client._operator != null\n                ? client._operator.accountId\n                : null;\n\n        // If the client has an operaator, sign this request with the operator\n        if (this._operator != null) {\n            await this.signWith(\n                this._operator.publicKey,\n                this._operator.transactionSigner\n            );\n        }\n    }\n\n    /**\n     * Construct a protobuf transaction\n     *\n     * @override\n     * @internal\n     * @returns {Promise<HashgraphProto.proto.ITransaction>}\n     */\n    async _makeRequestAsync() {\n        // The index for the transaction\n        const index =\n            this._transactionIds.index * this._nodeAccountIds.length +\n            this._nodeAccountIds.index;\n\n        // If sign on demand is disabled we need to simply build that transaction\n        // and return the result, without signing\n        if (!this._signOnDemand) {\n            this._buildTransaction(index);\n            return /** @type {HashgraphProto.proto.ITransaction} */ (\n                this._transactions.get(index)\n            );\n        }\n\n        // Build and sign a transaction\n        return await this._buildTransactionAsync();\n    }\n\n    /**\n     * Sign a `proto.SignedTransaction` with all the keys\n     *\n     * @private\n     * @returns {Promise<HashgraphProto.proto.ISignedTransaction>}\n     */\n    async _signTransaction() {\n        const signedTransaction = this._makeSignedTransaction(\n            this._nodeAccountIds.next\n        );\n\n        const bodyBytes = /** @type {Uint8Array} */ (\n            signedTransaction.bodyBytes\n        );\n\n        for (let j = 0; j < this._publicKeys.length; j++) {\n            const publicKey = this._publicKeys[j];\n            const transactionSigner = this._transactionSigners[j];\n\n            if (transactionSigner == null) {\n                continue;\n            }\n\n            const signature = await transactionSigner(bodyBytes);\n\n            if (signedTransaction.sigMap == null) {\n                signedTransaction.sigMap = {};\n            }\n\n            if (signedTransaction.sigMap.sigPair == null) {\n                signedTransaction.sigMap.sigPair = [];\n            }\n\n            signedTransaction.sigMap.sigPair.push(\n                publicKey._toProtobufSignature(signature)\n            );\n        }\n\n        return signedTransaction;\n    }\n\n    /**\n     * Construct a new transaction ID at the current index\n     *\n     * @private\n     */\n    _buildNewTransactionIdList() {\n        if (this._transactionIds.locked || this._operatorAccountId == null) {\n            return;\n        }\n\n        const transactionId = TransactionId.withValidStart(\n            this._operatorAccountId,\n            Timestamp.generate()\n        );\n\n        this._transactionIds.set(this._transactionIds.index, transactionId);\n    }\n\n    /**\n     * Build each transaction in a loop\n     *\n     * @private\n     */\n    _buildAllTransactions() {\n        for (let i = 0; i < this._signedTransactions.length; i++) {\n            this._buildTransaction(i);\n        }\n    }\n\n    /**\n     * Build and and sign each transaction in a loop\n     *\n     * This method is primary used in the exist condition methods\n     * which are not `execute()`, e.g. `toBytesAsync()` and `getSignaturesAsync()`\n     *\n     * @private\n     */\n    async _buildAllTransactionsAsync() {\n        if (!this._signOnDemand) {\n            this._buildAllTransactions();\n            return;\n        }\n\n        this._buildSignedTransactions();\n\n        if (this._transactions.locked) {\n            return;\n        }\n\n        for (let i = 0; i < this._signedTransactions.length; i++) {\n            this._transactions.push(await this._buildTransactionAsync());\n        }\n    }\n\n    /**\n     * Build a transaction at a particular index\n     *\n     * @private\n     * @param {number} index\n     */\n    _buildTransaction(index) {\n        if (this._transactions.length < index) {\n            for (let i = this._transactions.length; i < index; i++) {\n                this._transactions.push(null);\n            }\n        }\n\n        this._transactions.setIfAbsent(index, () => {\n            return {\n                signedTransactionBytes:\n                    HashgraphProto.proto.SignedTransaction.encode(\n                        this._signedTransactions.get(index)\n                    ).finish(),\n            };\n        });\n    }\n\n    /**\n     * Build a trransaction using the current index, where the current\n     * index is determined by `this._nodeAccountIds.index` and\n     * `this._transactionIds.index`\n     *\n     * @private\n     * @returns {Promise<HashgraphProto.proto.ITransaction>}\n     */\n    async _buildTransactionAsync() {\n        return {\n            signedTransactionBytes:\n                HashgraphProto.proto.SignedTransaction.encode(\n                    await this._signTransaction()\n                ).finish(),\n        };\n    }\n\n    /**\n     * Determine what execution state we're in.\n     *\n     * @override\n     * @internal\n     * @param {HashgraphProto.proto.ITransaction} request\n     * @param {HashgraphProto.proto.ITransactionResponse} response\n     * @returns {[Status, ExecutionState]}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _shouldRetry(request, response) {\n        const { nodeTransactionPrecheckCode } = response;\n\n        // Get the node precheck code, and convert it into an SDK `Status`\n        const status = Status._fromCode(\n            nodeTransactionPrecheckCode != null\n                ? nodeTransactionPrecheckCode\n                : HashgraphProto.proto.ResponseCodeEnum.OK\n        );\n\n        Logger.debug(\n            `[${this._getLogId()}] received status ${status.toString()}`\n        );\n\n        // Based on the status what execution state are we in\n        switch (status) {\n            case Status.Busy:\n            case Status.Unknown:\n            case Status.PlatformTransactionNotCreated:\n            case Status.PlatformNotActive:\n                return [status, ExecutionState.Retry];\n            case Status.Ok:\n                return [status, ExecutionState.Finished];\n            case Status.TransactionExpired:\n                if (\n                    this._regenerateTransactionId == null ||\n                    this._regenerateTransactionId\n                ) {\n                    this._buildNewTransactionIdList();\n                    return [status, ExecutionState.Retry];\n                } else {\n                    return [status, ExecutionState.Error];\n                }\n            default:\n                return [status, ExecutionState.Error];\n        }\n    }\n\n    /**\n     * Map the request and response into a precheck status error\n     *\n     * @override\n     * @internal\n     * @param {HashgraphProto.proto.ITransaction} request\n     * @param {HashgraphProto.proto.ITransactionResponse} response\n     * @returns {Error}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _mapStatusError(request, response) {\n        const { nodeTransactionPrecheckCode } = response;\n\n        const status = Status._fromCode(\n            nodeTransactionPrecheckCode != null\n                ? nodeTransactionPrecheckCode\n                : HashgraphProto.proto.ResponseCodeEnum.OK\n        );\n\n        return new PrecheckStatusError({\n            status,\n            transactionId: this._getTransactionId(),\n        });\n    }\n\n    /**\n     * Map the request, response, and node account ID into a `TransactionResponse`\n     *\n     * @override\n     * @protected\n     * @param {HashgraphProto.proto.ITransactionResponse} response\n     * @param {AccountId} nodeId\n     * @param {HashgraphProto.proto.ITransaction} request\n     * @returns {Promise<TransactionResponse>}\n     */\n    async _mapResponse(response, nodeId, request) {\n        const transactionHash = await sha384.digest(\n            /** @type {Uint8Array} */ (request.signedTransactionBytes)\n        );\n        const transactionId = this._getTransactionId();\n\n        this._transactionIds.advance();\n\n        return new TransactionResponse({\n            nodeId,\n            transactionHash,\n            transactionId,\n        });\n    }\n\n    /**\n     * Make a signed tranaction given a node account ID\n     *\n     * @internal\n     * @param {?AccountId} nodeId\n     * @returns {HashgraphProto.proto.ISignedTransaction}\n     */\n    _makeSignedTransaction(nodeId) {\n        const body = this._makeTransactionBody(nodeId);\n        const bodyBytes =\n            HashgraphProto.proto.TransactionBody.encode(body).finish();\n\n        return {\n            bodyBytes,\n            sigMap: {\n                sigPair: [],\n            },\n        };\n    }\n\n    /**\n     * Make a protobuf transaction body\n     *\n     * @private\n     * @param {?AccountId} nodeId\n     * @returns {HashgraphProto.proto.ITransactionBody}\n     */\n    _makeTransactionBody(nodeId) {\n        return {\n            [this._getTransactionDataCase()]: this._makeTransactionData(),\n            transactionFee:\n                this._maxTransactionFee != null\n                    ? this._maxTransactionFee.toTinybars()\n                    : null,\n            memo: this._transactionMemo,\n            transactionID: this._transactionIds.current._toProtobuf(),\n            nodeAccountID: nodeId != null ? nodeId._toProtobuf() : null,\n            transactionValidDuration: {\n                seconds: Long.fromNumber(this._transactionValidDuration),\n            },\n        };\n    }\n\n    /**\n     * This method returns a key for the `data` field in a transaction body.\n     * Each transaction overwrite this to make sure when we build the transaction body\n     * we set the right data field.\n     *\n     * @abstract\n     * @protected\n     * @returns {NonNullable<HashgraphProto.proto.TransactionBody[\"data\"]>}\n     */\n    _getTransactionDataCase() {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * Make a scheduled transaction body\n     * FIXME: Should really call this `makeScheduledTransactionBody` to be consistent\n     *\n     * @internal\n     * @returns {HashgraphProto.proto.ISchedulableTransactionBody}\n     */\n    _getScheduledTransactionBody() {\n        return {\n            memo: this.transactionMemo,\n            transactionFee:\n                this._maxTransactionFee == null\n                    ? this._defaultMaxTransactionFee.toTinybars()\n                    : this._maxTransactionFee.toTinybars(),\n            [this._getTransactionDataCase()]: this._makeTransactionData(),\n        };\n    }\n\n    /**\n     * Make the transaction body data.\n     *\n     * @abstract\n     * @protected\n     * @returns {object}\n     */\n    _makeTransactionData() {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * FIXME: Why do we have `isFrozen` and `_isFrozen()`?\n     *\n     * @protected\n     * @returns {boolean}\n     */\n    _isFrozen() {\n        return (\n            this._signOnDemand ||\n            this._signedTransactions.length > 0 ||\n            this._transactions.length > 0\n        );\n    }\n\n    /**\n     * Require the transaction to NOT be frozen\n     *\n     * @internal\n     */\n    _requireNotFrozen() {\n        if (this._isFrozen()) {\n            throw new Error(\n                \"transaction is immutable; it has at least one signature or has been explicitly frozen\"\n            );\n        }\n    }\n\n    /**\n     * Require the transaction to have sign on demand disabled\n     *\n     * @internal\n     */\n    _requireNotSignOnDemand() {\n        if (this._signOnDemand) {\n            throw new Error(\n                \"Please use `toBytesAsync()` if `signOnDemand` is enabled\"\n            );\n        }\n    }\n\n    /**\n     * Require the transaction to be frozen\n     *\n     * @internal\n     */\n    _requireFrozen() {\n        if (!this._isFrozen()) {\n            throw new Error(\n                \"transaction must have been frozen before calculating the hash will be stable, try calling `freeze`\"\n            );\n        }\n    }\n\n    /**\n     * Require the transaction to have a single node account ID set\n     *\n     * @internal\n     * @protected\n     */\n    _requireOneNodeAccountId() {\n        if (this._nodeAccountIds.length != 1) {\n            throw \"transaction did not have exactly one node ID set\";\n        }\n    }\n\n    /**\n     * @param {HashgraphProto.proto.Transaction} request\n     * @returns {Uint8Array}\n     */\n    _requestToBytes(request) {\n        return HashgraphProto.proto.Transaction.encode(request).finish();\n    }\n\n    /**\n     * @param {HashgraphProto.proto.TransactionResponse} response\n     * @returns {Uint8Array}\n     */\n    _responseToBytes(response) {\n        return HashgraphProto.proto.TransactionResponse.encode(\n            response\n        ).finish();\n    }\n}\n\n/**\n * This is essentially a registry/cache for a callback that creates a `ScheduleCreateTransaction`\n *\n * @type {(() => ScheduleCreateTransaction)[]}\n */\nexport const SCHEDULE_CREATE_TRANSACTION = [];\n"]},"metadata":{},"sourceType":"module"}