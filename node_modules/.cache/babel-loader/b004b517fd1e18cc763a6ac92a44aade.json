{"ast":null,"code":"/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\nimport AccountId from \"../account/AccountId.js\";\nimport Timestamp from \"../Timestamp.js\";\nimport * as HashgraphProto from \"@hashgraph/proto\";\nimport Long from \"long\";\nimport CACHE from \"../Cache.js\";\n/**\n * @typedef {import(\"../client/Client.js\").default<*, *>} Client\n * @typedef {import(\"./TransactionReceipt.js\").default} TransactionReceipt\n * @typedef {import(\"./TransactionRecord.js\").default} TransactionRecord\n */\n\n/**\n * The client-generated ID for a transaction.\n *\n * This is used for retrieving receipts and records for a transaction, for appending to a file\n * right after creating it, for instantiating a smart contract with bytecode in a file just created,\n * and internally by the network for detecting when duplicate transactions are submitted.\n */\n\nexport default class TransactionId {\n  /**\n   * Don't use this method directly.\n   * Use `TransactionId.[generate|withNonce|withValidStart]()` instead.\n   *\n   * @param {?AccountId} accountId\n   * @param {?Timestamp} validStart\n   * @param {?boolean} scheduled\n   * @param {?Long | number} nonce\n   */\n  constructor(accountId, validStart) {\n    let scheduled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let nonce = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n    /**\n     * The Account ID that paid for this transaction.\n     *\n     * @readonly\n     */\n    this.accountId = accountId;\n    /**\n     * The time from when this transaction is valid.\n     *\n     * When a transaction is submitted there is additionally a validDuration (defaults to 120s)\n     * and together they define a time window that a transaction may be processed in.\n     *\n     * @readonly\n     */\n\n    this.validStart = validStart;\n    this.scheduled = scheduled;\n    this.nonce = null;\n\n    if (nonce != null && nonce != 0) {\n      this.setNonce(nonce);\n    }\n\n    Object.seal(this);\n  }\n  /**\n   * @param {Long | number} nonce\n   * @returns {TransactionId}\n   */\n\n\n  setNonce(nonce) {\n    this.nonce = typeof nonce === \"number\" ? Long.fromNumber(nonce) : nonce;\n    return this;\n  }\n  /**\n   * @param {AccountId} accountId\n   * @param {Timestamp} validStart\n   * @returns {TransactionId}\n   */\n\n\n  static withValidStart(accountId, validStart) {\n    return new TransactionId(accountId, validStart);\n  }\n  /**\n   * Generates a new transaction ID for the given account ID.\n   *\n   * Note that transaction IDs are made of the valid start of the transaction and the account\n   * that will be charged the transaction fees for the transaction.\n   *\n   * @param {AccountId | string} id\n   * @returns {TransactionId}\n   */\n\n\n  static generate(id) {\n    return new TransactionId(typeof id === \"string\" ? AccountId.fromString(id) : new AccountId(id), Timestamp.generate());\n  }\n  /**\n   * @param {string} wholeId\n   * @returns {TransactionId}\n   */\n\n\n  static fromString(wholeId) {\n    let account, seconds, nanos, isScheduled, nonce;\n    let rest; // 1.1.1@5.4?scheduled/117\n\n    [account, rest] = wholeId.split(\"@\");\n    [seconds, rest] = rest.split(\".\");\n\n    if (rest.includes(\"?\")) {\n      [nanos, rest] = rest.split(\"?scheduled\");\n      isScheduled = true;\n\n      if (rest.includes(\"/\")) {\n        nonce = rest.replace(\"/\", \"\");\n      } else {\n        nonce = null;\n      }\n    } else if (rest.includes(\"/\")) {\n      [nanos, nonce] = rest.split(\"/\");\n      isScheduled = false;\n    } else {\n      nanos = rest;\n    }\n\n    return new TransactionId(AccountId.fromString(account), new Timestamp(Long.fromValue(seconds), Long.fromValue(nanos)), isScheduled, nonce != null ? Long.fromString(nonce) : null);\n  }\n  /**\n   * @param {boolean} scheduled\n   * @returns {this}\n   */\n\n\n  setScheduled(scheduled) {\n    this.scheduled = scheduled;\n    return this;\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  toString() {\n    if (this.accountId != null && this.validStart != null) {\n      const nonce = this.nonce != null ? \"/\".concat(this.nonce.toString()) : \"\";\n      const scheduled = this.scheduled ? \"?scheduled\" : \"\";\n      return `${this.accountId.toString()}@${this.validStart.seconds.toString()}.${this.validStart.nanos.toString()}${scheduled}${nonce}`;\n    } else {\n      throw new Error(\"neither `accountId` nor `validStart` are set\");\n    }\n  }\n  /**\n   * @internal\n   * @param {HashgraphProto.proto.ITransactionID} id\n   * @returns {TransactionId}\n   */\n\n\n  static _fromProtobuf(id) {\n    if (id.accountID != null && id.transactionValidStart != null) {\n      return new TransactionId(AccountId._fromProtobuf(id.accountID), Timestamp._fromProtobuf(id.transactionValidStart), id.scheduled != null ? id.scheduled : undefined, id.nonce != null ? id.nonce : undefined);\n    } else {\n      throw new Error(\"Neither `nonce` or `accountID` and `transactionValidStart` are set\");\n    }\n  }\n  /**\n   * @internal\n   * @returns {HashgraphProto.proto.ITransactionID}\n   */\n\n\n  _toProtobuf() {\n    return {\n      accountID: this.accountId != null ? this.accountId._toProtobuf() : null,\n      transactionValidStart: this.validStart != null ? this.validStart._toProtobuf() : null,\n      scheduled: this.scheduled,\n      nonce: this.nonce != null ? this.nonce.toInt() : null\n    };\n  }\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {TransactionId}\n   */\n\n\n  static fromBytes(bytes) {\n    return TransactionId._fromProtobuf(HashgraphProto.proto.TransactionID.decode(bytes));\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n\n\n  toBytes() {\n    return HashgraphProto.proto.TransactionID.encode(this._toProtobuf()).finish();\n  }\n  /**\n   * @returns {TransactionId}\n   */\n\n\n  clone() {\n    return new TransactionId(this.accountId, this.validStart, this.scheduled, this.nonce);\n  }\n  /**\n   * @param {TransactionId} other\n   * @returns {number}\n   */\n\n\n  compare(other) {\n    const comparison =\n    /** @type {AccountId} */\n    this.accountId.compare(\n    /** @type {AccountId} */\n    other.accountId);\n\n    if (comparison != 0) {\n      return comparison;\n    }\n\n    return (\n      /** @type {Timestamp} */\n      this.validStart.compare(\n      /** @type {Timestamp} */\n      other.validStart)\n    );\n  }\n  /**\n   * @param {Client} client\n   * @returns {Promise<TransactionReceipt>}\n   */\n\n\n  getReceipt(client) {\n    return CACHE.transactionReceiptQueryConstructor().setTransactionId(this).execute(client);\n  }\n  /**\n   * @param {Client} client\n   * @returns {Promise<TransactionRecord>}\n   */\n\n\n  async getRecord(client) {\n    await this.getReceipt(client);\n    return CACHE.transactionRecordQueryConstructor().setTransactionId(this).execute(client);\n  }\n\n}","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/hbar-shop/hbar-shop-dashboard/node_modules/@hashgraph/sdk/src/transaction/TransactionId.js"],"names":["AccountId","Timestamp","HashgraphProto","Long","CACHE","TransactionId","constructor","accountId","validStart","scheduled","nonce","setNonce","Object","seal","fromNumber","withValidStart","generate","id","fromString","wholeId","account","seconds","nanos","isScheduled","rest","split","includes","replace","fromValue","setScheduled","toString","concat","Error","_fromProtobuf","accountID","transactionValidStart","undefined","_toProtobuf","toInt","fromBytes","bytes","proto","TransactionID","decode","toBytes","encode","finish","clone","compare","other","comparison","getReceipt","client","transactionReceiptQueryConstructor","setTransactionId","execute","getRecord","transactionRecordQueryConstructor"],"mappings":"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","sourcesContent":["/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\n\nimport AccountId from \"../account/AccountId.js\";\nimport Timestamp from \"../Timestamp.js\";\nimport * as HashgraphProto from \"@hashgraph/proto\";\nimport Long from \"long\";\nimport CACHE from \"../Cache.js\";\n\n/**\n * @typedef {import(\"../client/Client.js\").default<*, *>} Client\n * @typedef {import(\"./TransactionReceipt.js\").default} TransactionReceipt\n * @typedef {import(\"./TransactionRecord.js\").default} TransactionRecord\n */\n\n/**\n * The client-generated ID for a transaction.\n *\n * This is used for retrieving receipts and records for a transaction, for appending to a file\n * right after creating it, for instantiating a smart contract with bytecode in a file just created,\n * and internally by the network for detecting when duplicate transactions are submitted.\n */\nexport default class TransactionId {\n    /**\n     * Don't use this method directly.\n     * Use `TransactionId.[generate|withNonce|withValidStart]()` instead.\n     *\n     * @param {?AccountId} accountId\n     * @param {?Timestamp} validStart\n     * @param {?boolean} scheduled\n     * @param {?Long | number} nonce\n     */\n    constructor(accountId, validStart, scheduled = false, nonce = null) {\n        /**\n         * The Account ID that paid for this transaction.\n         *\n         * @readonly\n         */\n        this.accountId = accountId;\n\n        /**\n         * The time from when this transaction is valid.\n         *\n         * When a transaction is submitted there is additionally a validDuration (defaults to 120s)\n         * and together they define a time window that a transaction may be processed in.\n         *\n         * @readonly\n         */\n        this.validStart = validStart;\n\n        this.scheduled = scheduled;\n\n        this.nonce = null;\n        if (nonce != null && nonce != 0) {\n            this.setNonce(nonce);\n        }\n\n        Object.seal(this);\n    }\n\n    /**\n     * @param {Long | number} nonce\n     * @returns {TransactionId}\n     */\n    setNonce(nonce) {\n        this.nonce = typeof nonce === \"number\" ? Long.fromNumber(nonce) : nonce;\n        return this;\n    }\n\n    /**\n     * @param {AccountId} accountId\n     * @param {Timestamp} validStart\n     * @returns {TransactionId}\n     */\n    static withValidStart(accountId, validStart) {\n        return new TransactionId(accountId, validStart);\n    }\n\n    /**\n     * Generates a new transaction ID for the given account ID.\n     *\n     * Note that transaction IDs are made of the valid start of the transaction and the account\n     * that will be charged the transaction fees for the transaction.\n     *\n     * @param {AccountId | string} id\n     * @returns {TransactionId}\n     */\n    static generate(id) {\n        return new TransactionId(\n            typeof id === \"string\"\n                ? AccountId.fromString(id)\n                : new AccountId(id),\n            Timestamp.generate()\n        );\n    }\n\n    /**\n     * @param {string} wholeId\n     * @returns {TransactionId}\n     */\n    static fromString(wholeId) {\n        let account, seconds, nanos, isScheduled, nonce;\n        let rest;\n        // 1.1.1@5.4?scheduled/117\n\n        [account, rest] = wholeId.split(\"@\");\n        [seconds, rest] = rest.split(\".\");\n        if (rest.includes(\"?\")) {\n            [nanos, rest] = rest.split(\"?scheduled\");\n            isScheduled = true;\n            if (rest.includes(\"/\")) {\n                nonce = rest.replace(\"/\", \"\");\n            } else {\n                nonce = null;\n            }\n        } else if (rest.includes(\"/\")) {\n            [nanos, nonce] = rest.split(\"/\");\n            isScheduled = false;\n        } else {\n            nanos = rest;\n        }\n\n        return new TransactionId(\n            AccountId.fromString(account),\n            new Timestamp(Long.fromValue(seconds), Long.fromValue(nanos)),\n            isScheduled,\n            nonce != null ? Long.fromString(nonce) : null\n        );\n    }\n\n    /**\n     * @param {boolean} scheduled\n     * @returns {this}\n     */\n    setScheduled(scheduled) {\n        this.scheduled = scheduled;\n        return this;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        if (this.accountId != null && this.validStart != null) {\n            const nonce =\n                this.nonce != null ? \"/\".concat(this.nonce.toString()) : \"\";\n            const scheduled = this.scheduled ? \"?scheduled\" : \"\";\n            return `${this.accountId.toString()}@${this.validStart.seconds.toString()}.${this.validStart.nanos.toString()}${scheduled}${nonce}`;\n        } else {\n            throw new Error(\"neither `accountId` nor `validStart` are set\");\n        }\n    }\n\n    /**\n     * @internal\n     * @param {HashgraphProto.proto.ITransactionID} id\n     * @returns {TransactionId}\n     */\n    static _fromProtobuf(id) {\n        if (id.accountID != null && id.transactionValidStart != null) {\n            return new TransactionId(\n                AccountId._fromProtobuf(id.accountID),\n                Timestamp._fromProtobuf(id.transactionValidStart),\n                id.scheduled != null ? id.scheduled : undefined,\n                id.nonce != null ? id.nonce : undefined\n            );\n        } else {\n            throw new Error(\n                \"Neither `nonce` or `accountID` and `transactionValidStart` are set\"\n            );\n        }\n    }\n\n    /**\n     * @internal\n     * @returns {HashgraphProto.proto.ITransactionID}\n     */\n    _toProtobuf() {\n        return {\n            accountID:\n                this.accountId != null ? this.accountId._toProtobuf() : null,\n            transactionValidStart:\n                this.validStart != null ? this.validStart._toProtobuf() : null,\n            scheduled: this.scheduled,\n            nonce: this.nonce != null ? this.nonce.toInt() : null,\n        };\n    }\n\n    /**\n     * @param {Uint8Array} bytes\n     * @returns {TransactionId}\n     */\n    static fromBytes(bytes) {\n        return TransactionId._fromProtobuf(\n            HashgraphProto.proto.TransactionID.decode(bytes)\n        );\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        return HashgraphProto.proto.TransactionID.encode(\n            this._toProtobuf()\n        ).finish();\n    }\n\n    /**\n     * @returns {TransactionId}\n     */\n    clone() {\n        return new TransactionId(\n            this.accountId,\n            this.validStart,\n            this.scheduled,\n            this.nonce\n        );\n    }\n\n    /**\n     * @param {TransactionId} other\n     * @returns {number}\n     */\n    compare(other) {\n        const comparison = /** @type {AccountId} */ (this.accountId).compare(\n            /** @type {AccountId} */ (other.accountId)\n        );\n\n        if (comparison != 0) {\n            return comparison;\n        }\n\n        return /** @type {Timestamp} */ (this.validStart).compare(\n            /** @type {Timestamp} */ (other.validStart)\n        );\n    }\n\n    /**\n     * @param {Client} client\n     * @returns {Promise<TransactionReceipt>}\n     */\n    getReceipt(client) {\n        return CACHE.transactionReceiptQueryConstructor()\n            .setTransactionId(this)\n            .execute(client);\n    }\n\n    /**\n     * @param {Client} client\n     * @returns {Promise<TransactionRecord>}\n     */\n    async getRecord(client) {\n        await this.getReceipt(client);\n\n        return CACHE.transactionRecordQueryConstructor()\n            .setTransactionId(this)\n            .execute(client);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}