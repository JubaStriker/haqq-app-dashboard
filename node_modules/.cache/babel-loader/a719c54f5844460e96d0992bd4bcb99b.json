{"ast":null,"code":"/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\nimport Hbar from \"../Hbar.js\";\nimport Transaction, { TRANSACTION_REGISTRY } from \"../transaction/Transaction.js\";\nimport * as utf8 from \"../encoding/utf8.js\";\nimport FileId from \"./FileId.js\";\nimport TransactionId from \"../transaction/TransactionId.js\";\nimport Timestamp from \"../Timestamp.js\";\nimport List from \"../transaction/List.js\";\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").proto.ITransaction} HashgraphProto.proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").proto.ISignedTransaction} HashgraphProto.proto.ISignedTransaction\n * @typedef {import(\"@hashgraph/proto\").proto.TransactionBody} HashgraphProto.proto.TransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionBody} HashgraphProto.proto.ITransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionResponse} HashgraphProto.proto.ITransactionResponse\n * @typedef {import(\"@hashgraph/proto\").proto.IFileAppendTransactionBody} HashgraphProto.proto.IFileAppendTransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.IFileID} HashgraphProto.proto.IFileID\n */\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../client/Client.js\").default<Channel, *>} Client\n * @typedef {import(\"../account/AccountId.js\").default} AccountId\n * @typedef {import(\"../transaction/TransactionResponse.js\").default} TransactionResponse\n * @typedef {import(\"../schedule/ScheduleCreateTransaction.js\").default} ScheduleCreateTransaction\n */\n\n/**\n * A transaction specifically to append data to a file on the network.\n *\n * If a file has multiple keys, all keys must sign to modify its contents.\n */\n\nexport default class FileAppendTransaction extends Transaction {\n  /**\n   * @param {object} [props]\n   * @param {FileId | string} [props.fileId]\n   * @param {Uint8Array | string} [props.contents]\n   * @param {number} [props.maxChunks]\n   * @param {number} [props.chunkSize]\n   */\n  constructor() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    /**\n     * @private\n     * @type {?FileId}\n     */\n\n    this._fileId = null;\n    /**\n     * @private\n     * @type {?Uint8Array}\n     */\n\n    this._contents = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this._maxChunks = 20;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this._chunkSize = 4096;\n    this._defaultMaxTransactionFee = new Hbar(5);\n\n    if (props.fileId != null) {\n      this.setFileId(props.fileId);\n    }\n\n    if (props.contents != null) {\n      this.setContents(props.contents);\n    }\n\n    if (props.maxChunks != null) {\n      this.setMaxChunks(props.maxChunks);\n    }\n\n    if (props.chunkSize != null) {\n      this.setChunkSize(props.chunkSize);\n    }\n    /** @type {List<TransactionId>} */\n\n\n    this._transactionIds = new List();\n  }\n  /**\n   * @internal\n   * @param {HashgraphProto.proto.ITransaction[]} transactions\n   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions\n   * @param {TransactionId[]} transactionIds\n   * @param {AccountId[]} nodeIds\n   * @param {HashgraphProto.proto.ITransactionBody[]} bodies\n   * @returns {FileAppendTransaction}\n   */\n\n\n  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {\n    const body = bodies[0];\n    const append =\n    /** @type {HashgraphProto.proto.IFileAppendTransactionBody} */\n    body.fileAppend;\n    let contents;\n\n    for (let i = 0; i < bodies.length; i += nodeIds.length) {\n      const fileAppend =\n      /** @type {HashgraphProto.proto.IFileAppendTransactionBody} */\n      bodies[i].fileAppend;\n\n      if (fileAppend.contents == null) {\n        break;\n      }\n\n      if (contents == null) {\n        contents = new Uint8Array(\n        /** @type {Uint8Array} */\n        fileAppend.contents);\n        continue;\n      }\n      /** @type {Uint8Array} */\n\n\n      const concat = new Uint8Array(contents.length +\n      /** @type {Uint8Array} */\n      fileAppend.contents.length);\n      concat.set(contents, 0);\n      concat.set(\n      /** @type {Uint8Array} */\n      fileAppend.contents, contents.length);\n      contents = concat;\n    }\n\n    return Transaction._fromProtobufTransactions(new FileAppendTransaction({\n      fileId: append.fileID != null ? FileId._fromProtobuf(\n      /** @type {HashgraphProto.proto.IFileID} */\n      append.fileID) : undefined,\n      contents: contents\n    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);\n  }\n  /**\n   * @returns {?FileId}\n   */\n\n\n  get fileId() {\n    return this._fileId;\n  }\n  /**\n   * Set the keys which must sign any transactions modifying this file. Required.\n   *\n   * All keys must sign to modify the file's contents or keys. No key is required\n   * to sign for extending the expiration time (except the one for the operator account\n   * paying for the transaction). Only one key must sign to delete the file, however.\n   *\n   * To require more than one key to sign to delete a file, add them to a\n   * KeyList and pass that here.\n   *\n   * The network currently requires a file to have at least one key (or key list or threshold key)\n   * but this requirement may be lifted in the future.\n   *\n   * @param {FileId | string} fileId\n   * @returns {this}\n   */\n\n\n  setFileId(fileId) {\n    this._requireNotFrozen();\n\n    this._fileId = typeof fileId === \"string\" ? FileId.fromString(fileId) : fileId.clone();\n    return this;\n  }\n  /**\n   * @returns {?Uint8Array}\n   */\n\n\n  get contents() {\n    return this._contents;\n  }\n  /**\n   * Set the given byte array as the file's contents.\n   *\n   * This may be omitted to append an empty file.\n   *\n   * Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the\n   * network; if you exceed this you may receive a HederaPreCheckStatusException\n   * with Status#TransactionOversize.\n   *\n   * In this case, you will need to break the data into chunks of less than ~6KiB and execute this\n   * transaction with the first chunk and then use FileAppendTransaction with\n   * FileAppendTransaction#setContents(Uint8Array) for the remaining chunks.\n   *\n   * @param {Uint8Array | string} contents\n   * @returns {this}\n   */\n\n\n  setContents(contents) {\n    this._requireNotFrozen();\n\n    this._contents = contents instanceof Uint8Array ? contents : utf8.encode(contents);\n    return this;\n  }\n  /**\n   * @returns {?number}\n   */\n\n\n  get maxChunks() {\n    return this._maxChunks;\n  }\n  /**\n   * @param {number} maxChunks\n   * @returns {this}\n   */\n\n\n  setMaxChunks(maxChunks) {\n    this._requireNotFrozen();\n\n    this._maxChunks = maxChunks;\n    return this;\n  }\n  /**\n   * @returns {?number}\n   */\n\n\n  get chunkSize() {\n    return this._chunkSize;\n  }\n  /**\n   * @param {number} chunkSize\n   * @returns {this}\n   */\n\n\n  setChunkSize(chunkSize) {\n    this._chunkSize = chunkSize;\n    return this;\n  }\n  /**\n   * Freeze this transaction from further modification to prepare for\n   * signing or serialization.\n   *\n   * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3\n   * nodes to prepare this transaction for.\n   *\n   * @param {?import(\"../client/Client.js\").default<Channel, *>} client\n   * @returns {this}\n   */\n\n\n  freezeWith(client) {\n    super.freezeWith(client);\n\n    if (this._contents == null) {\n      return this;\n    }\n\n    const chunks = Math.floor((this._contents.length + (this._chunkSize - 1)) / this._chunkSize);\n\n    if (chunks > this._maxChunks) {\n      throw new Error(`Contents with size ${this._contents.length} too long for ${this._maxChunks} chunks`);\n    }\n\n    let nextTransactionId = this._getTransactionId(); // Hack around the locked list. Should refactor a bit to remove such code\n\n\n    this._transactionIds.locked = false;\n\n    this._transactions.clear();\n\n    this._transactionIds.clear();\n\n    this._signedTransactions.clear();\n\n    for (let chunk = 0; chunk < chunks; chunk++) {\n      this._transactionIds.push(nextTransactionId);\n\n      this._transactionIds.advance();\n\n      for (const nodeAccountId of this._nodeAccountIds.list) {\n        this._signedTransactions.push(this._makeSignedTransaction(nodeAccountId));\n      }\n\n      nextTransactionId = new TransactionId(\n      /** @type {AccountId} */\n      nextTransactionId.accountId, new Timestamp(\n      /** @type {Timestamp} */\n      nextTransactionId.validStart.seconds,\n      /** @type {Timestamp} */\n      nextTransactionId.validStart.nanos.add(1)));\n    }\n\n    this._transactionIds.advance();\n\n    this._transactionIds.setLocked();\n\n    return this;\n  }\n  /**\n   * @returns {ScheduleCreateTransaction}\n   */\n\n\n  schedule() {\n    this._requireNotFrozen();\n\n    if (this._contents != null && this._contents.length > this._chunkSize) {\n      throw new Error(`cannot schedule \\`FileAppendTransaction\\` with message over ${this._chunkSize} bytes`);\n    }\n\n    return super.schedule();\n  }\n  /**\n   * @param {import(\"../client/Client.js\").default<Channel, *>} client\n   * @param {number=} requestTimeout\n   * @returns {Promise<TransactionResponse>}\n   */\n\n\n  async execute(client, requestTimeout) {\n    return (await this.executeAll(client, requestTimeout))[0];\n  }\n  /**\n   * @param {import(\"../client/Client.js\").default<Channel, *>} client\n   * @param {number=} requestTimeout\n   * @returns {Promise<TransactionResponse[]>}\n   */\n\n\n  async executeAll(client, requestTimeout) {\n    if (!super._isFrozen()) {\n      this.freezeWith(client);\n    } // on execute, sign each transaction with the operator, if present\n    // and we are signing a transaction that used the default transaction ID\n\n\n    const transactionId = this._getTransactionId();\n\n    const operatorAccountId = client.operatorAccountId;\n\n    if (operatorAccountId != null && operatorAccountId.equals(\n    /** @type {AccountId} */\n    transactionId.accountId)) {\n      await super.signWithOperator(client);\n    }\n\n    const responses = [];\n    let remainingTimeout = requestTimeout;\n\n    for (let i = 0; i < this._transactionIds.length; i++) {\n      const startTimestamp = Date.now();\n      const response = await super.execute(client, remainingTimeout);\n\n      if (remainingTimeout != null) {\n        remainingTimeout = Date.now() - startTimestamp;\n      }\n\n      await response.getReceipt(client);\n      responses.push(response);\n    }\n\n    return responses;\n  }\n  /**\n   * @param {Client} client\n   */\n\n\n  _validateChecksums(client) {\n    if (this._fileId != null) {\n      this._fileId.validateChecksum(client);\n    }\n  }\n  /**\n   * @override\n   * @internal\n   * @param {Channel} channel\n   * @param {HashgraphProto.proto.ITransaction} request\n   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}\n   */\n\n\n  _execute(channel, request) {\n    return channel.file.appendContent(request);\n  }\n  /**\n   * @override\n   * @protected\n   * @returns {NonNullable<HashgraphProto.proto.TransactionBody[\"data\"]>}\n   */\n\n\n  _getTransactionDataCase() {\n    return \"fileAppend\";\n  }\n  /**\n   * @override\n   * @protected\n   * @returns {HashgraphProto.proto.IFileAppendTransactionBody}\n   */\n\n\n  _makeTransactionData() {\n    const length = this._contents != null ? this._contents.length : 0;\n    const startIndex = this._transactionIds.index * this._chunkSize;\n    const endIndex = Math.min(startIndex + this._chunkSize, length);\n    return {\n      fileID: this._fileId != null ? this._fileId._toProtobuf() : null,\n      contents: this._contents != null ? this._contents.slice(startIndex, endIndex) : null\n    };\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  _getLogId() {\n    const timestamp =\n    /** @type {import(\"../Timestamp.js\").default} */\n    this._transactionIds.current.validStart;\n    return `FileAppendTransaction:${timestamp.toString()}`;\n  }\n\n} // eslint-disable-next-line @typescript-eslint/unbound-method\n\nTRANSACTION_REGISTRY.set(\"fileAppend\", FileAppendTransaction._fromProtobuf);","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/hbar-shop/hbar-shopify-coupon-client/node_modules/@hashgraph/sdk/src/file/FileAppendTransaction.js"],"names":["Hbar","Transaction","TRANSACTION_REGISTRY","utf8","FileId","TransactionId","Timestamp","List","FileAppendTransaction","constructor","props","_fileId","_contents","_maxChunks","_chunkSize","_defaultMaxTransactionFee","fileId","setFileId","contents","setContents","maxChunks","setMaxChunks","chunkSize","setChunkSize","_transactionIds","_fromProtobuf","transactions","signedTransactions","transactionIds","nodeIds","bodies","body","append","fileAppend","i","length","Uint8Array","concat","set","_fromProtobufTransactions","fileID","undefined","_requireNotFrozen","fromString","clone","encode","freezeWith","client","chunks","Math","floor","Error","nextTransactionId","_getTransactionId","locked","_transactions","clear","_signedTransactions","chunk","push","advance","nodeAccountId","_nodeAccountIds","list","_makeSignedTransaction","accountId","validStart","seconds","nanos","add","setLocked","schedule","execute","requestTimeout","executeAll","_isFrozen","transactionId","operatorAccountId","equals","signWithOperator","responses","remainingTimeout","startTimestamp","Date","now","response","getReceipt","_validateChecksums","validateChecksum","_execute","channel","request","file","appendContent","_getTransactionDataCase","_makeTransactionData","startIndex","index","endIndex","min","_toProtobuf","slice","_getLogId","timestamp","current","toString"],"mappings":"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","sourcesContent":["/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\n\nimport Hbar from \"../Hbar.js\";\nimport Transaction, {\n    TRANSACTION_REGISTRY,\n} from \"../transaction/Transaction.js\";\nimport * as utf8 from \"../encoding/utf8.js\";\nimport FileId from \"./FileId.js\";\nimport TransactionId from \"../transaction/TransactionId.js\";\nimport Timestamp from \"../Timestamp.js\";\nimport List from \"../transaction/List.js\";\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").proto.ITransaction} HashgraphProto.proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").proto.ISignedTransaction} HashgraphProto.proto.ISignedTransaction\n * @typedef {import(\"@hashgraph/proto\").proto.TransactionBody} HashgraphProto.proto.TransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionBody} HashgraphProto.proto.ITransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionResponse} HashgraphProto.proto.ITransactionResponse\n * @typedef {import(\"@hashgraph/proto\").proto.IFileAppendTransactionBody} HashgraphProto.proto.IFileAppendTransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.IFileID} HashgraphProto.proto.IFileID\n */\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../client/Client.js\").default<Channel, *>} Client\n * @typedef {import(\"../account/AccountId.js\").default} AccountId\n * @typedef {import(\"../transaction/TransactionResponse.js\").default} TransactionResponse\n * @typedef {import(\"../schedule/ScheduleCreateTransaction.js\").default} ScheduleCreateTransaction\n */\n\n/**\n * A transaction specifically to append data to a file on the network.\n *\n * If a file has multiple keys, all keys must sign to modify its contents.\n */\nexport default class FileAppendTransaction extends Transaction {\n    /**\n     * @param {object} [props]\n     * @param {FileId | string} [props.fileId]\n     * @param {Uint8Array | string} [props.contents]\n     * @param {number} [props.maxChunks]\n     * @param {number} [props.chunkSize]\n     */\n    constructor(props = {}) {\n        super();\n\n        /**\n         * @private\n         * @type {?FileId}\n         */\n        this._fileId = null;\n\n        /**\n         * @private\n         * @type {?Uint8Array}\n         */\n        this._contents = null;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._maxChunks = 20;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._chunkSize = 4096;\n\n        this._defaultMaxTransactionFee = new Hbar(5);\n\n        if (props.fileId != null) {\n            this.setFileId(props.fileId);\n        }\n\n        if (props.contents != null) {\n            this.setContents(props.contents);\n        }\n\n        if (props.maxChunks != null) {\n            this.setMaxChunks(props.maxChunks);\n        }\n\n        if (props.chunkSize != null) {\n            this.setChunkSize(props.chunkSize);\n        }\n\n        /** @type {List<TransactionId>} */\n        this._transactionIds = new List();\n    }\n\n    /**\n     * @internal\n     * @param {HashgraphProto.proto.ITransaction[]} transactions\n     * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions\n     * @param {TransactionId[]} transactionIds\n     * @param {AccountId[]} nodeIds\n     * @param {HashgraphProto.proto.ITransactionBody[]} bodies\n     * @returns {FileAppendTransaction}\n     */\n    static _fromProtobuf(\n        transactions,\n        signedTransactions,\n        transactionIds,\n        nodeIds,\n        bodies\n    ) {\n        const body = bodies[0];\n        const append =\n            /** @type {HashgraphProto.proto.IFileAppendTransactionBody} */ (\n                body.fileAppend\n            );\n\n        let contents;\n        for (let i = 0; i < bodies.length; i += nodeIds.length) {\n            const fileAppend =\n                /** @type {HashgraphProto.proto.IFileAppendTransactionBody} */ (\n                    bodies[i].fileAppend\n                );\n            if (fileAppend.contents == null) {\n                break;\n            }\n\n            if (contents == null) {\n                contents = new Uint8Array(\n                    /** @type {Uint8Array} */ (fileAppend.contents)\n                );\n                continue;\n            }\n\n            /** @type {Uint8Array} */\n            const concat = new Uint8Array(\n                contents.length +\n                    /** @type {Uint8Array} */ (fileAppend.contents).length\n            );\n            concat.set(contents, 0);\n            concat.set(\n                /** @type {Uint8Array} */ (fileAppend.contents),\n                contents.length\n            );\n            contents = concat;\n        }\n\n        return Transaction._fromProtobufTransactions(\n            new FileAppendTransaction({\n                fileId:\n                    append.fileID != null\n                        ? FileId._fromProtobuf(\n                              /** @type {HashgraphProto.proto.IFileID} */ (\n                                  append.fileID\n                              )\n                          )\n                        : undefined,\n                contents: contents,\n            }),\n            transactions,\n            signedTransactions,\n            transactionIds,\n            nodeIds,\n            bodies\n        );\n    }\n\n    /**\n     * @returns {?FileId}\n     */\n    get fileId() {\n        return this._fileId;\n    }\n\n    /**\n     * Set the keys which must sign any transactions modifying this file. Required.\n     *\n     * All keys must sign to modify the file's contents or keys. No key is required\n     * to sign for extending the expiration time (except the one for the operator account\n     * paying for the transaction). Only one key must sign to delete the file, however.\n     *\n     * To require more than one key to sign to delete a file, add them to a\n     * KeyList and pass that here.\n     *\n     * The network currently requires a file to have at least one key (or key list or threshold key)\n     * but this requirement may be lifted in the future.\n     *\n     * @param {FileId | string} fileId\n     * @returns {this}\n     */\n    setFileId(fileId) {\n        this._requireNotFrozen();\n        this._fileId =\n            typeof fileId === \"string\"\n                ? FileId.fromString(fileId)\n                : fileId.clone();\n\n        return this;\n    }\n\n    /**\n     * @returns {?Uint8Array}\n     */\n    get contents() {\n        return this._contents;\n    }\n\n    /**\n     * Set the given byte array as the file's contents.\n     *\n     * This may be omitted to append an empty file.\n     *\n     * Note that total size for a given transaction is limited to 6KiB (as of March 2020) by the\n     * network; if you exceed this you may receive a HederaPreCheckStatusException\n     * with Status#TransactionOversize.\n     *\n     * In this case, you will need to break the data into chunks of less than ~6KiB and execute this\n     * transaction with the first chunk and then use FileAppendTransaction with\n     * FileAppendTransaction#setContents(Uint8Array) for the remaining chunks.\n     *\n     * @param {Uint8Array | string} contents\n     * @returns {this}\n     */\n    setContents(contents) {\n        this._requireNotFrozen();\n        this._contents =\n            contents instanceof Uint8Array ? contents : utf8.encode(contents);\n\n        return this;\n    }\n\n    /**\n     * @returns {?number}\n     */\n    get maxChunks() {\n        return this._maxChunks;\n    }\n\n    /**\n     * @param {number} maxChunks\n     * @returns {this}\n     */\n    setMaxChunks(maxChunks) {\n        this._requireNotFrozen();\n        this._maxChunks = maxChunks;\n        return this;\n    }\n\n    /**\n     * @returns {?number}\n     */\n    get chunkSize() {\n        return this._chunkSize;\n    }\n\n    /**\n     * @param {number} chunkSize\n     * @returns {this}\n     */\n    setChunkSize(chunkSize) {\n        this._chunkSize = chunkSize;\n        return this;\n    }\n\n    /**\n     * Freeze this transaction from further modification to prepare for\n     * signing or serialization.\n     *\n     * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3\n     * nodes to prepare this transaction for.\n     *\n     * @param {?import(\"../client/Client.js\").default<Channel, *>} client\n     * @returns {this}\n     */\n    freezeWith(client) {\n        super.freezeWith(client);\n\n        if (this._contents == null) {\n            return this;\n        }\n\n        const chunks = Math.floor(\n            (this._contents.length + (this._chunkSize - 1)) / this._chunkSize\n        );\n\n        if (chunks > this._maxChunks) {\n            throw new Error(\n                `Contents with size ${this._contents.length} too long for ${this._maxChunks} chunks`\n            );\n        }\n\n        let nextTransactionId = this._getTransactionId();\n\n        // Hack around the locked list. Should refactor a bit to remove such code\n        this._transactionIds.locked = false;\n\n        this._transactions.clear();\n        this._transactionIds.clear();\n        this._signedTransactions.clear();\n\n        for (let chunk = 0; chunk < chunks; chunk++) {\n            this._transactionIds.push(nextTransactionId);\n            this._transactionIds.advance();\n\n            for (const nodeAccountId of this._nodeAccountIds.list) {\n                this._signedTransactions.push(\n                    this._makeSignedTransaction(nodeAccountId)\n                );\n            }\n\n            nextTransactionId = new TransactionId(\n                /** @type {AccountId} */ (nextTransactionId.accountId),\n                new Timestamp(\n                    /** @type {Timestamp} */ (\n                        nextTransactionId.validStart\n                    ).seconds,\n                    /** @type {Timestamp} */ (\n                        nextTransactionId.validStart\n                    ).nanos.add(1)\n                )\n            );\n        }\n\n        this._transactionIds.advance();\n        this._transactionIds.setLocked();\n\n        return this;\n    }\n\n    /**\n     * @returns {ScheduleCreateTransaction}\n     */\n    schedule() {\n        this._requireNotFrozen();\n\n        if (this._contents != null && this._contents.length > this._chunkSize) {\n            throw new Error(\n                `cannot schedule \\`FileAppendTransaction\\` with message over ${this._chunkSize} bytes`\n            );\n        }\n\n        return super.schedule();\n    }\n\n    /**\n     * @param {import(\"../client/Client.js\").default<Channel, *>} client\n     * @param {number=} requestTimeout\n     * @returns {Promise<TransactionResponse>}\n     */\n    async execute(client, requestTimeout) {\n        return (await this.executeAll(client, requestTimeout))[0];\n    }\n\n    /**\n     * @param {import(\"../client/Client.js\").default<Channel, *>} client\n     * @param {number=} requestTimeout\n     * @returns {Promise<TransactionResponse[]>}\n     */\n    async executeAll(client, requestTimeout) {\n        if (!super._isFrozen()) {\n            this.freezeWith(client);\n        }\n\n        // on execute, sign each transaction with the operator, if present\n        // and we are signing a transaction that used the default transaction ID\n\n        const transactionId = this._getTransactionId();\n        const operatorAccountId = client.operatorAccountId;\n\n        if (\n            operatorAccountId != null &&\n            operatorAccountId.equals(\n                /** @type {AccountId} */ (transactionId.accountId)\n            )\n        ) {\n            await super.signWithOperator(client);\n        }\n\n        const responses = [];\n        let remainingTimeout = requestTimeout;\n\n        for (let i = 0; i < this._transactionIds.length; i++) {\n            const startTimestamp = Date.now();\n            const response = await super.execute(client, remainingTimeout);\n\n            if (remainingTimeout != null) {\n                remainingTimeout = Date.now() - startTimestamp;\n            }\n\n            await response.getReceipt(client);\n            responses.push(response);\n        }\n\n        return responses;\n    }\n\n    /**\n     * @param {Client} client\n     */\n    _validateChecksums(client) {\n        if (this._fileId != null) {\n            this._fileId.validateChecksum(client);\n        }\n    }\n\n    /**\n     * @override\n     * @internal\n     * @param {Channel} channel\n     * @param {HashgraphProto.proto.ITransaction} request\n     * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}\n     */\n    _execute(channel, request) {\n        return channel.file.appendContent(request);\n    }\n\n    /**\n     * @override\n     * @protected\n     * @returns {NonNullable<HashgraphProto.proto.TransactionBody[\"data\"]>}\n     */\n    _getTransactionDataCase() {\n        return \"fileAppend\";\n    }\n\n    /**\n     * @override\n     * @protected\n     * @returns {HashgraphProto.proto.IFileAppendTransactionBody}\n     */\n    _makeTransactionData() {\n        const length = this._contents != null ? this._contents.length : 0;\n        const startIndex = this._transactionIds.index * this._chunkSize;\n        const endIndex = Math.min(startIndex + this._chunkSize, length);\n\n        return {\n            fileID: this._fileId != null ? this._fileId._toProtobuf() : null,\n            contents:\n                this._contents != null\n                    ? this._contents.slice(startIndex, endIndex)\n                    : null,\n        };\n    }\n\n    /**\n     * @returns {string}\n     */\n    _getLogId() {\n        const timestamp = /** @type {import(\"../Timestamp.js\").default} */ (\n            this._transactionIds.current.validStart\n        );\n        return `FileAppendTransaction:${timestamp.toString()}`;\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/unbound-method\nTRANSACTION_REGISTRY.set(\"fileAppend\", FileAppendTransaction._fromProtobuf);\n"]},"metadata":{},"sourceType":"module"}