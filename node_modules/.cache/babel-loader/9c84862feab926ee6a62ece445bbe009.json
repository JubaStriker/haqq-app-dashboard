{"ast":null,"code":"/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\nimport * as HashgraphProto from \"@hashgraph/proto\";\nimport * as utf8 from \"../encoding/utf8.js\";\nconst {\n  proto\n} = HashgraphProto;\n/**\n * @internal\n * @abstract\n */\n\nexport default class Channel {\n  /**\n   * @protected\n   */\n  constructor() {\n    /**\n     * @protected\n     * @type {?HashgraphProto.proto.CryptoService}\n     */\n    this._crypto = null;\n    /**\n     * @protected\n     * @type {?HashgraphProto.proto.SmartContractService}\n     */\n\n    this._smartContract = null;\n    /**\n     * @protected\n     * @type {?HashgraphProto.proto.FileService}\n     */\n\n    this._file = null;\n    /**\n     * @protected\n     * @type {?HashgraphProto.proto.ConsensusService}\n     */\n\n    this._consensus = null;\n    /**\n     * @protected\n     * @type {?HashgraphProto.proto.FreezeService}\n     */\n\n    this._freeze = null;\n    /**\n     * @protected\n     * @type {?HashgraphProto.proto.NetworkService}\n     */\n\n    this._network = null;\n    /**\n     * @protected\n     * @type {?HashgraphProto.proto.TokenService}\n     */\n\n    this._token = null;\n    /**\n     * @protected\n     * @type {?HashgraphProto.proto.ScheduleService}\n     */\n\n    this._schedule = null;\n    /**\n     * @protected\n     * @type {?HashgraphProto.proto.UtilService}\n     */\n\n    this._util = null;\n  }\n  /**\n   * @abstract\n   * @returns {void}\n   */\n\n\n  close() {\n    throw new Error(\"not implemented\");\n  }\n  /**\n   * @returns {HashgraphProto.proto.CryptoService}\n   */\n\n\n  get crypto() {\n    if (this._crypto != null) {\n      return this._crypto;\n    }\n\n    this._crypto = proto.CryptoService.create(this._createUnaryClient(\"CryptoService\"));\n    return this._crypto;\n  }\n  /**\n   * @returns {HashgraphProto.proto.SmartContractService}\n   */\n\n\n  get smartContract() {\n    if (this._smartContract != null) {\n      return this._smartContract;\n    }\n\n    this._smartContract = proto.SmartContractService.create(this._createUnaryClient(\"SmartContractService\"));\n    return this._smartContract;\n  }\n  /**\n   * @returns {HashgraphProto.proto.FileService}\n   */\n\n\n  get file() {\n    if (this._file != null) {\n      return this._file;\n    }\n\n    this._file = proto.FileService.create(this._createUnaryClient(\"FileService\"));\n    return this._file;\n  }\n  /**\n   * @returns {HashgraphProto.proto.ConsensusService}\n   */\n\n\n  get consensus() {\n    if (this._consensus != null) {\n      return this._consensus;\n    }\n\n    this._consensus = proto.ConsensusService.create(this._createUnaryClient(\"ConsensusService\"));\n    return this._consensus;\n  }\n  /**\n   * @returns {HashgraphProto.proto.FreezeService}\n   */\n\n\n  get freeze() {\n    if (this._freeze != null) {\n      return this._freeze;\n    }\n\n    this._freeze = proto.FreezeService.create(this._createUnaryClient(\"FreezeService\"));\n    return this._freeze;\n  }\n  /**\n   * @returns {HashgraphProto.proto.NetworkService}\n   */\n\n\n  get network() {\n    if (this._network != null) {\n      return this._network;\n    }\n\n    this._network = proto.NetworkService.create(this._createUnaryClient(\"NetworkService\"));\n    return this._network;\n  }\n  /**\n   * @returns {HashgraphProto.proto.TokenService}\n   */\n\n\n  get token() {\n    if (this._token != null) {\n      return this._token;\n    }\n\n    this._token = proto.TokenService.create(this._createUnaryClient(\"TokenService\"));\n    return this._token;\n  }\n  /**\n   * @returns {HashgraphProto.proto.ScheduleService}\n   */\n\n\n  get schedule() {\n    if (this._schedule != null) {\n      return this._schedule;\n    }\n\n    this._schedule = proto.ScheduleService.create(this._createUnaryClient(\"ScheduleService\"));\n    return this._schedule;\n  }\n  /**\n   * @returns {HashgraphProto.proto.UtilService}\n   */\n\n\n  get util() {\n    if (this._util != null) {\n      return this._util;\n    }\n\n    this._util = proto.UtilService.create(this._createUnaryClient(\"UtilService\"));\n    return this._util;\n  }\n  /**\n   * @abstract\n   * @protected\n   * @param {string} serviceName\n   * @returns {import(\"protobufjs\").RPCImpl}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _createUnaryClient(serviceName) {\n    throw new Error(\"not implemented\");\n  }\n\n} // grpc-web+proto is a series of data or trailer frames\n// a frame is identified by a single byte (0 = data or 1 = trailer) followed by 4 bytes for the\n// length of the frame, followed by the frame data\n\n/**\n * @param {Uint8Array} data\n * @returns {ArrayBuffer}\n */\n\nexport function encodeRequest(data) {\n  // for our requests, we want to transfer a single data frame\n  const frame = new ArrayBuffer(data.byteLength + 5); // the frame type (data) is zero and can be left default-initialized\n  // the length of the frame data\n\n  new DataView(frame, 1, 4).setUint32(0, data.length); // copy in the frame data\n\n  new Uint8Array(frame, 5).set(data);\n  return frame;\n}\n/**\n * @param {ArrayBuffer} data\n * @param {number} byteOffset\n * @param {number} byteLength\n * @returns {Uint8Array}\n */\n\nexport function decodeUnaryResponse(data) {\n  let byteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let byteLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : data.byteLength;\n  const dataView = new DataView(data, byteOffset, byteLength);\n  let dataOffset = 0;\n  /** @type {?Uint8Array} */\n\n  let unaryResponse = null; // 0 = successful\n\n  let status = 0;\n\n  while (dataOffset < dataView.byteLength) {\n    const frameByte = dataView.getUint8(dataOffset + 0);\n    const frameType = frameByte >> 7;\n    const frameByteLength = dataView.getUint32(dataOffset + 1);\n    const frameOffset = dataOffset + 5; // offset from the start of the dataView\n\n    if (frameOffset + frameByteLength > dataView.byteLength) {\n      throw new Error(\"(BUG) unexpected frame length past the boundary\");\n    }\n\n    const frameData = new Uint8Array(data, dataView.byteOffset + frameOffset, frameByteLength);\n\n    if (frameType === 0) {\n      if (unaryResponse != null) {\n        throw new Error(\"(BUG) unexpectedly received more than one data frame\");\n      }\n\n      unaryResponse = frameData;\n    } else if (frameType === 1) {\n      const trailer = utf8.decode(frameData);\n      const [trailerName, trailerValue] = trailer.split(\":\");\n\n      if (trailerName === \"grpc-status\") {\n        status = parseInt(trailerValue);\n      } else {\n        throw new Error(`(BUG) unhandled trailer, ${trailer}`);\n      }\n    } else {\n      throw new Error(`(BUG) unexpected frame type: ${frameType}`);\n    }\n\n    dataOffset += frameByteLength + 5;\n  }\n\n  if (status !== 0) {\n    throw new Error(`(BUG) unhandled grpc-status: ${status}`);\n  }\n\n  if (unaryResponse == null) {\n    throw new Error(\"(BUG) unexpectedly received no response\");\n  }\n\n  return unaryResponse;\n}","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/hbar-shop/hbar-shopify-coupon-client/node_modules/@hashgraph/sdk/src/channel/Channel.js"],"names":["HashgraphProto","utf8","proto","Channel","constructor","_crypto","_smartContract","_file","_consensus","_freeze","_network","_token","_schedule","_util","close","Error","crypto","CryptoService","create","_createUnaryClient","smartContract","SmartContractService","file","FileService","consensus","ConsensusService","freeze","FreezeService","network","NetworkService","token","TokenService","schedule","ScheduleService","util","UtilService","serviceName","encodeRequest","data","frame","ArrayBuffer","byteLength","DataView","setUint32","length","Uint8Array","set","decodeUnaryResponse","byteOffset","dataView","dataOffset","unaryResponse","status","frameByte","getUint8","frameType","frameByteLength","getUint32","frameOffset","frameData","trailer","decode","trailerName","trailerValue","split","parseInt"],"mappings":"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","sourcesContent":["/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\n\nimport * as HashgraphProto from \"@hashgraph/proto\";\nimport * as utf8 from \"../encoding/utf8.js\";\n\nconst { proto } = HashgraphProto;\n\n/**\n * @internal\n * @abstract\n */\nexport default class Channel {\n    /**\n     * @protected\n     */\n    constructor() {\n        /**\n         * @protected\n         * @type {?HashgraphProto.proto.CryptoService}\n         */\n        this._crypto = null;\n\n        /**\n         * @protected\n         * @type {?HashgraphProto.proto.SmartContractService}\n         */\n        this._smartContract = null;\n\n        /**\n         * @protected\n         * @type {?HashgraphProto.proto.FileService}\n         */\n        this._file = null;\n\n        /**\n         * @protected\n         * @type {?HashgraphProto.proto.ConsensusService}\n         */\n        this._consensus = null;\n\n        /**\n         * @protected\n         * @type {?HashgraphProto.proto.FreezeService}\n         */\n        this._freeze = null;\n\n        /**\n         * @protected\n         * @type {?HashgraphProto.proto.NetworkService}\n         */\n        this._network = null;\n\n        /**\n         * @protected\n         * @type {?HashgraphProto.proto.TokenService}\n         */\n        this._token = null;\n\n        /**\n         * @protected\n         * @type {?HashgraphProto.proto.ScheduleService}\n         */\n        this._schedule = null;\n\n        /**\n         * @protected\n         * @type {?HashgraphProto.proto.UtilService}\n         */\n        this._util = null;\n    }\n\n    /**\n     * @abstract\n     * @returns {void}\n     */\n    close() {\n        throw new Error(\"not implemented\");\n    }\n\n    /**\n     * @returns {HashgraphProto.proto.CryptoService}\n     */\n    get crypto() {\n        if (this._crypto != null) {\n            return this._crypto;\n        }\n\n        this._crypto = proto.CryptoService.create(\n            this._createUnaryClient(\"CryptoService\")\n        );\n\n        return this._crypto;\n    }\n\n    /**\n     * @returns {HashgraphProto.proto.SmartContractService}\n     */\n    get smartContract() {\n        if (this._smartContract != null) {\n            return this._smartContract;\n        }\n\n        this._smartContract = proto.SmartContractService.create(\n            this._createUnaryClient(\"SmartContractService\")\n        );\n\n        return this._smartContract;\n    }\n\n    /**\n     * @returns {HashgraphProto.proto.FileService}\n     */\n    get file() {\n        if (this._file != null) {\n            return this._file;\n        }\n\n        this._file = proto.FileService.create(\n            this._createUnaryClient(\"FileService\")\n        );\n\n        return this._file;\n    }\n\n    /**\n     * @returns {HashgraphProto.proto.ConsensusService}\n     */\n    get consensus() {\n        if (this._consensus != null) {\n            return this._consensus;\n        }\n\n        this._consensus = proto.ConsensusService.create(\n            this._createUnaryClient(\"ConsensusService\")\n        );\n\n        return this._consensus;\n    }\n\n    /**\n     * @returns {HashgraphProto.proto.FreezeService}\n     */\n    get freeze() {\n        if (this._freeze != null) {\n            return this._freeze;\n        }\n\n        this._freeze = proto.FreezeService.create(\n            this._createUnaryClient(\"FreezeService\")\n        );\n\n        return this._freeze;\n    }\n\n    /**\n     * @returns {HashgraphProto.proto.NetworkService}\n     */\n    get network() {\n        if (this._network != null) {\n            return this._network;\n        }\n\n        this._network = proto.NetworkService.create(\n            this._createUnaryClient(\"NetworkService\")\n        );\n\n        return this._network;\n    }\n\n    /**\n     * @returns {HashgraphProto.proto.TokenService}\n     */\n    get token() {\n        if (this._token != null) {\n            return this._token;\n        }\n\n        this._token = proto.TokenService.create(\n            this._createUnaryClient(\"TokenService\")\n        );\n\n        return this._token;\n    }\n\n    /**\n     * @returns {HashgraphProto.proto.ScheduleService}\n     */\n    get schedule() {\n        if (this._schedule != null) {\n            return this._schedule;\n        }\n\n        this._schedule = proto.ScheduleService.create(\n            this._createUnaryClient(\"ScheduleService\")\n        );\n\n        return this._schedule;\n    }\n\n    /**\n     * @returns {HashgraphProto.proto.UtilService}\n     */\n    get util() {\n        if (this._util != null) {\n            return this._util;\n        }\n\n        this._util = proto.UtilService.create(\n            this._createUnaryClient(\"UtilService\")\n        );\n\n        return this._util;\n    }\n\n    /**\n     * @abstract\n     * @protected\n     * @param {string} serviceName\n     * @returns {import(\"protobufjs\").RPCImpl}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _createUnaryClient(serviceName) {\n        throw new Error(\"not implemented\");\n    }\n}\n\n// grpc-web+proto is a series of data or trailer frames\n\n// a frame is identified by a single byte (0 = data or 1 = trailer) followed by 4 bytes for the\n// length of the frame, followed by the frame data\n\n/**\n * @param {Uint8Array} data\n * @returns {ArrayBuffer}\n */\nexport function encodeRequest(data) {\n    // for our requests, we want to transfer a single data frame\n\n    const frame = new ArrayBuffer(data.byteLength + 5);\n\n    // the frame type (data) is zero and can be left default-initialized\n\n    // the length of the frame data\n    new DataView(frame, 1, 4).setUint32(0, data.length);\n\n    // copy in the frame data\n    new Uint8Array(frame, 5).set(data);\n\n    return frame;\n}\n\n/**\n * @param {ArrayBuffer} data\n * @param {number} byteOffset\n * @param {number} byteLength\n * @returns {Uint8Array}\n */\nexport function decodeUnaryResponse(\n    data,\n    byteOffset = 0,\n    byteLength = data.byteLength\n) {\n    const dataView = new DataView(data, byteOffset, byteLength);\n    let dataOffset = 0;\n\n    /** @type {?Uint8Array} */\n    let unaryResponse = null;\n\n    // 0 = successful\n    let status = 0;\n\n    while (dataOffset < dataView.byteLength) {\n        const frameByte = dataView.getUint8(dataOffset + 0);\n        const frameType = frameByte >> 7;\n        const frameByteLength = dataView.getUint32(dataOffset + 1);\n        const frameOffset = dataOffset + 5; // offset from the start of the dataView\n        if (frameOffset + frameByteLength > dataView.byteLength) {\n            throw new Error(\"(BUG) unexpected frame length past the boundary\");\n        }\n        const frameData = new Uint8Array(\n            data,\n            dataView.byteOffset + frameOffset,\n            frameByteLength\n        );\n\n        if (frameType === 0) {\n            if (unaryResponse != null) {\n                throw new Error(\n                    \"(BUG) unexpectedly received more than one data frame\"\n                );\n            }\n\n            unaryResponse = frameData;\n        } else if (frameType === 1) {\n            const trailer = utf8.decode(frameData);\n            const [trailerName, trailerValue] = trailer.split(\":\");\n\n            if (trailerName === \"grpc-status\") {\n                status = parseInt(trailerValue);\n            } else {\n                throw new Error(`(BUG) unhandled trailer, ${trailer}`);\n            }\n        } else {\n            throw new Error(`(BUG) unexpected frame type: ${frameType}`);\n        }\n\n        dataOffset += frameByteLength + 5;\n    }\n\n    if (status !== 0) {\n        throw new Error(`(BUG) unhandled grpc-status: ${status}`);\n    }\n\n    if (unaryResponse == null) {\n        throw new Error(\"(BUG) unexpectedly received no response\");\n    }\n\n    return unaryResponse;\n}\n"]},"metadata":{},"sourceType":"module"}