{"ast":null,"code":"/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\nimport Transaction, { TRANSACTION_REGISTRY, CHUNK_SIZE } from \"../transaction/Transaction.js\";\nimport TopicId from \"./TopicId.js\";\nimport * as utf8 from \"../encoding/utf8.js\";\nimport TransactionId from \"../transaction/TransactionId.js\";\nimport Timestamp from \"../Timestamp.js\";\nimport * as util from \"../util.js\";\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").proto.IConsensusSubmitMessageTransactionBody} HashgraphProto.proto.IConsensusSubmitMessageTransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransaction} HashgraphProto.proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").proto.ISignedTransaction} HashgraphProto.proto.ISignedTransaction\n * @typedef {import(\"@hashgraph/proto\").proto.TransactionBody} HashgraphProto.proto.TransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionBody} HashgraphProto.proto.ITransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionResponse} HashgraphProto.proto.ITransactionResponse\n * @typedef {import(\"@hashgraph/proto\").proto.IConsensusMessageChunkInfo} HashgraphProto.proto.IConsensusMessageChunkInfo\n */\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../account/AccountId.js\").default} AccountId\n * @typedef {import(\"../transaction/TransactionResponse.js\").default} TransactionResponse\n * @typedef {import(\"../schedule/ScheduleCreateTransaction.js\").default} ScheduleCreateTransaction\n */\n\nexport default class TopicMessageSubmitTransaction extends Transaction {\n  /**\n   * @param {object} props\n   * @param {TopicId | string} [props.topicId]\n   * @param {Uint8Array | string} [props.message]\n   * @param {number} [props.maxChunks]\n   * @param {number} [props.chunkSize]\n   */\n  constructor() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    /**\n     * @private\n     * @type {?TopicId}\n     */\n\n    this._topicId = null;\n\n    if (props.topicId != null) {\n      this.setTopicId(props.topicId);\n    }\n    /**\n     * @private\n     * @type {?Uint8Array}\n     */\n\n\n    this._message = null;\n\n    if (props.message != null) {\n      this.setMessage(props.message);\n    }\n    /**\n     * @private\n     * @type {number}\n     */\n\n\n    this._maxChunks = 20;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this._chunkSize = CHUNK_SIZE;\n\n    if (props.maxChunks != null) {\n      this.setMaxChunks(props.maxChunks);\n    }\n\n    if (props.chunkSize != null) {\n      this.setChunkSize(props.chunkSize);\n    }\n    /** @type {HashgraphProto.proto.IConsensusMessageChunkInfo | null} */\n\n\n    this._chunkInfo = null;\n  }\n  /**\n   * @internal\n   * @param {HashgraphProto.proto.ITransaction[]} transactions\n   * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions\n   * @param {TransactionId[]} transactionIds\n   * @param {AccountId[]} nodeIds\n   * @param {HashgraphProto.proto.ITransactionBody[]} bodies\n   * @returns {TopicMessageSubmitTransaction}\n   */\n\n\n  static _fromProtobuf(transactions, signedTransactions, transactionIds, nodeIds, bodies) {\n    const body = bodies[0];\n    const message =\n    /** @type {HashgraphProto.proto.IConsensusSubmitMessageTransactionBody} */\n    body.consensusSubmitMessage;\n    return Transaction._fromProtobufTransactions(new TopicMessageSubmitTransaction({\n      topicId: message.topicID != null ? TopicId._fromProtobuf(message.topicID) : undefined,\n      message: message.message != null ? message.message : undefined\n    }), transactions, signedTransactions, transactionIds, nodeIds, bodies);\n  }\n  /**\n   * @returns {?TopicId}\n   */\n\n\n  get topicId() {\n    return this._topicId;\n  }\n  /**\n   * @param {TopicId | string} topicId\n   * @returns {this}\n   */\n\n\n  setTopicId(topicId) {\n    this._requireNotFrozen();\n\n    this._topicId = typeof topicId === \"string\" ? TopicId.fromString(topicId) : topicId.clone();\n    return this;\n  }\n  /**\n   * @returns {?Uint8Array}\n   */\n\n\n  get message() {\n    return this._message;\n  }\n  /**\n   * @param {string | Uint8Array} message\n   * @returns {this}\n   */\n\n\n  setMessage(message) {\n    this._requireNotFrozen();\n\n    message = util.requireStringOrUint8Array(message);\n    this._message = message instanceof Uint8Array ? message : utf8.encode(message);\n    return this;\n  }\n  /**\n   * @returns {?number}\n   */\n\n\n  get maxChunks() {\n    return this._maxChunks;\n  }\n  /**\n   * @param {number} maxChunks\n   * @returns {this}\n   */\n\n\n  setMaxChunks(maxChunks) {\n    this._requireNotFrozen();\n\n    this._maxChunks = maxChunks;\n    return this;\n  }\n  /**\n   * @returns {?number}\n   */\n\n\n  get chunkSize() {\n    return this._chunkSize;\n  }\n  /**\n   * @param {number} chunkSize\n   * @returns {this}\n   */\n\n\n  setChunkSize(chunkSize) {\n    this._chunkSize = chunkSize;\n    return this;\n  }\n  /**\n   * Freeze this transaction from further modification to prepare for\n   * signing or serialization.\n   *\n   * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3\n   * nodes to prepare this transaction for.\n   *\n   * @param {?import(\"../client/Client.js\").default<Channel, *>} client\n   * @returns {this}\n   */\n\n\n  freezeWith(client) {\n    super.freezeWith(client);\n\n    if (this._message == null) {\n      return this;\n    }\n\n    const chunks = Math.floor((this._message.length + (this._chunkSize - 1)) / this._chunkSize);\n\n    if (chunks > this._maxChunks) {\n      throw new Error(`Message with size ${this._message.length} too long for ${this._maxChunks} chunks`);\n    }\n\n    const initialTransactionId = this._getTransactionId()._toProtobuf();\n\n    let nextTransactionId = this._getTransactionId(); // Hack around the locked list. Should refactor a bit to remove such code\n\n\n    this._transactionIds.locked = false;\n\n    this._transactions.clear();\n\n    this._transactionIds.clear();\n\n    this._signedTransactions.clear();\n\n    for (let chunk = 0; chunk < chunks; chunk++) {\n      this._chunkInfo = {\n        initialTransactionID: initialTransactionId,\n        total: chunks,\n        number: chunk + 1\n      };\n\n      this._transactionIds.push(nextTransactionId);\n\n      this._transactionIds.advance();\n\n      for (const nodeAccountId of this._nodeAccountIds.list) {\n        this._signedTransactions.push(this._makeSignedTransaction(nodeAccountId));\n      }\n\n      nextTransactionId = new TransactionId(\n      /** @type {AccountId} */\n      nextTransactionId.accountId, new Timestamp(\n      /** @type {Timestamp} */\n      nextTransactionId.validStart.seconds,\n      /** @type {Timestamp} */\n      nextTransactionId.validStart.nanos.add(1)));\n    }\n\n    this._transactionIds.advance();\n\n    this._chunkInfo = null;\n    return this;\n  }\n  /**\n   * @returns {ScheduleCreateTransaction}\n   */\n\n\n  schedule() {\n    this._requireNotFrozen();\n\n    if (this._message != null && this._message.length > this._chunkSize) {\n      throw new Error(`cannot schedule \\`TopicMessageSubmitTransaction\\` with message over ${this._chunkSize} bytes`);\n    }\n\n    return super.schedule();\n  }\n  /**\n   * @param {import(\"../client/Client.js\").default<Channel, *>} client\n   * @param {number=} requestTimeout\n   * @returns {Promise<TransactionResponse>}\n   */\n\n\n  async execute(client, requestTimeout) {\n    return (await this.executeAll(client, requestTimeout))[0];\n  }\n  /**\n   * @param {import(\"../client/Client.js\").default<Channel, *>} client\n   * @param {number=} requestTimeout\n   * @returns {Promise<TransactionResponse[]>}\n   */\n\n\n  async executeAll(client, requestTimeout) {\n    if (!super._isFrozen()) {\n      this.freezeWith(client);\n    } // on execute, sign each transaction with the operator, if present\n    // and we are signing a transaction that used the default transaction ID\n\n\n    const transactionId = this._getTransactionId();\n\n    const operatorAccountId = client.operatorAccountId;\n\n    if (operatorAccountId != null && operatorAccountId.equals(\n    /** @type {AccountId} */\n    transactionId.accountId)) {\n      await super.signWithOperator(client);\n    }\n\n    const responses = [];\n    let remainingTimeout = requestTimeout;\n\n    for (let i = 0; i < this._transactionIds.length; i++) {\n      const startTimestamp = Date.now();\n      responses.push(await super.execute(client, remainingTimeout));\n\n      if (remainingTimeout != null) {\n        remainingTimeout = Date.now() - startTimestamp;\n      }\n    }\n\n    return responses;\n  }\n  /**\n   * @override\n   * @internal\n   * @param {Channel} channel\n   * @param {HashgraphProto.proto.ITransaction} request\n   * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}\n   */\n\n\n  _execute(channel, request) {\n    return channel.consensus.submitMessage(request);\n  }\n  /**\n   * @override\n   * @protected\n   * @returns {NonNullable<HashgraphProto.proto.TransactionBody[\"data\"]>}\n   */\n\n\n  _getTransactionDataCase() {\n    return \"consensusSubmitMessage\";\n  }\n  /**\n   * @override\n   * @protected\n   * @returns {HashgraphProto.proto.IConsensusSubmitMessageTransactionBody}\n   */\n\n\n  _makeTransactionData() {\n    if (this._chunkInfo != null && this._message != null) {\n      const num =\n      /** @type {number} */\n      this._chunkInfo.number;\n      const startIndex = (num - 1) * this._chunkSize;\n      let endIndex = startIndex + this._chunkSize;\n\n      if (endIndex > this._message.length) {\n        endIndex = this._message.length;\n      }\n\n      return {\n        topicID: this._topicId != null ? this._topicId._toProtobuf() : null,\n        message: this._message.slice(startIndex, endIndex),\n        chunkInfo: this._chunkInfo\n      };\n    } else {\n      return {\n        topicID: this._topicId != null ? this._topicId._toProtobuf() : null,\n        message: this._message\n      };\n    }\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  _getLogId() {\n    const timestamp =\n    /** @type {import(\"../Timestamp.js\").default} */\n    this._transactionIds.current.validStart;\n    return `TopicMessageSubmitTransaction:${timestamp.toString()}`;\n  }\n\n}\nTRANSACTION_REGISTRY.set(\"consensusSubmitMessage\", // eslint-disable-next-line @typescript-eslint/unbound-method\nTopicMessageSubmitTransaction._fromProtobuf);","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/hbar-shop/hbar-shopify-coupon-client/node_modules/@hashgraph/sdk/src/topic/TopicMessageSubmitTransaction.js"],"names":["Transaction","TRANSACTION_REGISTRY","CHUNK_SIZE","TopicId","utf8","TransactionId","Timestamp","util","TopicMessageSubmitTransaction","constructor","props","_topicId","topicId","setTopicId","_message","message","setMessage","_maxChunks","_chunkSize","maxChunks","setMaxChunks","chunkSize","setChunkSize","_chunkInfo","_fromProtobuf","transactions","signedTransactions","transactionIds","nodeIds","bodies","body","consensusSubmitMessage","_fromProtobufTransactions","topicID","undefined","_requireNotFrozen","fromString","clone","requireStringOrUint8Array","Uint8Array","encode","freezeWith","client","chunks","Math","floor","length","Error","initialTransactionId","_getTransactionId","_toProtobuf","nextTransactionId","_transactionIds","locked","_transactions","clear","_signedTransactions","chunk","initialTransactionID","total","number","push","advance","nodeAccountId","_nodeAccountIds","list","_makeSignedTransaction","accountId","validStart","seconds","nanos","add","schedule","execute","requestTimeout","executeAll","_isFrozen","transactionId","operatorAccountId","equals","signWithOperator","responses","remainingTimeout","i","startTimestamp","Date","now","_execute","channel","request","consensus","submitMessage","_getTransactionDataCase","_makeTransactionData","num","startIndex","endIndex","slice","chunkInfo","_getLogId","timestamp","current","toString","set"],"mappings":"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","sourcesContent":["/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\n\nimport Transaction, {\n    TRANSACTION_REGISTRY,\n    CHUNK_SIZE,\n} from \"../transaction/Transaction.js\";\nimport TopicId from \"./TopicId.js\";\nimport * as utf8 from \"../encoding/utf8.js\";\nimport TransactionId from \"../transaction/TransactionId.js\";\nimport Timestamp from \"../Timestamp.js\";\nimport * as util from \"../util.js\";\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").proto.IConsensusSubmitMessageTransactionBody} HashgraphProto.proto.IConsensusSubmitMessageTransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransaction} HashgraphProto.proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").proto.ISignedTransaction} HashgraphProto.proto.ISignedTransaction\n * @typedef {import(\"@hashgraph/proto\").proto.TransactionBody} HashgraphProto.proto.TransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionBody} HashgraphProto.proto.ITransactionBody\n * @typedef {import(\"@hashgraph/proto\").proto.ITransactionResponse} HashgraphProto.proto.ITransactionResponse\n * @typedef {import(\"@hashgraph/proto\").proto.IConsensusMessageChunkInfo} HashgraphProto.proto.IConsensusMessageChunkInfo\n */\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../account/AccountId.js\").default} AccountId\n * @typedef {import(\"../transaction/TransactionResponse.js\").default} TransactionResponse\n * @typedef {import(\"../schedule/ScheduleCreateTransaction.js\").default} ScheduleCreateTransaction\n */\n\nexport default class TopicMessageSubmitTransaction extends Transaction {\n    /**\n     * @param {object} props\n     * @param {TopicId | string} [props.topicId]\n     * @param {Uint8Array | string} [props.message]\n     * @param {number} [props.maxChunks]\n     * @param {number} [props.chunkSize]\n     */\n    constructor(props = {}) {\n        super();\n\n        /**\n         * @private\n         * @type {?TopicId}\n         */\n        this._topicId = null;\n\n        if (props.topicId != null) {\n            this.setTopicId(props.topicId);\n        }\n\n        /**\n         * @private\n         * @type {?Uint8Array}\n         */\n        this._message = null;\n\n        if (props.message != null) {\n            this.setMessage(props.message);\n        }\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._maxChunks = 20;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._chunkSize = CHUNK_SIZE;\n\n        if (props.maxChunks != null) {\n            this.setMaxChunks(props.maxChunks);\n        }\n\n        if (props.chunkSize != null) {\n            this.setChunkSize(props.chunkSize);\n        }\n\n        /** @type {HashgraphProto.proto.IConsensusMessageChunkInfo | null} */\n        this._chunkInfo = null;\n    }\n\n    /**\n     * @internal\n     * @param {HashgraphProto.proto.ITransaction[]} transactions\n     * @param {HashgraphProto.proto.ISignedTransaction[]} signedTransactions\n     * @param {TransactionId[]} transactionIds\n     * @param {AccountId[]} nodeIds\n     * @param {HashgraphProto.proto.ITransactionBody[]} bodies\n     * @returns {TopicMessageSubmitTransaction}\n     */\n    static _fromProtobuf(\n        transactions,\n        signedTransactions,\n        transactionIds,\n        nodeIds,\n        bodies\n    ) {\n        const body = bodies[0];\n        const message =\n            /** @type {HashgraphProto.proto.IConsensusSubmitMessageTransactionBody} */ (\n                body.consensusSubmitMessage\n            );\n\n        return Transaction._fromProtobufTransactions(\n            new TopicMessageSubmitTransaction({\n                topicId:\n                    message.topicID != null\n                        ? TopicId._fromProtobuf(message.topicID)\n                        : undefined,\n                message: message.message != null ? message.message : undefined,\n            }),\n            transactions,\n            signedTransactions,\n            transactionIds,\n            nodeIds,\n            bodies\n        );\n    }\n\n    /**\n     * @returns {?TopicId}\n     */\n    get topicId() {\n        return this._topicId;\n    }\n\n    /**\n     * @param {TopicId | string} topicId\n     * @returns {this}\n     */\n    setTopicId(topicId) {\n        this._requireNotFrozen();\n\n        this._topicId =\n            typeof topicId === \"string\"\n                ? TopicId.fromString(topicId)\n                : topicId.clone();\n\n        return this;\n    }\n\n    /**\n     * @returns {?Uint8Array}\n     */\n    get message() {\n        return this._message;\n    }\n\n    /**\n     * @param {string | Uint8Array} message\n     * @returns {this}\n     */\n    setMessage(message) {\n        this._requireNotFrozen();\n        message = util.requireStringOrUint8Array(message);\n        this._message =\n            message instanceof Uint8Array ? message : utf8.encode(message);\n        return this;\n    }\n\n    /**\n     * @returns {?number}\n     */\n    get maxChunks() {\n        return this._maxChunks;\n    }\n\n    /**\n     * @param {number} maxChunks\n     * @returns {this}\n     */\n    setMaxChunks(maxChunks) {\n        this._requireNotFrozen();\n        this._maxChunks = maxChunks;\n        return this;\n    }\n\n    /**\n     * @returns {?number}\n     */\n    get chunkSize() {\n        return this._chunkSize;\n    }\n\n    /**\n     * @param {number} chunkSize\n     * @returns {this}\n     */\n    setChunkSize(chunkSize) {\n        this._chunkSize = chunkSize;\n        return this;\n    }\n\n    /**\n     * Freeze this transaction from further modification to prepare for\n     * signing or serialization.\n     *\n     * Will use the `Client`, if available, to generate a default Transaction ID and select 1/3\n     * nodes to prepare this transaction for.\n     *\n     * @param {?import(\"../client/Client.js\").default<Channel, *>} client\n     * @returns {this}\n     */\n    freezeWith(client) {\n        super.freezeWith(client);\n\n        if (this._message == null) {\n            return this;\n        }\n\n        const chunks = Math.floor(\n            (this._message.length + (this._chunkSize - 1)) / this._chunkSize\n        );\n\n        if (chunks > this._maxChunks) {\n            throw new Error(\n                `Message with size ${this._message.length} too long for ${this._maxChunks} chunks`\n            );\n        }\n\n        const initialTransactionId = this._getTransactionId()._toProtobuf();\n        let nextTransactionId = this._getTransactionId();\n\n        // Hack around the locked list. Should refactor a bit to remove such code\n        this._transactionIds.locked = false;\n\n        this._transactions.clear();\n        this._transactionIds.clear();\n        this._signedTransactions.clear();\n\n        for (let chunk = 0; chunk < chunks; chunk++) {\n            this._chunkInfo = {\n                initialTransactionID: initialTransactionId,\n                total: chunks,\n                number: chunk + 1,\n            };\n\n            this._transactionIds.push(nextTransactionId);\n            this._transactionIds.advance();\n\n            for (const nodeAccountId of this._nodeAccountIds.list) {\n                this._signedTransactions.push(\n                    this._makeSignedTransaction(nodeAccountId)\n                );\n            }\n\n            nextTransactionId = new TransactionId(\n                /** @type {AccountId} */ (nextTransactionId.accountId),\n                new Timestamp(\n                    /** @type {Timestamp} */ (\n                        nextTransactionId.validStart\n                    ).seconds,\n                    /** @type {Timestamp} */ (\n                        nextTransactionId.validStart\n                    ).nanos.add(1)\n                )\n            );\n        }\n\n        this._transactionIds.advance();\n        this._chunkInfo = null;\n\n        return this;\n    }\n\n    /**\n     * @returns {ScheduleCreateTransaction}\n     */\n    schedule() {\n        this._requireNotFrozen();\n\n        if (this._message != null && this._message.length > this._chunkSize) {\n            throw new Error(\n                `cannot schedule \\`TopicMessageSubmitTransaction\\` with message over ${this._chunkSize} bytes`\n            );\n        }\n\n        return super.schedule();\n    }\n\n    /**\n     * @param {import(\"../client/Client.js\").default<Channel, *>} client\n     * @param {number=} requestTimeout\n     * @returns {Promise<TransactionResponse>}\n     */\n    async execute(client, requestTimeout) {\n        return (await this.executeAll(client, requestTimeout))[0];\n    }\n\n    /**\n     * @param {import(\"../client/Client.js\").default<Channel, *>} client\n     * @param {number=} requestTimeout\n     * @returns {Promise<TransactionResponse[]>}\n     */\n    async executeAll(client, requestTimeout) {\n        if (!super._isFrozen()) {\n            this.freezeWith(client);\n        }\n\n        // on execute, sign each transaction with the operator, if present\n        // and we are signing a transaction that used the default transaction ID\n\n        const transactionId = this._getTransactionId();\n        const operatorAccountId = client.operatorAccountId;\n\n        if (\n            operatorAccountId != null &&\n            operatorAccountId.equals(\n                /** @type {AccountId} */ (transactionId.accountId)\n            )\n        ) {\n            await super.signWithOperator(client);\n        }\n\n        const responses = [];\n        let remainingTimeout = requestTimeout;\n        for (let i = 0; i < this._transactionIds.length; i++) {\n            const startTimestamp = Date.now();\n            responses.push(await super.execute(client, remainingTimeout));\n\n            if (remainingTimeout != null) {\n                remainingTimeout = Date.now() - startTimestamp;\n            }\n        }\n\n        return responses;\n    }\n\n    /**\n     * @override\n     * @internal\n     * @param {Channel} channel\n     * @param {HashgraphProto.proto.ITransaction} request\n     * @returns {Promise<HashgraphProto.proto.ITransactionResponse>}\n     */\n    _execute(channel, request) {\n        return channel.consensus.submitMessage(request);\n    }\n\n    /**\n     * @override\n     * @protected\n     * @returns {NonNullable<HashgraphProto.proto.TransactionBody[\"data\"]>}\n     */\n    _getTransactionDataCase() {\n        return \"consensusSubmitMessage\";\n    }\n\n    /**\n     * @override\n     * @protected\n     * @returns {HashgraphProto.proto.IConsensusSubmitMessageTransactionBody}\n     */\n    _makeTransactionData() {\n        if (this._chunkInfo != null && this._message != null) {\n            const num = /** @type {number} */ (this._chunkInfo.number);\n            const startIndex = (num - 1) * this._chunkSize;\n            let endIndex = startIndex + this._chunkSize;\n\n            if (endIndex > this._message.length) {\n                endIndex = this._message.length;\n            }\n\n            return {\n                topicID:\n                    this._topicId != null ? this._topicId._toProtobuf() : null,\n                message: this._message.slice(startIndex, endIndex),\n                chunkInfo: this._chunkInfo,\n            };\n        } else {\n            return {\n                topicID:\n                    this._topicId != null ? this._topicId._toProtobuf() : null,\n                message: this._message,\n            };\n        }\n    }\n\n    /**\n     * @returns {string}\n     */\n    _getLogId() {\n        const timestamp = /** @type {import(\"../Timestamp.js\").default} */ (\n            this._transactionIds.current.validStart\n        );\n        return `TopicMessageSubmitTransaction:${timestamp.toString()}`;\n    }\n}\n\nTRANSACTION_REGISTRY.set(\n    \"consensusSubmitMessage\",\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    TopicMessageSubmitTransaction._fromProtobuf\n);\n"]},"metadata":{},"sourceType":"module"}