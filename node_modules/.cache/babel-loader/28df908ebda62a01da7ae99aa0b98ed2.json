{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _ = require(\"../\");\n\nvar _uint = require(\"../parsers/uint8\"); // a set of 0x00 terminated subblocks\n\n\nvar subBlocksSchema = {\n  blocks: function blocks(stream) {\n    var terminator = 0x00;\n    var chunks = [];\n    var streamSize = stream.data.length;\n    var total = 0;\n\n    for (var size = (0, _uint.readByte)()(stream); size !== terminator; size = (0, _uint.readByte)()(stream)) {\n      // size becomes undefined for some case when file is corrupted and  terminator is not proper \n      // null check to avoid recursion\n      if (!size) break; // catch corrupted files with no terminator\n\n      if (stream.pos + size >= streamSize) {\n        var availableSize = streamSize - stream.pos;\n        chunks.push((0, _uint.readBytes)(availableSize)(stream));\n        total += availableSize;\n        break;\n      }\n\n      chunks.push((0, _uint.readBytes)(size)(stream));\n      total += size;\n    }\n\n    var result = new Uint8Array(total);\n    var offset = 0;\n\n    for (var i = 0; i < chunks.length; i++) {\n      result.set(chunks[i], offset);\n      offset += chunks[i].length;\n    }\n\n    return result;\n  }\n}; // global control extension\n\nvar gceSchema = (0, _.conditional)({\n  gce: [{\n    codes: (0, _uint.readBytes)(2)\n  }, {\n    byteSize: (0, _uint.readByte)()\n  }, {\n    extras: (0, _uint.readBits)({\n      future: {\n        index: 0,\n        length: 3\n      },\n      disposal: {\n        index: 3,\n        length: 3\n      },\n      userInput: {\n        index: 6\n      },\n      transparentColorGiven: {\n        index: 7\n      }\n    })\n  }, {\n    delay: (0, _uint.readUnsigned)(true)\n  }, {\n    transparentColorIndex: (0, _uint.readByte)()\n  }, {\n    terminator: (0, _uint.readByte)()\n  }]\n}, function (stream) {\n  var codes = (0, _uint.peekBytes)(2)(stream);\n  return codes[0] === 0x21 && codes[1] === 0xf9;\n}); // image pipeline block\n\nvar imageSchema = (0, _.conditional)({\n  image: [{\n    code: (0, _uint.readByte)()\n  }, {\n    descriptor: [{\n      left: (0, _uint.readUnsigned)(true)\n    }, {\n      top: (0, _uint.readUnsigned)(true)\n    }, {\n      width: (0, _uint.readUnsigned)(true)\n    }, {\n      height: (0, _uint.readUnsigned)(true)\n    }, {\n      lct: (0, _uint.readBits)({\n        exists: {\n          index: 0\n        },\n        interlaced: {\n          index: 1\n        },\n        sort: {\n          index: 2\n        },\n        future: {\n          index: 3,\n          length: 2\n        },\n        size: {\n          index: 5,\n          length: 3\n        }\n      })\n    }]\n  }, (0, _.conditional)({\n    lct: (0, _uint.readArray)(3, function (stream, result, parent) {\n      return Math.pow(2, parent.descriptor.lct.size + 1);\n    })\n  }, function (stream, result, parent) {\n    return parent.descriptor.lct.exists;\n  }), {\n    data: [{\n      minCodeSize: (0, _uint.readByte)()\n    }, subBlocksSchema]\n  }]\n}, function (stream) {\n  return (0, _uint.peekByte)()(stream) === 0x2c;\n}); // plain text block\n\nvar textSchema = (0, _.conditional)({\n  text: [{\n    codes: (0, _uint.readBytes)(2)\n  }, {\n    blockSize: (0, _uint.readByte)()\n  }, {\n    preData: function preData(stream, result, parent) {\n      return (0, _uint.readBytes)(parent.text.blockSize)(stream);\n    }\n  }, subBlocksSchema]\n}, function (stream) {\n  var codes = (0, _uint.peekBytes)(2)(stream);\n  return codes[0] === 0x21 && codes[1] === 0x01;\n}); // application block\n\nvar applicationSchema = (0, _.conditional)({\n  application: [{\n    codes: (0, _uint.readBytes)(2)\n  }, {\n    blockSize: (0, _uint.readByte)()\n  }, {\n    id: function id(stream, result, parent) {\n      return (0, _uint.readString)(parent.blockSize)(stream);\n    }\n  }, subBlocksSchema]\n}, function (stream) {\n  var codes = (0, _uint.peekBytes)(2)(stream);\n  return codes[0] === 0x21 && codes[1] === 0xff;\n}); // comment block\n\nvar commentSchema = (0, _.conditional)({\n  comment: [{\n    codes: (0, _uint.readBytes)(2)\n  }, subBlocksSchema]\n}, function (stream) {\n  var codes = (0, _uint.peekBytes)(2)(stream);\n  return codes[0] === 0x21 && codes[1] === 0xfe;\n});\nvar schema = [{\n  header: [{\n    signature: (0, _uint.readString)(3)\n  }, {\n    version: (0, _uint.readString)(3)\n  }]\n}, {\n  lsd: [{\n    width: (0, _uint.readUnsigned)(true)\n  }, {\n    height: (0, _uint.readUnsigned)(true)\n  }, {\n    gct: (0, _uint.readBits)({\n      exists: {\n        index: 0\n      },\n      resolution: {\n        index: 1,\n        length: 3\n      },\n      sort: {\n        index: 4\n      },\n      size: {\n        index: 5,\n        length: 3\n      }\n    })\n  }, {\n    backgroundColorIndex: (0, _uint.readByte)()\n  }, {\n    pixelAspectRatio: (0, _uint.readByte)()\n  }]\n}, (0, _.conditional)({\n  gct: (0, _uint.readArray)(3, function (stream, result) {\n    return Math.pow(2, result.lsd.gct.size + 1);\n  })\n}, function (stream, result) {\n  return result.lsd.gct.exists;\n}), // content frames\n{\n  frames: (0, _.loop)([gceSchema, applicationSchema, commentSchema, imageSchema, textSchema], function (stream) {\n    var nextCode = (0, _uint.peekByte)()(stream); // rather than check for a terminator, we should check for the existence\n    // of an ext or image block to avoid infinite loops\n    //var terminator = 0x3B;\n    //return nextCode !== terminator;\n\n    return nextCode === 0x21 || nextCode === 0x2c;\n  })\n}];\nvar _default = schema;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/hbar-shop/hbar-shop-dashboard/node_modules/js-binary-schema-parser/lib/schemas/gif.js"],"names":["Object","defineProperty","exports","value","_","require","_uint","subBlocksSchema","blocks","stream","terminator","chunks","streamSize","data","length","total","size","readByte","pos","availableSize","push","readBytes","result","Uint8Array","offset","i","set","gceSchema","conditional","gce","codes","byteSize","extras","readBits","future","index","disposal","userInput","transparentColorGiven","delay","readUnsigned","transparentColorIndex","peekBytes","imageSchema","image","code","descriptor","left","top","width","height","lct","exists","interlaced","sort","readArray","parent","Math","pow","minCodeSize","peekByte","textSchema","text","blockSize","preData","applicationSchema","application","id","readString","commentSchema","comment","schema","header","signature","version","lsd","gct","resolution","backgroundColorIndex","pixelAspectRatio","frames","loop","nextCode","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _ = require(\"../\");\n\nvar _uint = require(\"../parsers/uint8\");\n\n// a set of 0x00 terminated subblocks\nvar subBlocksSchema = {\n  blocks: function blocks(stream) {\n    var terminator = 0x00;\n    var chunks = [];\n    var streamSize = stream.data.length;\n    var total = 0;\n\n    for (var size = (0, _uint.readByte)()(stream); size !== terminator; size = (0, _uint.readByte)()(stream)) {\n      // size becomes undefined for some case when file is corrupted and  terminator is not proper \n      // null check to avoid recursion\n      if (!size) break; // catch corrupted files with no terminator\n\n      if (stream.pos + size >= streamSize) {\n        var availableSize = streamSize - stream.pos;\n        chunks.push((0, _uint.readBytes)(availableSize)(stream));\n        total += availableSize;\n        break;\n      }\n\n      chunks.push((0, _uint.readBytes)(size)(stream));\n      total += size;\n    }\n\n    var result = new Uint8Array(total);\n    var offset = 0;\n\n    for (var i = 0; i < chunks.length; i++) {\n      result.set(chunks[i], offset);\n      offset += chunks[i].length;\n    }\n\n    return result;\n  }\n}; // global control extension\n\nvar gceSchema = (0, _.conditional)({\n  gce: [{\n    codes: (0, _uint.readBytes)(2)\n  }, {\n    byteSize: (0, _uint.readByte)()\n  }, {\n    extras: (0, _uint.readBits)({\n      future: {\n        index: 0,\n        length: 3\n      },\n      disposal: {\n        index: 3,\n        length: 3\n      },\n      userInput: {\n        index: 6\n      },\n      transparentColorGiven: {\n        index: 7\n      }\n    })\n  }, {\n    delay: (0, _uint.readUnsigned)(true)\n  }, {\n    transparentColorIndex: (0, _uint.readByte)()\n  }, {\n    terminator: (0, _uint.readByte)()\n  }]\n}, function (stream) {\n  var codes = (0, _uint.peekBytes)(2)(stream);\n  return codes[0] === 0x21 && codes[1] === 0xf9;\n}); // image pipeline block\n\nvar imageSchema = (0, _.conditional)({\n  image: [{\n    code: (0, _uint.readByte)()\n  }, {\n    descriptor: [{\n      left: (0, _uint.readUnsigned)(true)\n    }, {\n      top: (0, _uint.readUnsigned)(true)\n    }, {\n      width: (0, _uint.readUnsigned)(true)\n    }, {\n      height: (0, _uint.readUnsigned)(true)\n    }, {\n      lct: (0, _uint.readBits)({\n        exists: {\n          index: 0\n        },\n        interlaced: {\n          index: 1\n        },\n        sort: {\n          index: 2\n        },\n        future: {\n          index: 3,\n          length: 2\n        },\n        size: {\n          index: 5,\n          length: 3\n        }\n      })\n    }]\n  }, (0, _.conditional)({\n    lct: (0, _uint.readArray)(3, function (stream, result, parent) {\n      return Math.pow(2, parent.descriptor.lct.size + 1);\n    })\n  }, function (stream, result, parent) {\n    return parent.descriptor.lct.exists;\n  }), {\n    data: [{\n      minCodeSize: (0, _uint.readByte)()\n    }, subBlocksSchema]\n  }]\n}, function (stream) {\n  return (0, _uint.peekByte)()(stream) === 0x2c;\n}); // plain text block\n\nvar textSchema = (0, _.conditional)({\n  text: [{\n    codes: (0, _uint.readBytes)(2)\n  }, {\n    blockSize: (0, _uint.readByte)()\n  }, {\n    preData: function preData(stream, result, parent) {\n      return (0, _uint.readBytes)(parent.text.blockSize)(stream);\n    }\n  }, subBlocksSchema]\n}, function (stream) {\n  var codes = (0, _uint.peekBytes)(2)(stream);\n  return codes[0] === 0x21 && codes[1] === 0x01;\n}); // application block\n\nvar applicationSchema = (0, _.conditional)({\n  application: [{\n    codes: (0, _uint.readBytes)(2)\n  }, {\n    blockSize: (0, _uint.readByte)()\n  }, {\n    id: function id(stream, result, parent) {\n      return (0, _uint.readString)(parent.blockSize)(stream);\n    }\n  }, subBlocksSchema]\n}, function (stream) {\n  var codes = (0, _uint.peekBytes)(2)(stream);\n  return codes[0] === 0x21 && codes[1] === 0xff;\n}); // comment block\n\nvar commentSchema = (0, _.conditional)({\n  comment: [{\n    codes: (0, _uint.readBytes)(2)\n  }, subBlocksSchema]\n}, function (stream) {\n  var codes = (0, _uint.peekBytes)(2)(stream);\n  return codes[0] === 0x21 && codes[1] === 0xfe;\n});\nvar schema = [{\n  header: [{\n    signature: (0, _uint.readString)(3)\n  }, {\n    version: (0, _uint.readString)(3)\n  }]\n}, {\n  lsd: [{\n    width: (0, _uint.readUnsigned)(true)\n  }, {\n    height: (0, _uint.readUnsigned)(true)\n  }, {\n    gct: (0, _uint.readBits)({\n      exists: {\n        index: 0\n      },\n      resolution: {\n        index: 1,\n        length: 3\n      },\n      sort: {\n        index: 4\n      },\n      size: {\n        index: 5,\n        length: 3\n      }\n    })\n  }, {\n    backgroundColorIndex: (0, _uint.readByte)()\n  }, {\n    pixelAspectRatio: (0, _uint.readByte)()\n  }]\n}, (0, _.conditional)({\n  gct: (0, _uint.readArray)(3, function (stream, result) {\n    return Math.pow(2, result.lsd.gct.size + 1);\n  })\n}, function (stream, result) {\n  return result.lsd.gct.exists;\n}), // content frames\n{\n  frames: (0, _.loop)([gceSchema, applicationSchema, commentSchema, imageSchema, textSchema], function (stream) {\n    var nextCode = (0, _uint.peekByte)()(stream); // rather than check for a terminator, we should check for the existence\n    // of an ext or image block to avoid infinite loops\n    //var terminator = 0x3B;\n    //return nextCode !== terminator;\n\n    return nextCode === 0x21 || nextCode === 0x2c;\n  })\n}];\nvar _default = schema;\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}