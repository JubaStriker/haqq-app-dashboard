{"ast":null,"code":"\"use strict\";\n/**\n * This is a very simple strongly typed event emitter class, see README.md\n * for more details.\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nexports.__esModule = true;\nexports.createEventEmitter = exports.Event = exports.createEmitter = exports.SealedEvent = exports.BaseEvent = void 0;\n/**\n * A ts-typed-events event to register callbacks on to be invoked when they are\n * emitted.\n */\n\nvar BaseEvent =\n/** @class */\nfunction () {\n  /**\n   * Marked as protected to discourage creation outside of\n   * createEventEmitter().\n   */\n  function BaseEvent() {\n    /** All the current listeners for this event. */\n    this.listeners = []; // pass\n  }\n  /**\n   * Attaches a callback to trigger on all emits for this event.\n   *\n   * @param callback - The callback to invoke on all emits.\n   */\n\n\n  BaseEvent.prototype.on = function (callback) {\n    this.listeners.push({\n      once: false,\n      callback: callback\n    });\n  };\n  /**\n   * Attaches a callback to trigger on only the first emit for this event.\n   *\n   * This version either takes a callback or returns a promise.\n   *\n   * @param callback - Optional callback, if specified invokes the callback\n   * only once when the event is triggered, then removes it.\n   * Otherwise returns a promise that resolves with the value the next time\n   * this event is triggered.\n   * @returns Nothing if a callback is passed, otherwise a Promise that\n   * should resolve once this Event emits.\n   */\n\n\n  BaseEvent.prototype.once = function (callback) {\n    var _this = this;\n\n    if (!callback) {\n      // then they want us to return the promise\n      var promise = new Promise(function (resolve) {\n        // this will invoke the version that has a callback,\n        // so resolve can be used as the callback\n        _this.once(resolve);\n      }); // attach the promise we just made to the listener (it was pushed\n      // on the end via this.once() above)\n\n      this.listeners[this.listeners.length - 1].promise = promise;\n      return promise;\n    } // else we were sent a normal callback, so attach it\n\n\n    this.listeners.push({\n      once: true,\n      callback: callback\n    });\n  };\n  /**\n   * Removes a callback from this event (regardless of once vs on).\n   *\n   * Returns true if a callback was removed, false otherwise.\n   *\n   * @param listener - The callback to remove.\n   * @returns True if a callback was removed, false otherwise.\n   */\n\n\n  BaseEvent.prototype.off = function (listener) {\n    var originalLength = this.listeners.length; // remove all listeners that have the same callback as this one\n\n    this.listeners = this.listeners.filter(function (l) {\n      return listener !== l.callback && (!l.promise || listener !== l.promise);\n    });\n    return this.listeners.length !== originalLength;\n  };\n  /**\n   * Removes ALL callbacks from this event, regardless of once vs on.\n   *\n   * Returns the number of listeners removed.\n   *\n   * @returns The number of listeners removed.\n   */\n\n\n  BaseEvent.prototype.offAll = function () {\n    var originalLength = this.listeners.length;\n    this.listeners.length = 0; // empty our listener array\n\n    return originalLength;\n  };\n\n  return BaseEvent;\n}();\n\nexports.BaseEvent = BaseEvent;\n/**\n * A ts-typed-events event to register callbacks on to be invoked when they are\n * emitted.\n *\n * This Event class signifies the event is \"sealed\" from the outside and cannot\n * be emitted through itself. The emitter function is separated.\n */\n\nvar SealedEvent =\n/** @class */\nfunction (_super) {\n  __extends(SealedEvent, _super);\n\n  function SealedEvent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return SealedEvent;\n}(BaseEvent);\n\nexports.SealedEvent = SealedEvent;\n/** @internal */\n\nfunction createEmitterWithBaseEvent(event) {\n  // Hack-y, we are reaching into to grab the listeners\n  // realistically, this would be a friend style function\n  var publicListenersEvent = event;\n  /**\n   * The emitter function for the event.\n   *\n   * @param emitting - Whatever is being emitted.\n   * @returns True if any listeners were emitted to, false otherwise.\n   */\n\n  function emit(emitting) {\n    var listeners = publicListenersEvent.listeners;\n    var hadListeners = listeners.length > 0;\n\n    for (var _i = 0, listeners_1 = listeners; _i < listeners_1.length; _i++) {\n      var listener = listeners_1[_i];\n      listener.callback(emitting);\n    } // remove all listeners that only wanted to listen once\n\n\n    publicListenersEvent.listeners = listeners.filter(function (_a) {\n      var once = _a.once;\n      return !once;\n    });\n    return hadListeners;\n  } // Hack: Need to find a better way to convince TS this function will have\n  // the correct keys on these circular functions.\n\n  /* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access */\n\n\n  var func = emit;\n  func.event = event;\n  func.emit = emit;\n  var emitter = func;\n  /* eslint-enable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access */\n\n  return emitter;\n}\n/**\n * Creates and returns an emitter for a SealedEvent, with the event keyed off\n * the emitter via `.event`.\n *\n * @returns An emitter function that will emit to the `.event` SealedEvent.\n */\n\n\nfunction createEmitter() {\n  // This is a hack-y way to create a new class instance that doesn't want you\n  // to.\n  var EventClass = SealedEvent;\n  return createEmitterWithBaseEvent(new EventClass());\n}\n\nexports.createEmitter = createEmitter;\n/**\n * A specialized Event that holds a reference to its own emit function.\n * This allows any code with access to the Event to also trigger emits.\n */\n\nvar Event =\n/** @class */\nfunction (_super) {\n  __extends(Event, _super);\n  /**\n   * Creates a new Event, with its emit accessible as a member function.\n   */\n\n\n  function Event() {\n    var _this = _super.call(this) || this;\n    /**\n     * Emits a value to all the listeners, triggering their callbacks.\n     * Returns true if the event had listeners emitted to,\n     * false otherwise.\n     * Because this exists on the event, any code with access to this event\n     * can trigger the callback for all listeners.\n     *\n     * @param emitting - If the Event has a type, this is the data of that type\n     * to emit to all listeners. If no type (undefined) this argument should\n     * be omitted.\n     * @returns True if the event had listeners emitted to, false otherwise.\n     */\n\n\n    _this.emit = createEmitterWithBaseEvent(_this);\n    return _this;\n  }\n\n  return Event;\n}(BaseEvent);\n\nexports.Event = Event;\n/**\n * Creates and returns an emitter for an Event, with the event keyed off\n * the emitter via `.event`.\n * **Note**: The `event` here is will have a member function `.emit` that emits\n * to the same function as the emitter returned here.\n *\n * @returns An emitter function that will emit to the `.event` Event.\n */\n\nfunction createEventEmitter() {\n  return createEmitterWithBaseEvent(new Event());\n}\n\nexports.createEventEmitter = createEventEmitter;","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/hbar-shop/hbar-shop-dashboard/node_modules/ts-typed-events/dist/index.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__","constructor","create","exports","__esModule","createEventEmitter","Event","createEmitter","SealedEvent","BaseEvent","listeners","on","callback","push","once","_this","promise","Promise","resolve","length","off","listener","originalLength","filter","l","offAll","_super","apply","arguments","createEmitterWithBaseEvent","event","publicListenersEvent","emit","emitting","hadListeners","_i","listeners_1","_a","func","emitter","EventClass"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * This is a very simple strongly typed event emitter class, see README.md\n * for more details.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nexports.__esModule = true;\nexports.createEventEmitter = exports.Event = exports.createEmitter = exports.SealedEvent = exports.BaseEvent = void 0;\n/**\n * A ts-typed-events event to register callbacks on to be invoked when they are\n * emitted.\n */\nvar BaseEvent = /** @class */ (function () {\n    /**\n     * Marked as protected to discourage creation outside of\n     * createEventEmitter().\n     */\n    function BaseEvent() {\n        /** All the current listeners for this event. */\n        this.listeners = [];\n        // pass\n    }\n    /**\n     * Attaches a callback to trigger on all emits for this event.\n     *\n     * @param callback - The callback to invoke on all emits.\n     */\n    BaseEvent.prototype.on = function (callback) {\n        this.listeners.push({\n            once: false,\n            callback: callback\n        });\n    };\n    /**\n     * Attaches a callback to trigger on only the first emit for this event.\n     *\n     * This version either takes a callback or returns a promise.\n     *\n     * @param callback - Optional callback, if specified invokes the callback\n     * only once when the event is triggered, then removes it.\n     * Otherwise returns a promise that resolves with the value the next time\n     * this event is triggered.\n     * @returns Nothing if a callback is passed, otherwise a Promise that\n     * should resolve once this Event emits.\n     */\n    BaseEvent.prototype.once = function (callback) {\n        var _this = this;\n        if (!callback) {\n            // then they want us to return the promise\n            var promise = new Promise(function (resolve) {\n                // this will invoke the version that has a callback,\n                // so resolve can be used as the callback\n                _this.once(resolve);\n            });\n            // attach the promise we just made to the listener (it was pushed\n            // on the end via this.once() above)\n            this.listeners[this.listeners.length - 1].promise = promise;\n            return promise;\n        }\n        // else we were sent a normal callback, so attach it\n        this.listeners.push({\n            once: true,\n            callback: callback\n        });\n    };\n    /**\n     * Removes a callback from this event (regardless of once vs on).\n     *\n     * Returns true if a callback was removed, false otherwise.\n     *\n     * @param listener - The callback to remove.\n     * @returns True if a callback was removed, false otherwise.\n     */\n    BaseEvent.prototype.off = function (listener) {\n        var originalLength = this.listeners.length;\n        // remove all listeners that have the same callback as this one\n        this.listeners = this.listeners.filter(function (l) {\n            return listener !== l.callback && (!l.promise || listener !== l.promise);\n        });\n        return this.listeners.length !== originalLength;\n    };\n    /**\n     * Removes ALL callbacks from this event, regardless of once vs on.\n     *\n     * Returns the number of listeners removed.\n     *\n     * @returns The number of listeners removed.\n     */\n    BaseEvent.prototype.offAll = function () {\n        var originalLength = this.listeners.length;\n        this.listeners.length = 0; // empty our listener array\n        return originalLength;\n    };\n    return BaseEvent;\n}());\nexports.BaseEvent = BaseEvent;\n/**\n * A ts-typed-events event to register callbacks on to be invoked when they are\n * emitted.\n *\n * This Event class signifies the event is \"sealed\" from the outside and cannot\n * be emitted through itself. The emitter function is separated.\n */\nvar SealedEvent = /** @class */ (function (_super) {\n    __extends(SealedEvent, _super);\n    function SealedEvent() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return SealedEvent;\n}(BaseEvent));\nexports.SealedEvent = SealedEvent;\n/** @internal */\nfunction createEmitterWithBaseEvent(event) {\n    // Hack-y, we are reaching into to grab the listeners\n    // realistically, this would be a friend style function\n    var publicListenersEvent = event;\n    /**\n     * The emitter function for the event.\n     *\n     * @param emitting - Whatever is being emitted.\n     * @returns True if any listeners were emitted to, false otherwise.\n     */\n    function emit(emitting) {\n        var listeners = publicListenersEvent.listeners;\n        var hadListeners = listeners.length > 0;\n        for (var _i = 0, listeners_1 = listeners; _i < listeners_1.length; _i++) {\n            var listener = listeners_1[_i];\n            listener.callback(emitting);\n        }\n        // remove all listeners that only wanted to listen once\n        publicListenersEvent.listeners = listeners.filter(function (_a) {\n            var once = _a.once;\n            return !once;\n        });\n        return hadListeners;\n    }\n    // Hack: Need to find a better way to convince TS this function will have\n    // the correct keys on these circular functions.\n    /* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access */\n    var func = emit;\n    func.event = event;\n    func.emit = emit;\n    var emitter = func;\n    /* eslint-enable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access */\n    return emitter;\n}\n/**\n * Creates and returns an emitter for a SealedEvent, with the event keyed off\n * the emitter via `.event`.\n *\n * @returns An emitter function that will emit to the `.event` SealedEvent.\n */\nfunction createEmitter() {\n    // This is a hack-y way to create a new class instance that doesn't want you\n    // to.\n    var EventClass = SealedEvent;\n    return createEmitterWithBaseEvent(new EventClass());\n}\nexports.createEmitter = createEmitter;\n/**\n * A specialized Event that holds a reference to its own emit function.\n * This allows any code with access to the Event to also trigger emits.\n */\nvar Event = /** @class */ (function (_super) {\n    __extends(Event, _super);\n    /**\n     * Creates a new Event, with its emit accessible as a member function.\n     */\n    function Event() {\n        var _this = _super.call(this) || this;\n        /**\n         * Emits a value to all the listeners, triggering their callbacks.\n         * Returns true if the event had listeners emitted to,\n         * false otherwise.\n         * Because this exists on the event, any code with access to this event\n         * can trigger the callback for all listeners.\n         *\n         * @param emitting - If the Event has a type, this is the data of that type\n         * to emit to all listeners. If no type (undefined) this argument should\n         * be omitted.\n         * @returns True if the event had listeners emitted to, false otherwise.\n         */\n        _this.emit = createEmitterWithBaseEvent(_this);\n        return _this;\n    }\n    return Event;\n}(BaseEvent));\nexports.Event = Event;\n/**\n * Creates and returns an emitter for an Event, with the event keyed off\n * the emitter via `.event`.\n * **Note**: The `event` here is will have a member function `.emit` that emits\n * to the same function as the emitter returned here.\n *\n * @returns An emitter function that will emit to the `.event` Event.\n */\nfunction createEventEmitter() {\n    return createEmitterWithBaseEvent(new Event());\n}\nexports.createEventEmitter = createEventEmitter;\n"]},"metadata":{},"sourceType":"script"}