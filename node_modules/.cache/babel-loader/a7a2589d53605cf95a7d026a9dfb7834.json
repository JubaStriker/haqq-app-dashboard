{"ast":null,"code":"/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\nimport * as cryptography from \"@hashgraph/cryptography\";\nimport { arrayEqual } from \"./array.js\";\nimport Key from \"./Key.js\";\nimport CACHE from \"./Cache.js\";\n/**\n * @typedef {import(\"./transaction/Transaction.js\").default} Transaction\n * @typedef {import(\"./account/AccountId.js\").default} AccountId\n */\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").proto.IKey} HashgraphProto.proto.IKey\n * @typedef {import(\"@hashgraph/proto\").proto.ITransaction} HashgraphProto.proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").proto.ISignaturePair} HashgraphProto.proto.ISignaturePair\n * @typedef {import(\"@hashgraph/proto\").proto.ISignedTransaction} HashgraphProto.proto.ISignedTransaction\n */\n\nexport default class PublicKey extends Key {\n  /**\n   * @internal\n   * @hideconstructor\n   * @param {cryptography.PublicKey} key\n   */\n  constructor(key) {\n    super();\n    this._key = key;\n  }\n  /**\n   * @param {Uint8Array} data\n   * @returns {PublicKey}\n   */\n\n\n  static fromBytes(data) {\n    return new PublicKey(cryptography.PublicKey.fromBytes(data));\n  }\n  /**\n   * @param {Uint8Array} data\n   * @returns {PublicKey}\n   */\n\n\n  static fromBytesED25519(data) {\n    return new PublicKey(cryptography.PublicKey.fromBytesED25519(data));\n  }\n  /**\n   * @param {Uint8Array} data\n   * @returns {PublicKey}\n   */\n\n\n  static fromBytesECDSA(data) {\n    return new PublicKey(cryptography.PublicKey.fromBytesECDSA(data));\n  }\n  /**\n   * Parse a public key from a string of hexadecimal digits.\n   *\n   * The public key may optionally be prefixed with\n   * the DER header.\n   *\n   * @param {string} text\n   * @returns {PublicKey}\n   */\n\n\n  static fromString(text) {\n    return new PublicKey(cryptography.PublicKey.fromString(text));\n  }\n  /**\n   * Verify a signature on a message with this public key.\n   *\n   * @param {Uint8Array} message\n   * @param {Uint8Array} signature\n   * @returns {boolean}\n   */\n\n\n  verify(message, signature) {\n    return this._key.verify(message, signature);\n  }\n  /**\n   * @param {Transaction} transaction\n   * @returns {boolean}\n   */\n\n\n  verifyTransaction(transaction) {\n    transaction._requireFrozen();\n\n    if (!transaction.isFrozen()) {\n      transaction.freeze();\n    }\n\n    for (const signedTransaction of transaction._signedTransactions.list) {\n      if (signedTransaction.sigMap != null && signedTransaction.sigMap.sigPair != null) {\n        let found = false;\n\n        for (const sigPair of signedTransaction.sigMap.sigPair) {\n          const pubKeyPrefix =\n          /** @type {Uint8Array} */\n          sigPair.pubKeyPrefix;\n\n          if (arrayEqual(pubKeyPrefix, this.toBytesRaw())) {\n            found = true;\n            const bodyBytes =\n            /** @type {Uint8Array} */\n            signedTransaction.bodyBytes;\n            let signature = null;\n\n            if (sigPair.ed25519 != null) {\n              signature = sigPair.ed25519;\n            } else if (sigPair.ECDSASecp256k1 != null) {\n              signature = sigPair.ECDSASecp256k1;\n            }\n\n            if (signature == null) {\n              continue;\n            }\n\n            if (!this.verify(bodyBytes, signature)) {\n              return false;\n            }\n          }\n        }\n\n        if (!found) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n\n\n  toBytes() {\n    return this._key.toBytes();\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n\n\n  toBytesDer() {\n    return this._key.toBytesDer();\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n\n\n  toBytesRaw() {\n    return this._key.toBytesRaw();\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  toEthereumAddress() {\n    return this._key.toEthereumAddress();\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  toString() {\n    return this._key.toString();\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  toStringDer() {\n    return this._key.toStringDer();\n  }\n  /**\n   * @returns {string}\n   */\n\n\n  toStringRaw() {\n    return this._key.toStringRaw();\n  }\n  /**\n   * @param {PublicKey} other\n   * @returns {boolean}\n   */\n\n\n  equals(other) {\n    return this._key.equals(other._key);\n  }\n  /**\n   * @returns {HashgraphProto.proto.IKey}\n   */\n\n\n  _toProtobufKey() {\n    switch (this._key._type) {\n      case \"ED25519\":\n        return {\n          ed25519: this._key.toBytesRaw()\n        };\n\n      case \"secp256k1\":\n        return {\n          ECDSASecp256k1: this._key.toBytesRaw()\n        };\n\n      default:\n        throw new Error(`unrecognized key type ${this._key._type}`);\n    }\n  }\n  /**\n   * @param {Uint8Array} signature\n   * @returns {HashgraphProto.proto.ISignaturePair}\n   */\n\n\n  _toProtobufSignature(signature) {\n    switch (this._key._type) {\n      case \"ED25519\":\n        return {\n          pubKeyPrefix: this._key.toBytesRaw(),\n          ed25519: signature\n        };\n\n      case \"secp256k1\":\n        return {\n          pubKeyPrefix: this._key.toBytesRaw(),\n          ECDSASecp256k1: signature\n        };\n\n      default:\n        throw new Error(`unrecognized key type ${this._key._type}`);\n    }\n  }\n  /**\n   * @param {Long | number} shard\n   * @param {Long | number} realm\n   * @returns {AccountId}\n   */\n\n\n  toAccountId(shard, realm) {\n    return CACHE.accountIdConstructor(shard, realm, this);\n  }\n\n}\nCACHE.setPublicKeyED25519(key => PublicKey.fromBytesED25519(key));\nCACHE.setPublicKeyECDSA(key => PublicKey.fromBytesECDSA(key));","map":{"version":3,"sources":["/Users/jithendra/Desktop/Work/hbar-shop/hbar-shop-dashboard/node_modules/@hashgraph/sdk/src/PublicKey.js"],"names":["cryptography","arrayEqual","Key","CACHE","PublicKey","constructor","key","_key","fromBytes","data","fromBytesED25519","fromBytesECDSA","fromString","text","verify","message","signature","verifyTransaction","transaction","_requireFrozen","isFrozen","freeze","signedTransaction","_signedTransactions","list","sigMap","sigPair","found","pubKeyPrefix","toBytesRaw","bodyBytes","ed25519","ECDSASecp256k1","toBytes","toBytesDer","toEthereumAddress","toString","toStringDer","toStringRaw","equals","other","_toProtobufKey","_type","Error","_toProtobufSignature","toAccountId","shard","realm","accountIdConstructor","setPublicKeyED25519","setPublicKeyECDSA"],"mappings":"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","sourcesContent":["/*-\n * ‌\n * Hedera JavaScript SDK\n * ​\n * Copyright (C) 2020 - 2022 Hedera Hashgraph, LLC\n * ​\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ‍\n */\n\nimport * as cryptography from \"@hashgraph/cryptography\";\nimport { arrayEqual } from \"./array.js\";\nimport Key from \"./Key.js\";\nimport CACHE from \"./Cache.js\";\n\n/**\n * @typedef {import(\"./transaction/Transaction.js\").default} Transaction\n * @typedef {import(\"./account/AccountId.js\").default} AccountId\n */\n\n/**\n * @namespace proto\n * @typedef {import(\"@hashgraph/proto\").proto.IKey} HashgraphProto.proto.IKey\n * @typedef {import(\"@hashgraph/proto\").proto.ITransaction} HashgraphProto.proto.ITransaction\n * @typedef {import(\"@hashgraph/proto\").proto.ISignaturePair} HashgraphProto.proto.ISignaturePair\n * @typedef {import(\"@hashgraph/proto\").proto.ISignedTransaction} HashgraphProto.proto.ISignedTransaction\n */\n\nexport default class PublicKey extends Key {\n    /**\n     * @internal\n     * @hideconstructor\n     * @param {cryptography.PublicKey} key\n     */\n    constructor(key) {\n        super();\n\n        this._key = key;\n    }\n\n    /**\n     * @param {Uint8Array} data\n     * @returns {PublicKey}\n     */\n    static fromBytes(data) {\n        return new PublicKey(cryptography.PublicKey.fromBytes(data));\n    }\n\n    /**\n     * @param {Uint8Array} data\n     * @returns {PublicKey}\n     */\n    static fromBytesED25519(data) {\n        return new PublicKey(cryptography.PublicKey.fromBytesED25519(data));\n    }\n\n    /**\n     * @param {Uint8Array} data\n     * @returns {PublicKey}\n     */\n    static fromBytesECDSA(data) {\n        return new PublicKey(cryptography.PublicKey.fromBytesECDSA(data));\n    }\n\n    /**\n     * Parse a public key from a string of hexadecimal digits.\n     *\n     * The public key may optionally be prefixed with\n     * the DER header.\n     *\n     * @param {string} text\n     * @returns {PublicKey}\n     */\n    static fromString(text) {\n        return new PublicKey(cryptography.PublicKey.fromString(text));\n    }\n\n    /**\n     * Verify a signature on a message with this public key.\n     *\n     * @param {Uint8Array} message\n     * @param {Uint8Array} signature\n     * @returns {boolean}\n     */\n    verify(message, signature) {\n        return this._key.verify(message, signature);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @returns {boolean}\n     */\n    verifyTransaction(transaction) {\n        transaction._requireFrozen();\n\n        if (!transaction.isFrozen()) {\n            transaction.freeze();\n        }\n\n        for (const signedTransaction of transaction._signedTransactions.list) {\n            if (\n                signedTransaction.sigMap != null &&\n                signedTransaction.sigMap.sigPair != null\n            ) {\n                let found = false;\n                for (const sigPair of signedTransaction.sigMap.sigPair) {\n                    const pubKeyPrefix = /** @type {Uint8Array} */ (\n                        sigPair.pubKeyPrefix\n                    );\n                    if (arrayEqual(pubKeyPrefix, this.toBytesRaw())) {\n                        found = true;\n\n                        const bodyBytes = /** @type {Uint8Array} */ (\n                            signedTransaction.bodyBytes\n                        );\n\n                        let signature = null;\n                        if (sigPair.ed25519 != null) {\n                            signature = sigPair.ed25519;\n                        } else if (sigPair.ECDSASecp256k1 != null) {\n                            signature = sigPair.ECDSASecp256k1;\n                        }\n\n                        if (signature == null) {\n                            continue;\n                        }\n\n                        if (!this.verify(bodyBytes, signature)) {\n                            return false;\n                        }\n                    }\n                }\n\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytes() {\n        return this._key.toBytes();\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytesDer() {\n        return this._key.toBytesDer();\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    toBytesRaw() {\n        return this._key.toBytesRaw();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toEthereumAddress() {\n        return this._key.toEthereumAddress();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return this._key.toString();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toStringDer() {\n        return this._key.toStringDer();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toStringRaw() {\n        return this._key.toStringRaw();\n    }\n\n    /**\n     * @param {PublicKey} other\n     * @returns {boolean}\n     */\n    equals(other) {\n        return this._key.equals(other._key);\n    }\n\n    /**\n     * @returns {HashgraphProto.proto.IKey}\n     */\n    _toProtobufKey() {\n        switch (this._key._type) {\n            case \"ED25519\":\n                return {\n                    ed25519: this._key.toBytesRaw(),\n                };\n            case \"secp256k1\":\n                return {\n                    ECDSASecp256k1: this._key.toBytesRaw(),\n                };\n            default:\n                throw new Error(`unrecognized key type ${this._key._type}`);\n        }\n    }\n\n    /**\n     * @param {Uint8Array} signature\n     * @returns {HashgraphProto.proto.ISignaturePair}\n     */\n    _toProtobufSignature(signature) {\n        switch (this._key._type) {\n            case \"ED25519\":\n                return {\n                    pubKeyPrefix: this._key.toBytesRaw(),\n                    ed25519: signature,\n                };\n            case \"secp256k1\":\n                return {\n                    pubKeyPrefix: this._key.toBytesRaw(),\n                    ECDSASecp256k1: signature,\n                };\n            default:\n                throw new Error(`unrecognized key type ${this._key._type}`);\n        }\n    }\n\n    /**\n     * @param {Long | number} shard\n     * @param {Long | number} realm\n     * @returns {AccountId}\n     */\n    toAccountId(shard, realm) {\n        return CACHE.accountIdConstructor(shard, realm, this);\n    }\n}\n\nCACHE.setPublicKeyED25519((key) => PublicKey.fromBytesED25519(key));\nCACHE.setPublicKeyECDSA((key) => PublicKey.fromBytesECDSA(key));\n"]},"metadata":{},"sourceType":"module"}